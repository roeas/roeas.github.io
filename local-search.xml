<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>博客传送门</title>
    <link href="/2024/10/06/Blog/"/>
    <url>/2024/10/06/Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p><a href="https://t-rvw.github.io/blog/">CatDogEngine</a><br><a href="https://technology.riotgames.com/tags/rendering">RiotGames</a><br><a href="https://sebh.github.io/publications/">Sébastien Hillaire’s website</a><br><a href="http://evasion.inrialpes.fr/~Eric.Bruneton/">Eric Bruneton</a><br><a href="https://www.scratchapixel.com/index.php?redirect">Scratchapixel</a><br><a href="http://walkingfat.com/">WalkingFat</a><br><a href="https://www.qiujiawei.com/">Wyman 的原创技术博客</a><br><a href="https://iquilezles.org/">Inigo Quilez</a><br><a href="http://kevinbeason.com/">Kevin Beason</a><br><a href="http://candycat1992.github.io/">Candycat Blog</a><br><a href="https://wickedengine.net/">Wicked Engine Net</a><br><a href="https://www.cnblogs.com/miloyip/">Milo 的游戏开发</a><br><a href="http://blog.hakugyokurou.net/">白玉楼之梦 - szszss’ blog</a><br><a href="https://blog.selfshadow.com/">Self Shadow</a><br><a href="https://www.cnblogs.com/ghl_carmack/">风恋残雪</a><br><a href="https://qiankanglai.me/">Loading &amp; Learning</a><br><a href="https://baddogzz.github.io/">恶毒的狗</a><br><a href="https://www.cnblogs.com/X-Jun/">X_Jun</a><br><a href="http://www.cppblog.com/Leaf/">麒麟子</a><br><a href="http://www.klayge.org/">KlayGE 游戏引擎</a><br><a href="https://imgeself.github.io/">Dear World,</a><br><a href="https://zhuanlan.zhihu.com/p/36675543">虚幻 4 渲染编程专题概述及目录</a><br><a href="https://blog.codingnow.com/">云风的 BLOG</a><br><a href="https://placeholderart.wordpress.com/">Placeholder Art</a><br><a href="https://knarkowicz.wordpress.com/">Krzysztof Narkowicz</a><br><a href="https://technology.riotgames.com/">RIOT GAMMES TECHBLOG</a><br><a href="https://agraphicsguynotes.com/">A GRAPHICS GUY’S NOTE</a><br><a href="https://kesen.realtimerendering.com/">Ke-Sen Huang’s Home Page</a><br><a href="https://www.o3de.org/community/">O3DE Community</a><br><a href="https://www.cnblogs.com/KillerAery/">KillerAery</a><br><a href="https://neil3d.gitee.io/reading/index.html">游戏程序员的自我修养</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>现代 C++ 随记</title>
    <link href="/2024/05/02/CPP/"/>
    <url>/2024/05/02/CPP/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>现代 C++ 相关的笔记。</p><h2 id="inline-和-static"><a href="#inline-和-static" class="headerlink" title="inline 和 static"></a>inline 和 static</h2><h3 id="唯一定义原则"><a href="#唯一定义原则" class="headerlink" title="唯一定义原则"></a>唯一定义原则</h3><p><a href="https://en.cppreference.com/w/cpp/language/definition">https://en.cppreference.com/w/cpp/language/definition</a></p><p><code>extern int a;</code> 是声明。<br><code>int a;</code>, <code>int a = 1;</code>, <code>extern int a = 1;</code> 都是定义。</p><p><code>void foo();</code> 是声明。<br><code>void foo() &#123;&#125;</code> 是定义。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li>将定义的可见性限制到当前翻译单元，使得不同翻译单元之间同名定义不冲突。</li><li>实际上根据不同的用法 static 可以控制可见性，也可以控制生命周期，这里我们只讨论可见性相关的功能。</li></ul><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><ul><li>可以在多个翻译单元内存在同名 inline 定义，编译器选择其中一份作为唯一的定义，具体选择哪份定义则是未定义行为。</li><li>既有 static 的优点，可以写在头文件内被不同翻译单元包含，又有 extern 的优点，可以全局共享。</li></ul><h3 id="对于成员变量"><a href="#对于成员变量" class="headerlink" title="对于成员变量"></a>对于成员变量</h3><p><code>inline static</code> 的成员变量可以直接在头文件内声明与定义，免去了再在 cpp 文件里写一份成员变量定义的繁琐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span><br>&#123;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> member = <span class="hljs-number">42</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="对于函数"><a href="#对于函数" class="headerlink" title="对于函数"></a>对于函数</h3><ul><li>写在头文件里的 static 函数定义自然不会产生冲突，但是 static 也导致不同翻译单元之间各包含一份函数定义，导致最终生成的目标体积增大。inline 很好地解决了这个问题，因为连接器最终只会将 inline 函数链接到同一份定义，指向同一个函数地址。</li><li>include 同一份头文件更不会产生连接器链接到不同的定义（函数体）的问题。</li><li>同时，整个定义都在 class &#x2F; struct &#x2F; union 内的函数，隐式的是 inline 的。</li><li>顺便，直接写定义的模板函数是也默认 inline 的。</li></ul><h3 id="对于类"><a href="#对于类" class="headerlink" title="对于类"></a>对于类</h3><ul><li>可惜不能将 class 声明为 static，但是要解决这个问题也很简单，将类的定义放在一个匿名命名空间即可将该类的可见范围限制在当前翻译单元。</li><li>匿名命名空间下的函数定义和 static 的函数定义效果也是一样的。</li></ul><h3 id="至于内联"><a href="#至于内联" class="headerlink" title="至于内联"></a>至于内联</h3><ul><li>自 C++17 之后 inline 的意义产生了巨大的变化，对于函数的含义已经变为“容许重定义”而不是“建议内联”。</li><li>比如对于 MSVC，可以使用 <code>__forceinline</code> 放宽编译器对内联函数的判断，不过编译器依旧不一定会听你的。</li></ul><h2 id="前向声明与-std-unique-ptr"><a href="#前向声明与-std-unique-ptr" class="headerlink" title="前向声明与 std::unique_ptr"></a>前向声明与 std::unique_ptr</h2><p>假设我们前向声明了一个 <code>T</code>。<br>当一个类持有 <code>std::unique_ptr&lt;T&gt;</code> 类型的成员变量时，该类的析构函数必须也只能在 cpp 内有定义（当然一般来说这时 cpp 内是有 T 的完整定义的）。<br>理由很简单，该类析构时需要调用 unique_ptr 所包裹对象的析构函数，但是默认生成的析构函数是头文件中的内联函数，而在头文件内自然是不知道 T 该如何析构的。<br>将类的析构函数的定义移至 cpp 相当于向其告知了 T 的析构方式。</p><h3 id="static-std-unique-ptr"><a href="#static-std-unique-ptr" class="headerlink" title="static std::unique_ptr"></a>static std::unique_ptr</h3><p>前向声明不可用于 <code>inline static std::unique_ptr&lt;T&gt;</code> 类型的成员变量。<br>静态成员变量的生命周期已经脱离了类实例的生命周期，此时 unique_ptr 需要在该静态成员变量的定义处得知 T 的完整定义。<br><code>inline static</code> 成员变量的定义处自然是头文件，故此时会编译失败。将静态成员变量的定义分离至 cpp（总之是有类完整定义的地方）内才能编译。</p><h2 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h2><p>在完美转发返回值时尤为有用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">PerfectForward</span><span class="hljs-params">(F fun, Args&amp;&amp;... args)</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fun</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">auto</span> c0 = a;             <span class="hljs-comment">// c0 的类型是 int，保有 a 的副本</span><br>    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) c1 = a;   <span class="hljs-comment">// c1 的类型是 int，保有 a 的副本</span><br>    <span class="hljs-keyword">auto</span> c2 = (a);           <span class="hljs-comment">// c2 的类型是 int，保有 a 的副本</span><br>    <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) c3 = (a); <span class="hljs-comment">// c3 的类型是 int&amp;，它是 a 的别名</span><br>    <br>    <span class="hljs-keyword">auto</span> d = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// OK：d 的类型是 std::initializer_list&lt;int&gt;</span><br>    <span class="hljs-keyword">auto</span> n = &#123;<span class="hljs-number">5</span>&#125;;    <span class="hljs-comment">// OK：n 的类型是 std::initializer_list&lt;int&gt;</span><br><span class="hljs-comment">//  auto e&#123;1, 2&#125;;    // C++17 起错误，之前是 std::initializer_list&lt;int&gt;</span><br>    <span class="hljs-keyword">auto</span> m&#123;<span class="hljs-number">5</span>&#125;;       <span class="hljs-comment">// OK：DR N3922 起 m 的类型是 int，之前是 initializer_list&lt;int&gt;</span><br><span class="hljs-comment">//  decltype(auto) z = &#123; 1, 2 &#125; // 错误：&#123;1, 2&#125; 不是表达式</span><br></code></pre></td></tr></table></figure><h2 id="简写函数模板"><a href="#简写函数模板" class="headerlink" title="简写函数模板"></a>简写函数模板</h2><p>在 C++20 中，auto 能推导出作为参数的函数对象，也能推导出可变长参数<br>上面的 <code>PerfectForward</code> 也可以写成:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">PerfectForward</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> fun, <span class="hljs-keyword">auto</span> &amp;&amp;...args)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fun</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>C++ 的最终形态一定是 auto auto &#x3D; auto(auto); 罢</em></p><h2 id="概念与约束（concept-requires）"><a href="#概念与约束（concept-requires）" class="headerlink" title="概念与约束（concept &amp; requires）"></a>概念与约束（concept &amp; requires）</h2><p>模板的报错往往极度缺乏可读性，我们希望在编写模板时就对可能发生的情况做出一定的约束，使得违反约束的调用不要实例化，以避免产生难以阅读的报错信息。<br>这项技巧叫做 SFINE（Substitution Failure Is Not An Error），自 C++20 起 concept 与 requires 加入了标准，大大简化了 SFINE 的编写与理解难度。</p><h3 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h3><p>这是一个概念：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;模板形参列表&gt;<br><span class="hljs-keyword">concept</span> 概念名 = 编译期布尔表达式;<br></code></pre></td></tr></table></figure><p>ex:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 无条件成立</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C0 = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 要求 T 为整数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C1 = std::is_integral_v&lt;T&gt;;<br><br><span class="hljs-comment">// 要求 T 为浮点或者有符号</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C2 = std::is_floating_point_v&lt;T&gt; || std::is_signed_v&lt;T&gt;;<br><br><span class="hljs-comment">// 要求 T 为无符号整数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C3 = C1&lt;T&gt; &amp;&amp; !std::is_signed_v&lt;T&gt;;<br><br>C0&lt;<span class="hljs-type">int</span>&gt;   <span class="hljs-comment">// 编译期返回 true</span><br>C1&lt;<span class="hljs-type">int</span>&gt;   <span class="hljs-comment">// 编译期返回 true</span><br>C2&lt;<span class="hljs-type">int</span>&gt;   <span class="hljs-comment">// 编译期返回 true</span><br>C2&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-comment">// 编译期返回 true</span><br>C3&lt;uint&gt;  <span class="hljs-comment">// 编译期返回 true</span><br></code></pre></td></tr></table></figure><p>这是一个受 concept 约束的函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 要求 T 为无符号整数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = std::is_integral_v&lt;T&gt; &amp;&amp; !std::is_signed_v&lt;T&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;C T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(T t)</span></span>&#123;&#125;<br><br><span class="hljs-built_in">Foo</span>(<span class="hljs-number">42U</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">Foo</span>(<span class="hljs-number">42.0</span>); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>这是一个受 concept 约束的简写函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 要求 T 为无符号整数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = std::is_integral_v&lt;T&gt; &amp;&amp; !std::is_signed_v&lt;T&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(C <span class="hljs-keyword">auto</span> t)</span></span>&#123;&#125;<br><br><span class="hljs-built_in">Foo</span>(<span class="hljs-number">42U</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">Foo</span>(<span class="hljs-number">42.0</span>); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>标准库已经提供了很多简单且常用的概念：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;concepts&gt;</span></span><br><br><span class="hljs-comment">// 要求 t 为无符号整数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(std::unsigned_integral <span class="hljs-keyword">auto</span> t)</span></span>&#123;&#125;<br><br><span class="hljs-built_in">Foo</span>(<span class="hljs-number">42U</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">Foo</span>(<span class="hljs-number">42.0</span>); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h3 id="requires-表达式"><a href="#requires-表达式" class="headerlink" title="requires 表达式"></a>requires 表达式</h3><p>这是一个 requires 表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">requires</span>&#123; 要求序列 &#125;<br></code></pre></td></tr></table></figure><p>因为他在编译期返回一个布尔，所以可以接在 concept 后面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-keyword">requires</span>&#123; 要求序列 &#125;;<br></code></pre></td></tr></table></figure><p>这是一个简单要求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">StaticFoo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C0 = <span class="hljs-keyword">requires</span>&#123; T::<span class="hljs-built_in">StaticFoo</span>(); &#125;<br><br><span class="hljs-comment">// 可以有形参</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C1 = <span class="hljs-built_in">requires</span>(T t)&#123; t.<span class="hljs-built_in">Foo</span>(); &#125;<br></code></pre></td></tr></table></figure><p>requires 表达式不实际运行大括号内的代码，只检测代码的有效性。</p><p>这是一个类型要求，以关键字 typename 开头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Type0</span>&#123;&#125;;<br>    <span class="hljs-keyword">using</span> Type1 = <span class="hljs-type">int</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span>&#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> Ref = T&amp;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-keyword">requires</span><br>&#123;<br>    <span class="hljs-keyword">typename</span> T::Type0; <span class="hljs-comment">// 要求嵌套类型</span><br>    <span class="hljs-keyword">typename</span> T::type1; <span class="hljs-comment">// 要求嵌套类型</span><br>    <span class="hljs-keyword">typename</span> S&lt;T&gt;;     <span class="hljs-comment">// 要求类模板特化</span><br>    <span class="hljs-keyword">typename</span> Ref&lt;T&gt;;   <span class="hljs-comment">// 要求别名模板代换</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个复合要求，不但检查代码的有效性，还可以检查返回值类型和 noexcept：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-built_in">requires</span>(T t)<br>&#123;<br>    <span class="hljs-comment">// 要求 T 重载了 operator+，并且要求其返回值可以被转换为 bool</span><br>    &#123; t + t &#125; -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;<br>    <span class="hljs-comment">// 要求 T 重载了 operator-，并且要求其返回值为 int</span><br>    &#123; t - t &#125; -&gt; std::same_as&lt;<span class="hljs-type">int</span>&gt;;<br>    <span class="hljs-comment">// 要求 `x.~T()` 是不会抛出异常的合法表达式</span><br>    &#123; t.~<span class="hljs-built_in">T</span>() &#125; <span class="hljs-keyword">noexcept</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是一个嵌套要求，由关键字 requires 开头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">requires</span><br>&#123;<br>    <span class="hljs-keyword">requires</span> 编译期布尔表达式;<br>&#125;;<br></code></pre></td></tr></table></figure><p>ex:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-built_in">requires</span>(T t)<br>&#123;<br>    <span class="hljs-keyword">requires</span> std::is_same_v&lt;T, <span class="hljs-type">int</span>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种写法完全等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = std::is_same_v&lt;T, <span class="hljs-type">int</span>&gt;;<br></code></pre></td></tr></table></figure><p>意义在于允许我们在要求序列中加入编译期布尔表达式，并以此影响整个 requires 表达式的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = <span class="hljs-built_in">requires</span>(T t)<br>&#123;<br>    &#123; t + t &#125; -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;<br>    <span class="hljs-keyword">requires</span> std::is_same_v&lt;T, <span class="hljs-type">int</span>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其实这种写法也等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = std::is_same_v&lt;T, <span class="hljs-type">int</span>&gt; &amp;&amp; <span class="hljs-built_in">requires</span>(T t)<br>&#123;<br>    &#123; t + t &#125; -&gt; std::convertible_to&lt;<span class="hljs-type">bool</span>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="requires-子句"><a href="#requires-子句" class="headerlink" title="requires 子句"></a>requires 子句</h3><p>这是一个 requires 子句，可以在声明模板时直接写在 template&lt;模板形参列表&gt; 后面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">requires</span> 编译期布尔表达式<br></code></pre></td></tr></table></figure><p>这是一个被 requires 子句约束的函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">requires</span> std::is_same_v&lt;T, <span class="hljs-type">int</span>&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo0</span><span class="hljs-params">(T t)</span></span>&#123;&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> C = std::is_same_v&lt;T, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">requires</span> C&lt;T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo1</span><span class="hljs-params">(T t)</span></span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">requires</span> std::is_same_v&lt;T, <span class="hljs-type">int</span>&gt;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo2</span><span class="hljs-params">(T t)</span></span>&#123;&#125;<br><span class="hljs-comment">// 第一个 requires 代表“requires 子句”</span><br><span class="hljs-comment">// 第一个 requires 代表“requires 表达式”</span><br><span class="hljs-comment">// 第一个 requires 代表“嵌套要求”</span><br></code></pre></td></tr></table></figure><p>以上写法全部等价，你甚至可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">requires</span> <span class="hljs-keyword">requires</span>&#123; std::is_same_v&lt;T, <span class="hljs-type">int</span>&gt; &#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo2</span><span class="hljs-params">(T t)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="R”-”"><a href="#R”-”" class="headerlink" title="R”()”"></a>R”()”</h2><p>不使用转义字符打印特殊字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str =<br><span class="hljs-string">R&quot;(</span><br><span class="hljs-string">    &quot;test&quot;&#x27;test&#x27;</span><br><span class="hljs-string">    `~!@#$%^&amp;*()-_=+[&#123;]&#125;\|;:&#x27;&quot;,&lt;.&gt;/?</span><br><span class="hljs-string">)&quot;</span>;<br>std::cout &lt;&lt; str &lt;&lt; std::endl;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    output :</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &quot;test&quot;&#x27;test&#x27;</span><br><span class="hljs-comment">    `~!@#$%^&amp;*()-_=+[&#123;]&#125;\|;:&#x27;&quot;,&lt;.&gt;/?</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>R&quot;()&quot;</code> 会忠实的存储两个小括号之间的所有符号，包括每一个换行和缩进。</p><h2 id="offsetof"><a href="#offsetof" class="headerlink" title="offsetof"></a>offsetof</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertext</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Vertext vert;<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">char</span> *)(&amp;vert) + <span class="hljs-built_in">offsetof</span>(Vertext, c)) = <span class="hljs-number">42</span>;<br>    std::cout &lt;&lt; vert.c &lt;&lt; std::endl;<br>    <span class="hljs-comment">// output : 42</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pragma-warning"><a href="#pragma-warning" class="headerlink" title="pragma warning"></a>pragma warning</h2><ul><li>完全忽略指定警告<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(disable: XXXX)</span><br></code></pre></td></tr></table></figure></li><li>指定警告只显示一次<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(once: XXXX)</span><br></code></pre></td></tr></table></figure></li><li>指定警告为错误<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(<span class="hljs-keyword">error</span>: XXXX)</span><br></code></pre></td></tr></table></figure></li><li>重置警告，可能会影响更早的警告设置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(default: XXXX)</span><br></code></pre></td></tr></table></figure></li><li>push, pop 之间所有的更改都会在 pop 之后被放弃<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(push)</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(pop)</span><br></code></pre></td></tr></table></figure></li><li>suppress 仅忽略下一行的警告，然后恢复到 suppress 之前的状态，无法影响多行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span>(suppress: XXXX)</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="nodiscard"><a href="#nodiscard" class="headerlink" title="nodiscard"></a>nodiscard</h2><ul><li><p>若没有使用函数的返回值，编译器可以发出警告。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// nodiscard( 字符串字面量 ) (C++20 起):</span><br>[[<span class="hljs-built_in">nodiscard</span>(<span class="hljs-string">&quot;PURE FUN&quot;</span>)]] <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strategic_value</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x ^ y; &#125;<br></code></pre></td></tr></table></figure></li><li><p>若该类型作为返回值没有被使用，编译器可以发出警告。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> [[nodiscard]] error_info &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="VA-OPT"><a href="#VA-OPT" class="headerlink" title="VA_OPT"></a><strong>VA_OPT</strong></h2><p>当可变参数宏不为空时才展开 <code>__VA_OPT__</code> 内的内容，反之则忽略 <code>__VA_OPT__</code> 内的内容。<br>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASSERT(x, ...) &#123; <span class="hljs-keyword">if</span>(!(x)) &#123; __VA_OPT__(LOG_FATAL(__VA_ARGS__);) DEBUGBREAK(); &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>会将 <code>ASSERT(false, &quot;Hello&quot;)</code> 展开为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    <span class="hljs-keyword">if</span>(!(<span class="hljs-literal">false</span>))<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        <span class="hljs-built_in">DEBUGBREAK</span>();<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>而会将 <code>ASSERT(false)</code> 展开为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    <span class="hljs-keyword">if</span>(!(<span class="hljs-literal">false</span>))<br>    &#123;<br>        <span class="hljs-built_in">DEBUGBREAK</span>();<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="VS"><a href="#VS" class="headerlink" title="VS"></a>VS</h3><p>在 VS2022 中启用 <code>__VA_OPT__</code> 等较新的预处理器需要开启编译器开关 <code>/Zc:preprocessor</code><br><a href="https://learn.microsoft.com/en-us/cpp/preprocessor/preprocessor-experimental-overview?view=msvc-170">https://learn.microsoft.com/en-us/cpp/preprocessor/preprocessor-experimental-overview?view=msvc-170</a></p><h3 id="Premake"><a href="#Premake" class="headerlink" title="Premake"></a>Premake</h3><p>按理来说在 Premake 中启用该 VS 开关对应的是 <code>usestandardpreprocessor</code><br><a href="https://premake.github.io/docs/usestandardpreprocessor/">https://premake.github.io/docs/usestandardpreprocessor/</a><br>但是实测不生效，可能是一个 bug<br>现在而言的话可以写：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">filter</span> &#123; <span class="hljs-string">&quot;action:vs*&quot;</span> &#125;<br><span class="hljs-keyword">buildoptions</span> &#123; <span class="hljs-string">&quot;/Zc:preprocessor&quot;</span> &#125;<br><span class="hljs-keyword">filter</span> &#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GGX+Smith 微表面 PBR 漫反射光照</title>
    <link href="/2024/03/26/GDCGGXSmith/"/>
    <url>/2024/03/26/GDCGGXSmith/</url>
    
    <content type="html"><![CDATA[<h2 id="原标题"><a href="#原标题" class="headerlink" title="原标题"></a>原标题</h2><p><em>PBR Diffuse Lighting for GGX+Smith Microsurfaces</em></p><h2 id="通用的微表面-BRDF"><a href="#通用的微表面-BRDF" class="headerlink" title="通用的微表面 BRDF"></a>通用的微表面 BRDF</h2><h3 id="通用形式"><a href="#通用形式" class="headerlink" title="通用形式"></a>通用形式</h3><p>宏观表面的 BRDF 只是许多微表面的平均。</p><ul><li><p><strong>通用形式</strong><br>$\int_\Omega\rho_m(L,V,m)D(m)G_2(L,V,m)\frac{m\cdot L}{|N\cdot L|}\frac{m\cdot V}{|N\cdot V|}dm$</p></li><li><p>$\int_\Omega dm$<br>对半球面上所有微表面法线积分。</p></li><li><p>$\rho_m(L,V,m)$<br>单个微表面如何响应，即法线方向的 BRDF，通常为理想镜面或理想漫反射。</p></li><li><p>$D(m)$<br>法线分布概率密度函数。</p></li><li><p>$G_2(L,V,m)$<br>微表面 m 同时看到光源和观察者的概率。</p></li><li><p>$D(m)G_2(L,V,m)$<br>同时被光源和观察者可见的表面的概率密度函数。<br>$G_2$ 由两个方向（光源、观察者）的可视性 $G_1$ 推出。</p></li><li><p>$\frac{\lang m\cdot L\rang}{|N\cdot L|}\frac{\lang m\cdot V\rang}{|N\cdot V|}$<br>表面对光源来说有多大，表面对观察者来说有多大。</p></li><li><p>$D(m)G_2(L,V,m)\frac{\lang m\cdot L\rang}{|N\cdot L|}\frac{\lang m\cdot V\rang}{|N\cdot V|}$<br>从 L 出发，经过单次反射，到达 V 的概率密度函数。<br>$\int_\Omega D(m)G_2(L,V,m)\frac{\lang m\cdot L\rang}{|N\cdot L|}\frac{\lang m\cdot V\rang}{|N\cdot V|}dm\leq 1$</p></li></ul><h3 id="如何获得-specular"><a href="#如何获得-specular" class="headerlink" title="如何获得 specular"></a>如何获得 specular</h3><ul><li><p>微表面 BRDF 是完美镜面</p></li><li><p>光线只在 m &#x3D; H，的情况下反射</p></li><li><p>在数学上，BRDF 是经过缩放的狄拉克函数$\delta_m(H,m)$</p></li><li><p>一般情况：<br>$\int_\Omega\rho(L,V,N)cos\Theta_VdV&#x3D;1$</p></li><li><p><strong>更改积分域以计算 $\delta$：</strong><br>$\int_\Omega k\delta_m(H,m)cos\Theta_V\frac{dV}{dm}dm&#x3D;1$</p></li><li><p>$k\delta_m(H,m)$ 是纯镜面 BRDF</p></li><li><p>k 是缩放参数</p></li><li><p>$\frac{dV}{dm}$ 是 V 相对于 m 的变化速度</p></li></ul><p><strong>就结论而言，$\frac{dV}{dm}&#x3D;4H\cdot V$</strong><br>这是通过将 dv 从单位球投影至半径为 |L + V| 的球面上得到的。<br><img src="/img/GDCGGXSmith/dVdm.png" alt="dVdm"></p><p>由于 m &#x3D; H 以及 $H\cdot V&#x3D;H\cdot L$</p><ul><li>$\int_\Omega k\delta_m(H,m)cos\Theta_V\frac{dV}{dm}dm&#x3D;1$</li><li>$\int_\Omega k\delta_m(H,m)(m\cdot V)(4H\cdot V)dm&#x3D;1$</li><li>$k&#x3D;\frac{1}{4(H\cdot L)(H\cdot V)}$</li></ul><p><em>狄拉克函数在其定义域上的积分为 1</em><br><em>为什么 $(m\cdot V)(H\cdot V)$ 要以 $(H\cdot L)(H\cdot V)$ 的形式保留下来？</em></p><ul><li><p><strong>故，完美镜面 BRDF：</strong><br>$\frac{\delta_m(H,m)}{4(H\cdot L)(H\cdot V)}$</p></li><li><p>加上菲涅尔项<br>$\rho_m(L,Vm)&#x3D;F(L,m)\frac{\delta_H(m)}{4|H\cdot L||H\cdot V|}$</p></li><li><p>整合<br>$\int_\Omega\rho_m(L,V,m)D(m)G_2(L,V,m)\frac{\lang m\cdot L\rang}{|N\cdot L|}\frac{\lang m\cdot V\rang}{|N\cdot V|}dm$</p></li><li><p>代入得：<br>$\int_\Omega\frac{F(L,m)\delta_m(H,m)}{4|H\cdot L||H\cdot V|}D(m)G_2(L,V,m)\frac{\lang m\cdot L\rang}{|N\cdot L|}\frac{\lang m\cdot V\rang}{|N\cdot V|}dm$</p></li><li><p>由于狄拉克函数在积分中被消掉，以及 m &#x3D; H 得：<br>Specular BRDF &#x3D; $\frac{F(L,H)D(H)G_2(L,V,H)}{4|H\cdot L||H\cdot V|}$</p></li></ul><h3 id="扩展至-diffuse"><a href="#扩展至-diffuse" class="headerlink" title="扩展至 diffuse"></a>扩展至 diffuse</h3><ul><li>兰伯特漫反射：<br>$\rho_m(L,V,m)&#x3D;\frac{1}{\pi}$</li><li>无闭合解。<br><em>闭合指的是一个表达式包含有限个标准运算，极限、差分、积分都不算标准运算。</em></li></ul><h2 id="GGX-Smith-微表面模型的漫反射模拟"><a href="#GGX-Smith-微表面模型的漫反射模拟" class="headerlink" title="GGX+Smith 微表面模型的漫反射模拟"></a>GGX+Smith 微表面模型的漫反射模拟</h2><h3 id="Shadowing-masking-函数"><a href="#Shadowing-masking-函数" class="headerlink" title="Shadowing &#x2F; masking 函数"></a>Shadowing &#x2F; masking 函数</h3><h4 id="不相关-vs-高度相关的-G"><a href="#不相关-vs-高度相关的-G" class="headerlink" title="不相关 vs 高度相关的 G"></a>不相关 vs 高度相关的 G</h4><p>$G_2(L,V,m)&#x3D;G_1(L,m)G_1(V,m)$<br>不太现实，但是在实践中的效果很好。</p><blockquote><p> Higher points more likely visible to both 𝐿 and 𝑉 (and lower points less likely)</p></blockquote><ul><li><p>高度不相关的 G 会使镜面反射变暗</p><ul><li>越粗糙误差越大</li><li>越接近掠射角误差越大</li><li><img src="/img/GDCGGXSmith/vs.png"></li></ul></li><li><p>角度相关性</p><ul><li>当 L &#x3D; V，应有 $G_2(V,V,m)&#x3D;G_1(V,m)$</li><li>不相关：$G_2(V,V,m)&#x3D;G_1(V,m)^2$</li><li>相关：$G_2$ 介于两者之间</li></ul></li></ul><h4 id="Smith-shadowing-masking"><a href="#Smith-shadowing-masking" class="headerlink" title="Smith shadowing &#x2F; masking"></a>Smith shadowing &#x2F; masking</h4><ul><li><p>前面没看懂，中间没看懂，但是：</p></li><li><p>$\Lambda(V)&#x3D;\frac{1}{2}(\frac{\sqrt{\alpha^2+(1-\alpha^2)(N\cdot V)^2}}{N\cdot V}-1)$</p></li><li><p>$G_1(V)&#x3D;\frac{1}{1+\Lambda(V)}$</p></li><li><p>$G_2(L,V)&#x3D;\frac{1}{1+\Lambda(L)+\Lambda(V)}$</p></li><li><p>$G_1(L)G_1(V)&#x3D;\frac{1}{1+\Lambda(L)+\Lambda(V)+\Lambda(L)\Lambda(V)}$</p></li><li><p>$G_1(V)&#x3D;$<br>$\frac{2N\cdot V}{\sqrt{\alpha^2+(1-\alpha^2)(N\cdot V)^2}+N\cdot V}$</p></li><li><p>$G_2(L,V)&#x3D;$<br>$\frac{2(N\cdot L)(N\cdot V)}{N\cdot V\sqrt{\alpha^2+(1-\alpha^2)(N\cdot L)^2}+N\cdot L\sqrt{\alpha^2+(1-\alpha^2)(N\cdot V)^2}}$</p></li></ul><h4 id="新的-Smith-GGX-G-2-近似"><a href="#新的-Smith-GGX-G-2-近似" class="headerlink" title="新的 Smith + GGX $G_2$ 近似"></a>新的 Smith + GGX $G_2$ 近似</h4><ul><li>$G_1$ 的分母<ul><li>$\sqrt{\alpha^2+(1-\alpha^2)(N\cdot V)^2}+N\cdot V$</li><li>$\sqrt{lerp((N\cdot V)^2,1,\alpha^2)}+N\cdot V$</li><li><strong>近似：</strong></li><li>$\sqrt{lerp((N\cdot V)^2,1,\alpha^2)}\approx lerp(N\cdot V,1,\alpha)$</li></ul></li><li>故，$G_1(V)\approx\frac{2N\cdot V}{N\cdot V(2-\alpha)+\alpha}$<ul><li>和 Unreal 一致：</li><li>$G_1(V)\approx\frac{N\cdot V}{N\cdot V(1-k)+k}$, $k&#x3D;\frac{\alpha}{2}$</li></ul></li><li>通过近似的 $G_1$ 近似来求得 $G_2$<ul><li>$G_2(L,V)&#x3D;\frac{2|N\cdot L||N\cdot V|}{lerp(2|N\cdot L||N\cdot V|,|N\cdot L|+|N\cdot V|,\alpha)}$</li><li>代入 BRDF，约分：</li><li>$BRDF&#x3D;\frac{F(L,H)D(H)}{2lerp(2|N\cdot L||N\cdot V|,|N\cdot L|+|N\cdot V|,\alpha)}$</li></ul></li><li>开销：<ul><li>$G_1(L)G_1(V)$：$\frac{F(L,H)D(H)}{(|N\cdot L|(2-\alpha)+\alpha)(|N\cdot V|(2-\alpha)+\alpha)}$（**~4 cycles**）</li><li>$G_2(L,V)$：**~6 cycles**</li><li>高度相关产生的额外成本可以忽略不计。</li></ul></li><li>质量：<ul><li>在粗糙材质的掠射角上效果更好。</li><li><img src="/img/GDCGGXSmith/quality.png"></li><li><img src="/img/GDCGGXSmith/diff1.png" alt="高度相关近似 VS 不相关近似"></li><li><img src="/img/GDCGGXSmith/diff1.png" alt="高度相关准确 VS 高度相关近似"></li><li>感觉是否相关带来的差异比是否准确要大一些。</li></ul></li></ul><h3 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h3><p>讨论了一些光追中，BRDF 中菲涅尔项对漫反射以及高光部分的权重问题，先略过。</p>]]></content>
    
    
    <categories>
      
      <category>GDC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Rendering</tag>
      
      <tag>PBR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>守望先锋中的 ECS 系统</title>
    <link href="/2024/01/18/GDCOverwatchECS/"/>
    <url>/2024/01/18/GDCOverwatchECS/</url>
    
    <content type="html"><![CDATA[<h2 id="原标题"><a href="#原标题" class="headerlink" title="原标题"></a>原标题</h2><p><em>Overwatch Gameplay Architecture and Netcode</em></p><ul><li>Component：只保存状态，不含逻辑</li><li>System：只有逻辑，没有数据</li></ul><p>系统按顺序更新（Tick），每个系统访问多个不同的组件，称之为元组（Tuple）<br>元组之后被 Sibling 取代了。<br>系统不关心实体，只关心具体的组件。</p><h2 id="World"><a href="#World" class="headerlink" title="World"></a>World</h2><ul><li>array&lt;System *&gt;</li><li>hash_map&lt;EntityID, Entity *&gt;</li><li>object_pool&lt; Component &gt;*</li><li>array&lt;Component <em>&gt;</em></li></ul><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><ul><li>EntityID</li><li>array&lt;Component *&gt;</li><li>resourceHandle</li></ul><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul><li>void Create(resource *)</li><li>~Component()</li></ul><p>基类，其子类可以重载构造 &#x2F; 析构函数用于管理资源。<br>有一些工具函数，主要为数据的访问接口。</p><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><ul><li>void Update(float)</li><li>void NotifyComponent…(Component *)</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>一个检测玩家挂机行为的 System，这个 System 必须同时取得 ConnectionComponent，InputStreamComponent 和 StatsComponent。<br>而对于没有 ConnectionComponent 和 InputStreamComponent 的 AI 玩家则不受这个系统的约束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PlayerConnectionSystem::Update</span><span class="hljs-params">(<span class="hljs-type">float</span> timeStep)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(ConnectionComponent *c : <span class="hljs-built_in">ComponentItr</span>&lt;ConnectionComponent&gt;(m_admin))<br>    &#123;<br>        <span class="hljs-comment">// 从一个具体的 Component 所在的 Entity 上获得指定类型的 Component。</span><br>        InputStreamComponent *is = c-&gt;<span class="hljs-built_in">Sibling</span>&lt;InputStreamComponent&gt;();<br>        StatsComponent *stats = c-&gt;<span class="hljs-built_in">Sibling</span>&lt;StatsComponent&gt;();<br>        <span class="hljs-keyword">if</span> (is-&gt;m_inputThisFrame || stats-&gt;m_didSomethingCoolLately)<br>        &#123;<br>            c-&gt;m_afkTimer = <span class="hljs-number">0.0f</span>;<br>            C-&gt;m_sentAFKMessage = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            C-&gt;m_afkTimer += timeStep;<br>            <span class="hljs-keyword">if</span> (!c-&gt;m_sentAFKMessage &amp;&amp; c-&gt;m_afkTimer &gt; AFK_MESSAGE_SECONDS)<br>            &#123;<br>                c-&gt;m_sentAFKMessage = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 辅助函数，之后会讲到</span><br>                ConnectionUtil::<span class="hljs-built_in">SendMessage</span>(c-&gt;m_connectionHandle, <span class="hljs-string">&quot;Move scrub!&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WHY-NOT-OOP-IT"><a href="#WHY-NOT-OOP-IT" class="headerlink" title="WHY NOT OOP IT"></a>WHY NOT OOP IT</h2><p>观点：同一份数据在不同视角下的意义是不同的。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>为了避免奇怪的访问方式（比如一个系统通过全局变量拿到另一个系统的指针，而死亡回放时存在两个 World，便存在了两个“全局变量”）<br>可以定义一些仅存在一个实例的 Component，称之为单例组件。存在于一匿名 Entity 上，通常直接通过 World 访问。<br>单例组件极少只被单个 System 访问，并且事实上 OW 有百分之四十的 Component 都是单例组件。</p><h2 id="全局行为（Share-behavior）"><a href="#全局行为（Share-behavior）" class="headerlink" title="全局行为（Share behavior）"></a>全局行为（Share behavior）</h2><p>为了避免系统之间的耦合（比如在一个系统内调用另一系统的函数）<br>有一些逻辑是许多系统都关心的，比如判断两个实体是否敌对，可以将其抽象为辅助函数。<br>这里有一些设计规则：</p><ol><li>尽量少读取 Component，尽量少产生副作用。</li><li>如果做不到，就尽量少调用它。</li></ol><h3 id="减小副作用的方法"><a href="#减小副作用的方法" class="headerlink" title="减小副作用的方法"></a>减小副作用的方法</h3><p>假设有一个会影响很多 Component 的函数，并且允许其在多个地方调用。首先对其本身的任何修改就需要进行大量的测试，其次调用者容易对其真正的复杂度产生误解进而无限制的进行调用。两者放在一起更是让代码很难理解。<br><img src="/img/GDCOverwatchECS/Nightmare.png" alt="Nightmare"><br>解决方案：延迟调用<br>在原本的调用位置只添加一个包含足够多信息的用于稍后进行真正的调用的记录到 array，最后统一进行处理，这样一来每一帧就只有一处调用会产生明显的副作用了。<br>我的理解是：复杂度是无法减小的，但是是可以被错误的设计放大的，而我们的设计应当尽量逼近最小的复杂度。<br>更多好处：</p><ol><li>数据与指令内存布局连续，访存友好。</li><li>你甚至可以将真正的调用延迟到之后几帧来分摊性能。</li></ol><p>PS：实体的创建是立即的，具体情况具体分析。</p>]]></content>
    
    
    <categories>
      
      <category>GDC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Engineering</tag>
      
      <tag>ECS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低复杂，高保真：INSIDE 中的渲染</title>
    <link href="/2023/12/23/GDCTheRenderingofInside/"/>
    <url>/2023/12/23/GDCTheRenderingofInside/</url>
    
    <content type="html"><![CDATA[<h2 id="原标题"><a href="#原标题" class="headerlink" title="原标题"></a>原标题</h2><p><em>Low Complexity, High Fidelity: The Rendering of INSIDE</em><br>项目中的各种 Trick 与性能优化，其中颜色抖动在渲染中的应用比较有意思。</p><h2 id="Dithering"><a href="#Dithering" class="headerlink" title="Dithering"></a>Dithering</h2><p><img src="/img/GDCTheRenderingofInside/ColorBanding.png" alt="Color Banding"><br>这个问题源于：8 bit 的颜色无法完美还原高精度的渲染结果。</p><ul><li>橙线：理想中的原始信号</li><li>蓝线：默认的采样方式（floor），可以看到丢失了精度</li><li>噪点：人为在原始信号上叠加的 [0, 1] 随机值</li></ul><p>加上噪声之后，信号从原本的“不得不被 floor 至蓝线丢失精度”变成“有 a 概率被 clamp 至蓝线，有 b 概率被 clamp 至红线，a + b &#x3D;&#x3D; 1”，这样在人眼的感知上也更贴合原始信号。</p><h2 id="Noise-Modulation"><a href="#Noise-Modulation" class="headerlink" title="Noise Modulation"></a>Noise Modulation</h2><p>噪声的选择也值得关注，这里提到了一个 Noise Modulation 的概念，大致意思好像是噪声不应当与原始信号无关，详细可以看 _Optimal Dither and Noise Shaping in lmage Processing, 2008, Cameron Nicklaus Christou_。<br>他们最终选择了预计算 blue noise，并且 remap 至三角概率密度函数（右下角），在实际的应用中只进行一个简单的采样。<br><img src="/img/GDCTheRenderingofInside/FinalNoiseTypeforDithering.png" alt="Final Noise Type for Dithering"></p>]]></content>
    
    
    <categories>
      
      <category>GDC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rendering</tag>
      
      <tag>Dithering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>荒野大镖客 2 中的天气系统</title>
    <link href="/2023/12/19/SigRedDeadRedemption2Atmospheric/"/>
    <url>/2023/12/19/SigRedDeadRedemption2Atmospheric/</url>
    
    <content type="html"><![CDATA[<h2 id="原标题"><a href="#原标题" class="headerlink" title="原标题"></a>原标题</h2><p><em>Creating the Atmospheric World of Red Dead Redemption 2: A Complete and Integrated Solution</em><br>整套天气系统渲染的实现，包括大气、云雾、二十四小时、不同天气。</p><h2 id="物理基础"><a href="#物理基础" class="headerlink" title="物理基础"></a>物理基础</h2><p><img src="/img/SigRedDeadRedemption2Atmospheric/Scattering1.png" alt="Scattering"></p><ul><li>这里只考虑单条光路上的单次散射。</li><li>以单个粒子为视角，当光线与其交互时，大致会发生吸收（转化为热能）、散射和反弹。</li><li>散射向相机的部分被称作 in-scattering，剩余的部分被称作 out-scattering。<ul><li>out-scattering 会继续作用于其他粒子并造成多重散射，多重散射较为复杂，此处不做考虑。</li><li>以一条光路为视角，远处的粒子发生的 in-scattering 会继续在近处的粒子上发生 out-scattering。</li></ul></li><li><strong>Scattered Light</strong>：单个粒子上发生的散射，P 为相函数，V 为可见性，L 为入射 Radiance。</li><li><strong>Extinction</strong>：消光系数，由吸收系数与散射系数定义，意为一束光经过单个粒子之后沿着原光路继续传播的占比。</li><li><strong>Transmittance</strong>：透射率 &#x2F; 透光率，意为一束光经过给定距离之间所有粒子之后沿着原光路继续传播的占比。</li><li>总结：单光路上单次散射便可表示为，“着色点到达相机剩余的光”与“光路上所有粒子提供给相机的散射”之和。</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="云"><a href="#云" class="headerlink" title="云"></a>云</h3><p>贴图 + 参数生成两个通道用于表示两层云在平面上该如何放置，覆盖整张地图。<br><img src="/img/SigRedDeadRedemption2Atmospheric/CloudMap.png" alt="Cloud Map"></p><p>高度上的定义。<br><img src="/img/SigRedDeadRedemption2Atmospheric/CloudHeightLUT.png" alt="Cloud Height LUT"></p><p>细节，两张 2D 的位移贴图 + 一张 3D 的噪声贴图结合风速参数。<br><img src="/img/SigRedDeadRedemption2Atmospheric/CloudDetail.png" alt="Cloud Detail"></p><p>在高空还有一层简化过的卷云，不过光照模型是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">float2 c = SampleCloudMap(ray.p);<br>float3 cloudLut = SampleCloudLUT(altitude);<br><span class="hljs-type">float</span> density = smoothstep(g_CloudShape.xz + cloudLut.xy, g_CloudShape.yw + cloudLut.xy, c.xy);<br><span class="hljs-type">float</span> <span class="hljs-title function_">rescale</span><span class="hljs-params">(vMin, vMax, v)</span><br>&#123;<br>  <span class="hljs-keyword">return</span> saturate((v – vMin) / (vMax - vMin));<br>&#125;<br>density = rescale(noise, CloudLut.z, density);<br></code></pre></td></tr></table></figure><h3 id="雾"><a href="#雾" class="headerlink" title="雾"></a>雾</h3><p>全局雾 + 局部雾。一张图覆盖所有可玩区域，存储起始高度，衰减距离和密度。<br><img src="/img/SigRedDeadRedemption2Atmospheric/FogMap.png" alt="Fog Map"><br>同时也支持可以自由摆放的 Fog Volumes，球型或盒型，自定义颜色，alpha blending 或者 additive。</p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>近处 frustum aligned volume，远处 raymarching。</p><h3 id="相函数"><a href="#相函数" class="headerlink" title="相函数"></a>相函数</h3><p>单次散射，波长无关，trick 近似多重散射。<br><img src="/img/SigRedDeadRedemption2Atmospheric/PhaseFunction.png" alt="Phase Function"></p><ul><li>叠加多级的 Henyey-Greenstein 函数，每次迭代 各向异性 g 减小。</li><li>使用艺术导向的权重 $\omega_0$ 和 $\omega_1$ 以及 消光系数 $\sigma_{ext}$ 来混合。</li><li>两次迭代。</li></ul><p>依旧缺乏向后的散射，clamp 至由消光系数和感知调整参数影响的 Lambertian BRDF 1&#x2F;PI。<br><em>不知道这个感知调整参数具体是什么玩意儿</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">ApplyBackScattering</span><span class="hljs-params">(<span class="hljs-type">float</span> phase, <span class="hljs-type">float</span> extinction)</span><br>&#123;<br>  <span class="hljs-type">float</span> v = <span class="hljs-number">1</span>/PI * rescale(BACK_SCATTER_MIN, BACK_SCATTER_MAX, extinction);<br>  <span class="hljs-keyword">return</span> max(phase, v);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>主要是 Shadow Map。<br>对于云，则进行对太阳&#x2F;月亮的消光采样，通过天气参数控制采样长度。</p><p>对地形的 Height Map 做 Raymarch，记录相交的高度，Ray length 用于调整 threshold。<br><img src="/img/SigRedDeadRedemption2Atmospheric/TerrainShadowMap.png" alt="Terrain Shadow Map"></p><p>云的 Shadw Map 存储为 ESM（Exponential Shadow Map），透射率加权射线长度，滤波存为 Mip Map。<br><img src="/img/SigRedDeadRedemption2Atmospheric/CloudShadowMap.png" alt="Cloud Shadow Map"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> transmittance = <span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> depth = maxDepth;<br><span class="hljs-keyword">while</span> (ray.t &lt; maxDepth &amp;&amp; transmittance &gt; <span class="hljs-number">0.001</span>)<br>&#123;<br>  <span class="hljs-type">float</span> density = SampleCloudDensity(ray.p + ray.d * ray.t);<br>  transmittance *= <span class="hljs-built_in">exp</span>(-density * stepLength);<br>  depth = lerp(depth, ray.t, <span class="hljs-built_in">pow</span>(transmittance, <span class="hljs-number">4</span>));<br>  ray.t += stepLength;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p>复用上面 Cloud Shadow Map 的可见性。</p><p>对于 Raymarching：</p><ul><li>将无云的 Rayleigh 和 Mie 散射加权平均</li><li>渲染至低分辨率的抛物面贴图上</li><li>Parallel Reduction</li><li>太阳&#x2F;月亮方向加权</li></ul><p>对于 Frustum Volume：</p><ul><li>采样 Irradiance Probe，存储了 sky light + indirect bounce light * AO</li></ul><h3 id="Local-Lights"><a href="#Local-Lights" class="headerlink" title="Local Lights"></a>Local Lights</h3><ul><li>采样 light cluster volume</li><li>Shadow Map 做可见性</li><li>单级 HG 相函数</li></ul><h3 id="闪电"><a href="#闪电" class="headerlink" title="闪电"></a>闪电</h3><p>没有细讲，比较暴力的实现。</p><ul><li>每一击闪电添加一个点光源</li><li>指数衰减 + 相函数</li><li>简化的局部消光（用于近似阴影）</li></ul><h3 id="散射波瓣可视化"><a href="#散射波瓣可视化" class="headerlink" title="散射波瓣可视化"></a>散射波瓣可视化</h3><p><img src="/img/SigRedDeadRedemption2Atmospheric/ScatteredLightOverview.png" alt="Scattered Light Overview"></p><h3 id="Frustum-Voxel-Grid"><a href="#Frustum-Voxel-Grid" class="headerlink" title="Frustum Voxel Grid"></a>Frustum Voxel Grid</h3><p><img src="/img/SigRedDeadRedemption2Atmospheric/FrustumVoxelGrid.png" alt="Frustum Voxel Grid"></p><ul><li>动态可调深度（&lt;160m）</li></ul><p>三个 volume</p><ul><li>Shadow Volume</li><li>Material Volume</li><li>Scattered Light and Extinction Volume</li><li>分辨率 160 x 88 x 64</li></ul><h4 id="Shadow-Volume"><a href="#Shadow-Volume" class="headerlink" title="Shadow Volume"></a>Shadow Volume</h4><ul><li>格式：R16F</li><li>存储从 Shadow Map，Cloud Shadow Map 和 Terrain Shadow Map 采样到的直接光阴影项</li><li>Temporal Filtering</li></ul><h4 id="Material-Volume"><a href="#Material-Volume" class="headerlink" title="Material Volume"></a>Material Volume</h4><p>分为两个子 Volume 存储不同参数。<br><img src="/img/SigRedDeadRedemption2Atmospheric/MaterialVolume.png" alt="Material Volume"></p><ul><li>混合顺序：Additive -&gt; Alpha -&gt; Particles<br>这样可以用一个大号的 Additive 包围整个建筑，然后用 Alpha 镂空室内，然后还支持用 Particles 表示的爆炸&#x2F;火灾。</li><li>对散射和吸收系数做 Temporal Filtering</li><li>与风速交互</li></ul><h4 id="Scattered-Light-Volume"><a href="#Scattered-Light-Volume" class="headerlink" title="Scattered Light Volume"></a>Scattered Light Volume</h4><ul><li><p>采样 Material 和 Shadow Volume</p></li><li><p>累计直接光（太阳&#x2F;月亮&#x2F;局部光）和环境光（来自 irradiance probe）的 Radiance</p></li><li><p>格式：RGBA16F，RGB: Scattered light，A: Extinction</p></li><li><p>一个 slice marching pass 计算每个 slice 的 in-scattering 和 transmittance </p></li><li><p>无时间性的混合，动态光源拖影明显</p></li><li><p>使用抖动查找和 TAA</p></li></ul><h3 id="Raymarch"><a href="#Raymarch" class="headerlink" title="Raymarch"></a>Raymarch</h3><p>Frustum Volumes 分辨率有限，无高频信息，使用时间性的混合依旧不稳定。<br>Raymarch 内存更小但是运行开销更大，剔除了雾, irradiance probe 和局部光。</p><ul><li><p>射线长度由屏幕深度，与地平面&#x2F;穹顶的解析解决定</p></li><li><p>击中云的基本形状之后步长减半并回退一步，直到达到迭代最大次数</p></li><li><p>以此做为积分的开始位置</p></li><li><p>离开云之后恢复初始步长</p></li><li><p>射线起始位置 &#x3D; frustum volume 的最后一个 slice 之后 + offset(blue noise)</p></li><li><p>目标是半屏幕分辨率</p></li><li><p>还是太慢了，故不对所有像素投射光线，吧计算分布到 4 帧</p></li></ul><h4 id="Reconstruction"><a href="#Reconstruction" class="headerlink" title="Reconstruction"></a>Reconstruction</h4><ul><li>每次只投射 2 x 2 tile 中的一条光线，并重投影上一帧中跳过的像素</li><li>采样之前的 buffer 时将结果 clamp 至 3 x 3 的临近像素内</li><li>放弃与当前像素深度差异过大的样本</li><li>无历史信息时使用最近的 Raymarch 结果</li></ul><p><img src="/img/SigRedDeadRedemption2Atmospheric/RaymarchReconstruction.png" alt="Raymarch Reconstruction"></p><h4 id="Ray-Placement"><a href="#Ray-Placement" class="headerlink" title="Ray Placement"></a>Ray Placement</h4><p>先对深度进行棋盘下采样，这是一种交替存储 tile 内最大值与最小值的下采样方法，有助于保存细节。</p><ol><li><p>假设以：“左上、右上、右下、左下”的顺序投射光线，在特定的情况下会遇到问题。例如在 Frame 2 我们试图重建左下的像素，会发现九个可信的 Raymarch 结果全部与其深度相差过大，即都应当被丢弃。这时这个像素便会失去在时间上的可信度。在这里其实可以反推出一个理想中光线分布方式应当是覆盖了尽可能大的深度范围的。<br><img src="/img/SigRedDeadRedemption2Atmospheric/RayPlacement.png" alt="Ray Placement"></p></li><li><p>又提出了一种不统一从左上角开始的分布方式，依旧不能适配所有情况。<br><img src="/img/SigRedDeadRedemption2Atmospheric/RayPlacement2.png" alt="Ray Placement 2"></p></li><li><p>在 2 的基础上微调。比较中心 Ray 和周围八个 Ray 的深度，如果相差无几，就将 min 上的 Ray 移到 max 上去，反之亦然。<br><em>移动时每个 tile 内应该都有两个选项，具体怎么移动好像没有细说</em></p></li></ol><h4 id="Full-Resolution-Upscale"><a href="#Full-Resolution-Upscale" class="headerlink" title="Full Resolution Upscale"></a>Full Resolution Upscale</h4><h5 id="Dithered-Upscale"><a href="#Dithered-Upscale" class="headerlink" title="Dithered Upscale"></a>Dithered Upscale</h5><ul><li>4 个采样点 + blue noise</li><li>深度加权</li></ul><h5 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h5><ul><li>卷积核宽度由透射率和深度决定，让远处云不会被处理的太糊。<br><em>原文是：… width … is chosen by the transmittance weighted depth of the ray of this pixel.</em></li><li>查找 in-scattering &#x2F; transmittance accumulation volume 应用同样的原则。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>有一篇结合了逆向的文章，还在 UE 里复现了一遍：<br><a href="https://zhuanlan.zhihu.com/p/127435500">荒野大镖客2天气系统云雾分帧处理细节</a></p><h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><h3 id="Sky-Scattering"><a href="#Sky-Scattering" class="headerlink" title="Sky Scattering"></a>Sky Scattering</h3><ul><li>基于 Precomputed Atmospheric Scattering [Bruneton07]</li><li>改进自 Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite [Hillaire16]</li><li>支持 earth shadow <em>这啥？</em></li><li>随时间段更新</li><li>Raymarch 之后采样一次，而非每个采样点都采样 Sky Scattering</li></ul><h4 id="Light-Shaft-God-Ray"><a href="#Light-Shaft-God-Ray" class="headerlink" title="Light Shaft &#x2F; God Ray"></a>Light Shaft &#x2F; God Ray</h4><ul><li>分离 Sky Scattering 的可见性项</li><li>每次 Raymarch 累计可见性，通过样本覆盖面积和透射率加权</li><li>Raymarch 之后通过 光线长度进行归一化。</li><li>物理不正确，但是开销小效果好</li></ul><h3 id="Sky-Irradiance-Probes"><a href="#Sky-Irradiance-Probes" class="headerlink" title="Sky Irradiance Probes"></a>Sky Irradiance Probes</h3><p><img src="/img/SigRedDeadRedemption2Atmospheric/SkyIrradianceProbes.png" alt="Sky Irradiance Probes"></p><ul><li>云雾对大气提供的环境光的遮挡</li><li>维护 32 x 32 个 probe，每 256 x 256 平方米一个</li><li>高度和方向由 height map 和 bent normal map 决定</li><li>编码为三阶球谐函数</li></ul><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/SigRedDeadRedemption2Atmospheric/SkyIrradianceProbes1.png" alt="Sky Irradiance"></div><div class="group-image-wrap"><img src="/img/SigRedDeadRedemption2Atmospheric/SkyIrradianceProbes2.png" alt="With Scattering / Transmittance"></div><div class="group-image-wrap"><img src="/img/SigRedDeadRedemption2Atmospheric/SkyIrradianceProbes3.png" alt="With Direct Light"></div></div></div><p>优化：</p><ul><li>可视的 Probe 投射 32 条光线，不可见投射 16 条</li><li>每个线程一条射线</li><li>不考虑云的高频噪声侵蚀</li><li>不考虑彩虹 &#x2F; 闪电</li><li>长步长，无需细化</li><li>Shared memory parallel reduction</li></ul><h3 id="Reflection-Probes"><a href="#Reflection-Probes" class="headerlink" title="Reflection Probes"></a>Reflection Probes</h3><ul><li>在相机位置生成低分辨率的 Cube Map</li><li>存储 scattering 和 transmittance</li><li>和 Sky Irradiance Probe 一样简化的 Raymarch</li></ul><h3 id="Water-Reflections"><a href="#Water-Reflections" class="headerlink" title="Water Reflections"></a>Water Reflections</h3><ul><li>SSR 不包含半透明 &#x2F; 体积效果</li><li>取而代之使用简化的 Raymarch + temporal blend</li></ul>]]></content>
    
    
    <categories>
      
      <category>Siggraph</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AtmosphericScattering</tag>
      
      <tag>Rendering</tag>
      
      <tag>VolumeRendering</tag>
      
      <tag>Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫威蜘蛛侠中的程序化光照</title>
    <link href="/2023/11/21/GDCSpiderManLighting/"/>
    <url>/2023/11/21/GDCSpiderManLighting/</url>
    
    <content type="html"><![CDATA[<h2 id="原标题"><a href="#原标题" class="headerlink" title="原标题"></a>原标题</h2><p><em>Marvel’s Spider-Man: Procedural Lighting Tools</em><br>程序化布光以及 Probe &#x2F; Light Grid 分布。</p><h2 id="Open-World-Tiles"><a href="#Open-World-Tiles" class="headerlink" title="Open World Tiles"></a>Open World Tiles</h2><p><img src="/img/GDCSpiderManLighting/Tile.png" alt="Tile"></p><ul><li>将整个世界分成数个 128 x 128 米的 Tile，对于每个 Tile，由数个 JSON 文件描述该 Tile 所引用的资源。</li><li>只有玩家当前所在的和周围的 Tile 会流入内存，其余的 Tile 卸载。</li><li>极远处的渲染由下文会讲到的 Impostor 系统负责。</li></ul><h2 id="Procedural-Placement"><a href="#Procedural-Placement" class="headerlink" title="Procedural Placement"></a>Procedural Placement</h2><p><img src="/img/GDCSpiderManLighting/ProceduralPlacement.png" alt="ProceduralPlacement"></p><ul><li>程序化沿着街道放置路灯。</li><li>可视化所有光源的位置及其光照范围（RayCast），以找到打光不足的区域。</li></ul><h2 id="Light-Probes（Specular）"><a href="#Light-Probes（Specular）" class="headerlink" title="Light Probes（Specular）"></a>Light Probes（Specular）</h2><ul><li>在每个 Tile 中均匀划分四个区域，在每个区域中心生成一个 Probe。</li><li>将 Probe 移动到距离最近的街道上，优先主干道，然后次干道。</li><li>如果 Probe 位于建筑物内，用 SDF 将其移出。</li><li>Probes 所捕获的信息来自 Impostor 系统。</li></ul><p><img src="/img/GDCSpiderManLighting/LightProbes.png" alt="LightProbes"></p><ul><li>在磁盘上存储 Light Probe 信息数据量过大，故使用实时的 Light Probe 生成。</li><li>每个 Probe 的每个面分辨率为 512 x 512，然后向下进行 5 层卷积存储为 MipMap。</li></ul><h2 id="IG-Impostors"><a href="#IG-Impostors" class="headerlink" title="IG-Impostors"></a>IG-Impostors</h2><p><img src="/img/GDCSpiderManLighting/IG.png" alt="IG"></p><ul><li>相关的 Mesh 和 Texture 常驻于全局内存中，代表最低级别的 LOD。</li><li>所有 Mesh 共占 100 MB，Texture 共占 90 MB，还有一些高质量的用于自发光以及反射的 Mesh 共占 30 MB。</li><li>一共 220 MB 的数据来表示整个城市的最低级别 LOD，可以被任何系统访问。<br><img src="/img/GDCSpiderManLighting/Texture.png" alt="Texture"></li><li>一张贴图存储 albedo，一张一半分辨率的贴图存储 specular，gloss，emission。</li></ul><h2 id="Light-Grids"><a href="#Light-Grids" class="headerlink" title="Light Grids"></a>Light Grids</h2><p><img src="/img/GDCSpiderManLighting/Grid.png" alt="Grid"></p><ul><li>每个 128 x 128 米的 Tile 被划分为数个 16 x 16 x 16 的 capture volume。</li><li>由建筑物高度决定立方体的分布。</li><li>移除建筑物内部的立方体。</li><li>Light Grids 信息生成为 JSON，引擎读取后进行采样并存储为 Cache File。</li></ul><p><img src="/img/GDCSpiderManLighting/LightGrids.png" alt="LightGrids"></p><ul><li>每个 capture volume 内 4096 个样本，一立方米一个。</li><li>每个样本生成每个面 256 x 256 像素的立方体贴图。</li><li>然后每个面被卷积至单个 HDR 像素，用以表示 diffuse 和方向（高度可压缩的）。</li></ul><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ul><li>还存在一个 Hibernation 系统，简单来说只是拥有一个更远的剔除平面，用于处理一些被 Impostors 系统认为过于复杂而被剔除的物体，比如公园里的长椅，楼顶的空调外机等。</li><li>Light Probe 的更新大约为每秒两次，具体则由引擎的任务系统调度。</li><li>一共有 4 份 Light Grid 数据来描述一整天中的漫反射信息，分别为正午，阴天，黎明&#x2F;黄昏，夜晚，</li><li>每个 Probe 存储一份可见的建筑列表。</li><li>通过视锥体，移动方向，移动速度来决定如何优化加载哪些 Tile。</li></ul>]]></content>
    
    
    <categories>
      
      <category>GDC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GlobalIllumination</tag>
      
      <tag>Rendering</tag>
      
      <tag>Procedural</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>何为一个 C++ 项目</title>
    <link href="/2023/11/09/CppProject/"/>
    <url>/2023/11/09/CppProject/</url>
    
    <content type="html"><![CDATA[<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>待整理，但是最近发现了一些有趣的东西，先记一下</p><h2 id="CMAKE-MSVC-RUNTIME-LIBRARY"><a href="#CMAKE-MSVC-RUNTIME-LIBRARY" class="headerlink" title="CMAKE_MSVC_RUNTIME_LIBRARY"></a>CMAKE_MSVC_RUNTIME_LIBRARY</h2><p>用于在 CMakeLists 里指定 MSVC 使用的运行时库。</p><ul><li><code>MultiThreaded</code> 对应 <code>MT</code></li><li><code>MultiThreadedDebug</code> 对应 <code>MTd</code></li><li><code>MultiThreadedDLL</code> 对应 <code>MD</code></li><li><code>MultiThreadedDebugDLL</code> 对应 <code>MDd</code></li></ul><p>注意这项功能仅在 CMake 3.15 之后被支持，至少需要 <code>cmake_minimum_required(VERSION 3.15)</code>。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span>(CMAKE_MSVC_RUNTIME_LIBRARY <span class="hljs-string">&quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;</code> 为生成器表达式，意为“如果当前为 Debug，返回 Debug，否则返回空字符串”。<br>要放在 <code>project</code> 之前才会生效。</p><p>在 3.15 以下的版本中要实现相同的功能需要类似于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span>(CompilerFlags<br>        CMAKE_CXX_FLAGS<br>        CMAKE_CXX_FLAGS_DEBUG<br>        CMAKE_CXX_FLAGS_RELEASE<br>        CMAKE_C_FLAGS<br>        CMAKE_C_FLAGS_DEBUG<br>        CMAKE_C_FLAGS_RELEASE<br>        )<br>foreach(CompilerFlag $&#123;CompilerFlags&#125;)<br>  <span class="hljs-built_in">string</span>(REPLACE <span class="hljs-string">&quot;/MD&quot;</span> <span class="hljs-string">&quot;/MT&quot;</span> $&#123;CompilerFlag&#125; <span class="hljs-string">&quot;$&#123;$&#123;CompilerFlag&#125;&#125;&quot;</span>)<br>endforeach()<br></code></pre></td></tr></table></figure><p>详见：<br><a href="https://stackoverflow.com/questions/14172856/compile-with-mt-instead-of-md-using-cmake">Compile with &#x2F;MT instead of &#x2F;MD using CMake</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://cmake.org/cmake/help/latest/variable/CMAKE_MSVC_RUNTIME_LIBRARY.html">CMAKE_MSVC_RUNTIME_LIBRARY</a><br><a href="https://zhuanlan.zhihu.com/p/429849408">在 CMake 中设置 MSVC 运行库</a></p><h2 id="使用-dumpbin-查看静态库的依赖"><a href="#使用-dumpbin-查看静态库的依赖" class="headerlink" title="使用 dumpbin 查看静态库的依赖"></a>使用 dumpbin 查看静态库的依赖</h2><p>在安装 VS2017 或以上的版本时会自动安装 dumpbin.exe，我的路径在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-string">&quot;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\bin\Hostx64\x64\dumpbin.exe&quot;</span><br></code></pre></td></tr></table></figure><p>将其加入环境变量即可在任意位置调用 <code>dumpbin</code>。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat">dumpbin /directives &lt;<span class="hljs-built_in">path</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="/img/CppProject/directives.png" alt="directives"><br>其中 <code>MT_StaticReleasd</code> 和 <code>LIBCMT</code> 都代表该文件使用的运行时库为 <code>MT</code>。<br>剩余对应详见 <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features?view=msvc-170#c-runtime-lib-files">C 运行时 .lib 文件</a><br><img src="/img/CppProject/CRT.png" alt="directives"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>dumpbin 看起来还有很多功能，可惜官方文档写的也不是很清楚：<br><a href="https://learn.microsoft.com/en-us/cpp/build/reference/dumpbin-options?view=msvc-170">DUMPBIN 选项</a></p><h2 id="使用-depends-查看动态库的依赖"><a href="#使用-depends-查看动态库的依赖" class="headerlink" title="使用 depends 查看动态库的依赖"></a>使用 depends 查看动态库的依赖</h2><p>一个开源的 dll 依赖分析软件：<br><a href="https://github.com/lucasg/Dependencies">https://github.com/lucasg/Dependencies</a><br>打开 GUI 将对应 dll 拖入：</p><ul><li><code>msvcp&lt;version&gt;.dll</code> 对应 <code>/MD</code></li><li><code>msvcp&lt;version&gt;d.dll</code> 对应 <code>/MDd</code><br>自 VS2017 以后这个 version 应该是 140。</li></ul><p>MD：<br><img src="/img/CppProject/MD.png" alt="MD"><br>MT：<br><img src="/img/CppProject/MT.png" alt="MT"></p><h2 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h2><p><a href="https://zhuanlan.zhihu.com/p/577996608">C++ ABI总结</a></p><ul><li>体现在跨编译器的 link 大概率是失败的，因为 C++ 编译器会对符号进行一个“名称重整”的行为以满足 C++ 中的多态，而不同编译器名称重整的逻辑完全不同。不过好像 clang 之类的是能够提供对其他编译器的兼容的。</li><li>另一个方面是混合了同一个编译器不同版本的编译流程，比如 MSVC 自 VS2015 之后说，新的连接器可以混合链接旧版 MSVC 编译出来的库文件。<a href="https://learn.microsoft.com/en-us/cpp/porting/binary-compat-2015-2017?view=msvc-170">C++ binary compatibility between Visual Studio versions</a></li><li>还有就是第三方库只要能保持 ABI 兼容，即可只更新 dll 文件而不用重新编译最终的运行文件。</li><li>对虚函数表的重排序，添加删除成员变量等都会使 ABI 兼容失效，因为内存排布不一样了，然后有个保持 ABI 兼容的技巧叫做 Pointer to implementation。<a href="https://en.cppreference.com/w/cpp/language/pimpl">PImpl</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行调用 CMake 与 MSBuild</title>
    <link href="/2023/10/30/CMakeAndMSBuild/"/>
    <url>/2023/10/30/CMakeAndMSBuild/</url>
    
    <content type="html"><![CDATA[<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>一个 OpenCV 的例子</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br><br><span class="hljs-built_in">set</span> &quot;ROOT_PATH=%~dp0&quot;<br><span class="hljs-built_in">set</span> &quot;OPENCV_PATH=<span class="hljs-variable">%ROOT_PATH%</span>\Frame\Source\ThirdParty\opencv&quot;<br><span class="hljs-built_in">echo</span> [ opencv ] <span class="hljs-built_in">path</span>: <span class="hljs-variable">%OPENCV_PATH%</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">%OPENCV_PATH%</span><br><br>cmake -B build -D CMAKE_CONFIGURATION_TYPES=&quot;Release;Debug&quot; -D OPENCV_DOWNLOAD_MIRROR_ID=gitcode -D BUILD_TESTS=OFF -D BUILD_PERF_TESTS=OFF -D BUILD_EXAMPLES=OFF -D BUILD_opencv_apps=OFF -D BUILD_opencv_world=ON<br><br>cmake --build build --target opencv_world --config Release<br>cmake --build build --target opencv_world --config Debug<br><br><span class="hljs-built_in">echo</span>.<br><span class="hljs-built_in">pause</span><br></code></pre></td></tr></table></figure><h3 id="dp0"><a href="#dp0" class="headerlink" title="%~dp0"></a>%~dp0</h3><p>当前 batch 文件的路径。</p><h3 id="cmake-B-build"><a href="#cmake-B-build" class="headerlink" title="cmake -B build"></a>cmake -B build</h3><p>配置阶段，会在当前目录下生成 <code>build</code> 文件夹，并在其中生成一系列 cmake 缓存。<code>-D</code> 之类的配置正是在这个阶段进行的，不过由于缓存的机制，只有在第一次 <code>-B</code> 的时候 <code>-D</code> 等配置才会生效。<br>任何时候都可以通过删除 <code>build/CMakeCache.txt</code> 或整个 <code>build</code> 文件夹来删除缓存，以便重新运行 <code>-B</code>。</p><h3 id="CMAKE-CONFIGURATION-TYPES"><a href="#CMAKE-CONFIGURATION-TYPES" class="headerlink" title="CMAKE_CONFIGURATION_TYPES"></a>CMAKE_CONFIGURATION_TYPES</h3><p>指定多配置生成器（如 VS，XCode，Ninja）上可用的构建类型，常见有 <code>Debug</code>, <code>Release</code>, <code>RelWithDebInfo</code> 和 <code>MinSizeRel</code>。<br>相对于用于指定单配置生成器的构建类型的 <code>CMAKE_BUILD_TYPE</code>。</p><h3 id="cmake-–build-build"><a href="#cmake-–build-build" class="headerlink" title="cmake –build build"></a>cmake –build build</h3><p>会使用 build 目录下的 CMake 缓存编译目标文件。</p><h3 id="–target"><a href="#–target" class="headerlink" title="–target"></a>–target</h3><p>用于指定要编译的目标，默认则编译所有目标。</p><h3 id="–config"><a href="#–config" class="headerlink" title="–config"></a>–config</h3><p>用于指定多配置生成器要编译的构建类型，对于单配置生成器会忽略该选项。</p><h2 id="MSBuild"><a href="#MSBuild" class="headerlink" title="MSBuild"></a>MSBuild</h2><p><a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/msbuild-command-line-reference?view=vs-2022">MSBuild 命令行参考</a><br><a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/common-msbuild-project-properties?view=vs-2022">常用的 MSBuild 项目属性</a></p><p>在 windows 中调用 MSBuild 编译现成的 .sln。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bat"><span class="hljs-comment">rem Find MSBuild by vswhere</span><br><span class="hljs-built_in">set</span> &quot;VSWHERE_PATH=<span class="hljs-variable">%ProgramFiles(x86)%</span>\Microsoft Visual Studio\Installer\vswhere.exe&quot;<br><span class="hljs-keyword">for</span> /f &quot;usebackq tokens=*&quot; <span class="hljs-variable">%%i</span> <span class="hljs-keyword">in</span> (`&quot;<span class="hljs-variable">%VSWHERE_PATH%</span>&quot; -latest -requires Microsoft.Component.MSBuild -<span class="hljs-built_in">find</span> MSBuild\**\Bin\MSBuild.exe`) <span class="hljs-keyword">do</span> (<br>  <span class="hljs-built_in">set</span> &quot;MSBUILD_PATH=<span class="hljs-variable">%%i</span>&quot;<br>  <span class="hljs-keyword">goto</span> :exitLoop<br>)<br>:exitLoop<br><span class="hljs-built_in">echo</span> Found MSBuild <span class="hljs-built_in">at</span>: <span class="hljs-variable">%MSBUILD_PATH%</span><br><br>&quot;<span class="hljs-variable">%MSBUILD_PATH%</span>&quot; &quot;<span class="hljs-variable">%OPENCV_PATH%</span>\build\OpenCV.sln&quot; -p:Configuration=Debug;Platform=x64<br>&quot;<span class="hljs-variable">%MSBUILD_PATH%</span>&quot; &quot;<span class="hljs-variable">%OPENCV_PATH%</span>\build\OpenCV.sln&quot; -p:Configuration=Release;Platform=x64<br></code></pre></td></tr></table></figure><h3 id="vswhere"><a href="#vswhere" class="headerlink" title="vswhere"></a>vswhere</h3><p><a href="https://github.com/microsoft/vswhere/wiki/Find-MSBuild">vswhere Find MSBuild</a><br>一个用于查找 Visual Studio 相关路径的软件，当安装 2017 或更高的 VS 版本时，vswhere 会被安装到 <code>%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe</code>。</p><h3 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h3><p>p:<code>name</code>&#x3D;<code>value</code>，设置或重写指定项目级属性，多个属性之间用分号或逗号分隔。</p><p>PS: 我尝试过通过 <code>-p:RuntimeLibrary=MultiThreaded</code> 重写 &#x2F;MT 选项，没有生效，网上信息也比较少。<br><a href="https://stackoverflow.com/questions/38109726/how-to-set-runtime-library-mt-md-configuration-in-msbuild">https://stackoverflow.com/questions/38109726/how-to-set-runtime-library-mt-md-configuration-in-msbuild</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Engineering</tag>
      
      <tag>CMake</tag>
      
      <tag>MSBuild</tag>
      
      <tag>MSVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些第三方库的构建与集成记录</title>
    <link href="/2023/10/14/ThirdParty/"/>
    <url>/2023/10/14/ThirdParty/</url>
    
    <content type="html"><![CDATA[<h2 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h2><p>纯头文件库，包含路径即可。<br><a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">https://eigen.tuxfamily.org/index.php?title=Main_Page</a><br>GitLab：<br><a href="https://gitlab.com/libeigen/eigen">https://gitlab.com/libeigen/eigen</a><br>GitHub:<br><a href="https://github.com/PX4/eigen">https://github.com/PX4/eigen</a></p><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>3.4.0 release 的 .gitignore 相比 GitLab 最新的主分支少两行：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">!Eigen/Core</span><br><span class="hljs-addition">!Eigen/src/Core</span><br></code></pre></td></tr></table></figure><p>直接集成的话 Core 文件会错误地被忽略。</p><h2 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h2><p><a href="https://github.com/opencv/opencv">https://github.com/opencv/opencv</a></p><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><p><em>万恶的 GFW</em></p><ol><li><p>最无脑的解决方案，通过配置<br><code>-DOPENCV_DOWNLOAD_MIRROR_ID=gitcode</code><br>将下载源改为 GitCode，一个国内代码托管网站。比较依赖于 OpenCV 中国团队和 GitCode 对镜像仓库的维护。<a href="https://mp.weixin.qq.com/s/QhtEjXn126bitN9AQ3_s6w">下载不再卡顿，OpenCV 中国镜像启用</a><br>ps:<br>他们说从 <a href="https://gitcode.net/opencv/opencv">https://gitcode.net/opencv/opencv</a> 下载的代码是不用这条配置的，但是我尝试 clone 下来后看到了 <code>Package ADE from mirror gitcode.net is outdated and will be downloaded from github.com instead.</code> 的警告。提了 Issue 也没反应。<br>然后 GitCode 上的 Release 实际上又是需要这条配置的（意思是 GitCode Release 和 GitHub Release 是一模一样的，而且下载源都是外网。）<br>总之有点抽象，好在 GitHub Latest Release + -DOPENCV_DOWNLOAD_MIRROR_ID&#x3D;gitcode 的组合是没什么问题的。</p></li><li><p>开启代理并配置环境变量<br><a href="https://docs.opencv.org/4.x/db/d05/tutorial_config_reference.html#tutorial_config_reference_general_download">Downloaded dependencies</a></p></li><li><p>手动下载依赖<br><a href="https://zhuanlan.zhihu.com/p/344036896">Visual Studio + OpenCV + OpenCV_contrib 源代码编译流程</a></p></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><a href="https://docs.opencv.org/4.x/db/d05/tutorial_config_reference.html">DOC</a></p><ul><li><p>静态 &#x2F; 动态：<code>BUILD_SHARED_LIBS</code></p></li><li><p>运行时库：<code>BUILD_WITH_STATIC_CRT</code></p></li><li><p>只生单个库文件：<code>BUILD_opencv_world</code></p></li></ul><h2 id="fswatch"><a href="#fswatch" class="headerlink" title="fswatch"></a>fswatch</h2><p><a href="https://github.com/emcrisostomo/fswatch">https://github.com/emcrisostomo/fswatch</a><br>一个使用 GCC 编译的跨平台文件监视器，开发者不太关心 Windows 上的编译体验，深感麻烦。</p><h3 id="安装-MinGW"><a href="#安装-MinGW" class="headerlink" title="安装 MinGW"></a>安装 MinGW</h3><p>我们需要一个 Windows GCC，自然是先装 MinGW-W64。<br>比起直接解压 MinGW 再配置环境变量，更方便的是先安装一个 MSYS2。MSYS2 自带一个包管理器 packman，可以很方便的下载 MinGW 以及更多乱七八糟的依赖。以 <code>Windows</code> <code>MSYS2</code> <code>MinGW</code>  <code>GCC</code> 为关键词搜索应该就能找到不错的教程。</p><h3 id="配置-CMake-生成器"><a href="#配置-CMake-生成器" class="headerlink" title="配置 CMake 生成器"></a>配置 CMake 生成器</h3><p>在指定生成器的阶段我们需要选择 <code>MinGW Makefiles</code> + <code>Specify native compilers</code>，然后将 C 与 C++ 的编译器配置为 MSYS2 安装的 gcc.exe 与 g++.exe 路径。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/ThirdParty/generator.png" alt="指定生成器"></div><div class="group-image-wrap"><img src="/img/ThirdParty/compiler.png" alt="指定本地编译器"></div></div></div><p>路径大概是 <code>C:/msys64/mingw64/bin</code> 之类的。</p><h3 id="配置-CMake-依赖"><a href="#配置-CMake-依赖" class="headerlink" title="配置 CMake 依赖"></a>配置 CMake 依赖</h3><p>Makefile 生成依赖于 MSGFMT，MSGMERGE 与 PTHREAD，前两个都属于 Gettext。<br>如果看到任何 <code>NOTFOUND</code> 字眼，用 MSYS2 搜索并安装对应的库，然后配置对应路径。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>回到根目录执行 <code>cmake --build build</code>，出现如下报错：<br><code>error: &#39;realpath&#39; was not declared in this scope</code><br><code>error: &#39;lstat&#39; was not declared in this scope; did you mean &#39;wstat&#39;?</code><br>结果这似乎是一个遗留 bug，七年没修：<br><a href="https://github.com/emcrisostomo/fswatch/issues/121">https://github.com/emcrisostomo/fswatch/issues/121</a><br>最终是放弃了这个库的集成转而使用了 <a href="https://github.com/septag/dmon">dmon</a>。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/401188789">给萌新的 C&#x2F;C++ 环境搭建攻略（VSCode 和 MSYS2）</a><br><a href="https://zhuanlan.zhihu.com/p/448884264">捋一捋 gcc &#x2F; g++ &#x2F; MingW &#x2F; MSVC 与 make &#x2F; CMake 的关系</a><br><a href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/mingw-vs-mingw-v64.md">[科普][FAQ] MinGW vs MinGW-W64 及其它</a></p><h2 id="GLEW"><a href="#GLEW" class="headerlink" title="GLEW"></a>GLEW</h2><p><a href="https://glew.sourceforge.net/index.html">https://glew.sourceforge.net/index.html</a><br>OpenGL 扩展库。</p><h3 id="静态-动态"><a href="#静态-动态" class="headerlink" title="静态 &#x2F; 动态"></a>静态 &#x2F; 动态</h3><p>CMake 会生成 <code>glew</code> 和 <code>glew_s</code> 两个项目，分别对应了动态与静态的生成目标。<br>然后使用静态库时，要在包含 GLEW 头文件之前定义 <code>GLEW_STATIC</code> 这个宏，写在项目配置里比较好。</p><h3 id="gitignore-1"><a href="#gitignore-1" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>要注意一下 glew 仓库里就有一个 <code>build</code> 文件夹，CMakeLists 也在里面，总觉得不太合理，你叫个什么 <code>builds</code> 都比这好。<br>如果你的仓库忽略了所有叫做 <code>build</code> 的文件夹的，小心这个文件夹也被忽略掉。</p><h2 id="spdlog"><a href="#spdlog" class="headerlink" title="spdlog"></a>spdlog</h2><p><a href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog</a><br>支持纯头文件 &#x2F; 编译两种方式。</p><h3 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h3><p>最近 MSVC 将 <code>stdext::checked_array_iterator</code> 标记为了已弃用，fmt 用到了这个函数，而 spdlog 默认用到了 fmt。这里有几个解决方案：</p><h4 id="1-屏蔽这个警告"><a href="#1-屏蔽这个警告" class="headerlink" title="1. 屏蔽这个警告"></a>1. 屏蔽这个警告</h4><p>为项目设置 <code>_SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING</code> 宏。</p><h4 id="2-将-spdlog-更新至-v2-x"><a href="#2-将-spdlog-更新至-v2-x" class="headerlink" title="2. 将 spdlog 更新至 v2.x"></a>2. 将 spdlog 更新至 v2.x</h4><p>fmt 已经修复了这个 bug，但 spdlog 作者说为了向后兼容，spdlog v1.x 无法更新 fmt。<br>v2.x 似乎仍在开发中。</p><h4 id="3-为-spdlog-指定外部的-fmt"><a href="#3-为-spdlog-指定外部的-fmt" class="headerlink" title="3. 为 spdlog 指定外部的 fmt"></a>3. 为 spdlog 指定外部的 fmt</h4><p>开启 <code>SPDLOG_FMT_EXTERNAL</code> 或 <code>SPDLOG_FMT_EXTERNAL_HO</code> 宏，手动更新 fmt。<br>spdlog 使用 <code>find_package</code> 查找 fmt，我们需要先生成 fmt，得到 <code>fmt-config.cmake</code> 文件，然后将其所在路径添加至 <code>CMAKE_PREFIX_PATH</code> 或 <code>fmt_DIR</code>，两者都可以用 -D 指令添加。<br>项目中要包含 fmt 的头文件，记得不要把 spdlog bundled 的 fmt 文件包含进项目。<br>在项目内还要手动定义 <code>SPDLOG_FMT_EXTERNAL</code> 和 <code>SPDLOG_COMPILED_LIB</code> 两个宏。<br>如果编译 spdlog 时用的是 <code>SPDLOG_FMT_EXTERNAL_HO</code>，项目中要定义 <code>FMT_HEADER_ONLY</code> 宏。</p><h4 id="4-使用-std-format-代替-fmt"><a href="#4-使用-std-format-代替-fmt" class="headerlink" title="4. 使用 std::format 代替 fmt"></a>4. 使用 <code>std::format</code> 代替 fmt</h4><p>开启 <code>SPDLOG_USE_STD_FORMAT</code> 宏即可。</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p><code>SPDLOG_NO_EXCEPTIONS</code></p><h2 id="yaml-cpp"><a href="#yaml-cpp" class="headerlink" title="yaml-cpp"></a>yaml-cpp</h2><p><a href="https://github.com/jbeder/yaml-cpp">https://github.com/jbeder/yaml-cpp</a><br>YAML 解析库</p><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><ul><li>运行时库：<code>YAML_MSVC_SHARED_RT</code></li><li>静态库需要的宏定义 <code>YAML_CPP_STATIC_DEFINE</code></li></ul><h2 id="shaderc"><a href="#shaderc" class="headerlink" title="shaderc"></a>shaderc</h2><p>集成了 glslang, SPIRV-Tools 和一些其他小功能。<br><a href="https://github.com/google/shaderc">https://github.com/google/shaderc</a></p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>没有 Release，但是有 Tag，commit message 也有写 <code>Finalize Shaderc v2024.2</code> 之类的。</p><h3 id="下载依赖-1"><a href="#下载依赖-1" class="headerlink" title="下载依赖"></a>下载依赖</h3><p>执行 python 脚本下载依赖 <code>/utils/git-sync-deps</code></p><h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><ul><li>静态 &#x2F; 动态：<code>BUILD_SHARED_LIBS</code></li><li>运行时库：<code>SHADERC_ENABLE_SHARED_CRT</code></li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>包含了所有功能的静态库 build&#x2F;libshaderc&#x2F;libshaderc_combined.lib</p><h2 id="SPIRV-Cross"><a href="#SPIRV-Cross" class="headerlink" title="SPIRV-Cross"></a>SPIRV-Cross</h2><p>SPIRV 反编译库<br><a href="https://github.com/KhronosGroup/SPIRV-Cross">https://github.com/KhronosGroup/SPIRV-Cross</a></p><h3 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h3><p>没有 Release，只有 Tag</p><h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h3><ul><li>静态 &#x2F; 动态：<code>SPIRV_CROSS_SHARED</code>, <code>SPIRV_CROSS_STATIC</code></li><li>运行时库：没有 Cmake 配置，只能改 CMakeLists</li></ul><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><code>spirv-cross-core</code>, <code>spirv-cross-glsl</code>, <code>spirv-cross-hlsl</code>, <code>spirv-cross-msl</code></p><h2 id="SDL"><a href="#SDL" class="headerlink" title="SDL"></a>SDL</h2><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>官方推荐编译为动态库，实际上编译为静态库时需要手动链接几个依赖库，具体可以查看 CMake log。</p><h3 id="SDL-config-h"><a href="#SDL-config-h" class="headerlink" title="SDL_config.h"></a>SDL_config.h</h3><p>SDL 会在 build 目录下生成不同配置的 SDL_config.h，我们需要在工程里包含这个路径：<code>\build\include-config-release\SDL2\SDL_config.h</code></p><h2 id="Assimp"><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h2><h3 id="配置-5"><a href="#配置-5" class="headerlink" title="配置"></a>配置</h3><ul><li>静态 &#x2F; 动态：<code>BUILD_SHARED_LIBS</code></li><li>运行时库：<code> USE_STATIC_CRT</code></li></ul><h3 id="config-h"><a href="#config-h" class="headerlink" title="config.h"></a>config.h</h3><p>assimp 会在 build 目录下生成 config.h，我们需要在工程里包含这个路径：<code>\build\include\assimp\config.h</code></p><h3 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h3><p>还需要手动链接 zlib，这个库会被默认编译至 <code>\build\contrib\zlib</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
      <tag>CMake</tag>
      
      <tag>Eigen</tag>
      
      <tag>fswatch</tag>
      
      <tag>GLEW</tag>
      
      <tag>OpenCV</tag>
      
      <tag>Premake</tag>
      
      <tag>shaderc</tag>
      
      <tag>spdlog</tag>
      
      <tag>SPIRV-Cross</tag>
      
      <tag>yaml-cpp</tag>
      
      <tag>SDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAMES101 拾遗</title>
    <link href="/2023/10/13/GAMES101Review/"/>
    <url>/2023/10/13/GAMES101Review/</url>
    
    <content type="html"><![CDATA[<h2 id="Lecture-02-Review-of-Linear-Algebra"><a href="#Lecture-02-Review-of-Linear-Algebra" class="headerlink" title="Lecture 02 Review of Linear Algebra"></a>Lecture 02 Review of Linear Algebra</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101Review/dot.png" alt="点乘"></div><div class="group-image-wrap"><img src="/img/GAMES101Review/cross.png" alt="叉乘"></div></div></div><p>对于一个 vec4，一般认为 w 分量为 1 时表示点，w 分量 为 0 时表示向量。<br>也符合“点 - 点 &#x3D; 向量”</p><h2 id="Lecture-04-Transformation-Cont"><a href="#Lecture-04-Transformation-Cont" class="headerlink" title="Lecture 04 Transformation Cont."></a>Lecture 04 Transformation Cont.</h2><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101Review/rotation.png" alt="绕轴旋转"></div><div class="group-image-wrap"><img src="/img/GAMES101Review/rotationn.png" alt="绕任意轴旋转"></div></div></div><h3 id="相机定义"><a href="#相机定义" class="headerlink" title="相机定义"></a>相机定义</h3><ul><li>位置：e</li><li>看向：g</li><li>头顶：t</li></ul><h3 id="Frustum-定义"><a href="#Frustum-定义" class="headerlink" title="Frustum 定义"></a>Frustum 定义</h3><ul><li>$tan\frac{fovY}{2} &#x3D; \frac{t}{|n|}$</li><li>$aspect &#x3D; \frac{r}{t}$</li></ul><h3 id="View-矩阵"><a href="#View-矩阵" class="headerlink" title="View 矩阵"></a>View 矩阵</h3><p>将相机变换至“位于原点，看向 -Z，头顶为 +Y”<br>先移动至原点，再旋转<br>$M_{view}&#x3D;R_{view}T_{view}$</p><p>$T_{view}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  1 &amp; 0 &amp; 0 &amp; -x_e \<br>  0 &amp; 1 &amp; 0 &amp; -y_e \<br>  0 &amp; 0 &amp; 1 &amp; -z_e \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$</p><p>由 $R_{view}^{-1}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  x_{g \times t} &amp; x_t &amp; x_{-g} &amp; 0 \<br>  y_{g \times t} &amp; y_t &amp; y_{-g} &amp; 0 \<br>  z_{g \times t} &amp; z_t &amp; z_{-g} &amp; 0 \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$<br>得 $R_{view}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  x_{g \times t} &amp; y_{g \times t} &amp; z_{g \times t} &amp; 0 \<br>  x_t &amp; y_t &amp; z_t &amp; 0 \<br>  x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$</p><h3 id="Projection-矩阵"><a href="#Projection-矩阵" class="headerlink" title="Projection 矩阵"></a>Projection 矩阵</h3><p>先透视，再正交（Frustum -&gt; 长方体 -&gt; 正方体）<br>$M_{Projection}&#x3D;M_{Orthographic}M_{PersprctiveToOrthographic}$</p><p>$M_{p2o}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  n &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; n &amp; 0 &amp; 0 \<br>  0 &amp; 0 &amp; n+f &amp; -nf \<br>  0 &amp; 0 &amp; 1 &amp; 0 \<br>  \end{pmatrix}<br>$$</p><p>$M_{Orthographic}&#x3D;M_{rotate}M_{trans}$</p><p>$M_{trans}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \<br>  0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \<br>  0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$</p><p>$M_{rotate}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  \frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \<br>  0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$</p><h3 id="Viewport-视口变换"><a href="#Viewport-视口变换" class="headerlink" title="Viewport 视口变换"></a>Viewport 视口变换</h3><p>$M_{viewport}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  \frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \<br>  0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \<br>  0 &amp; 0 &amp; 1 &amp; 0 \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$</p><h2 id="Lecture-09-Shading-3-Texture-Mapping-Cont"><a href="#Lecture-09-Shading-3-Texture-Mapping-Cont" class="headerlink" title="Lecture 09 Shading 3(Texture Mapping Cont.)"></a>Lecture 09 Shading 3(Texture Mapping Cont.)</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101Review/bc.png" alt="重心坐标"></div><div class="group-image-wrap"><img src="/img/GAMES101Review/bc2.png" alt="重心坐标"></div><div class="group-image-wrap"><img src="/img/GAMES101Review/bi.png" alt="双线性插值"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101Review/mm.png" alt="Mipmap"></div><div class="group-image-wrap"><img src="/img/GAMES101Review/ti.png" alt="三线性插值"></div><div class="group-image-wrap"><img src="/img/GAMES101Review/bm.png" alt="Bump"></div></div></div><p>当重心坐标相加为 1 且全部在 [0, 1] 的范围内，即代表点在三角形内。</p><h2 id="Lecture-13-Ray-Tracing-1"><a href="#Lecture-13-Ray-Tracing-1" class="headerlink" title="Lecture 13 Ray Tracing 1"></a>Lecture 13 Ray Tracing 1</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101Review/rayplane.png" alt="射线平面相交"></div><div class="group-image-wrap"><img src="/img/GAMES101Review/aa.png" alt="轴对齐的简化"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101Review/moller.png" alt="Moller Trumbore 算法"></div></div></div><h3 id="求射线与-AABB-求交"><a href="#求射线与-AABB-求交" class="headerlink" title="求射线与 AABB 求交"></a>求射线与 AABB 求交</h3><ul><li>对三个轴每一对平面，计算 $t_{min}$ 与 $t_{max}$，负值也 OK。</li><li>对于 AABB，$t_{enter} &#x3D; max(t_{min})$，$t_{exit} &#x3D; min(t_{max})$。</li><li>当且仅当 $t_{enter} &lt; t_{exit}$ &amp;&amp; $t_{exit} &gt;&#x3D; 0$ 时射线与 AABB 相交。</li></ul><h2 id="Lecture-15-Ray-Tracing-3"><a href="#Lecture-15-Ray-Tracing-3" class="headerlink" title="Lecture 15 Ray Tracing 3"></a>Lecture 15 Ray Tracing 3</h2><p><a href="https://roeas.github.io/2021/09/14/Radiometry/">辐射度量学基础</a></p><h2 id="Lecture-16-Ray-Tracing-4"><a href="#Lecture-16-Ray-Tracing-4" class="headerlink" title="Lecture 16 Ray Tracing 4"></a>Lecture 16 Ray Tracing 4</h2><h3 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h3><p>$L_o(p,\omega_o)$</p><p>$&#x3D;\int_{H^2}L_i(p, \omega_i)f_r(p, \omega_i, \omega_o)(n\cdot \omega_i)d\omega_i$</p><p>$\approx\frac{1}{N}\sum^N_{i&#x3D;1}\frac{L_i(p, \omega_i)f_r(p, \omega_i, \omega_o)(n\cdot \omega_i)}{p(\omega_i)}$</p><h3 id="Light-Sampling"><a href="#Light-Sampling" class="headerlink" title="Light Sampling"></a>Light Sampling</h3><p><img src="/img/GAMES101Review/LightSampling.png" alt="LightSampling"></p><h3 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c">shade<span class="hljs-punctuation">(</span>p<span class="hljs-punctuation">,</span> wo<span class="hljs-punctuation">)</span><br>  <span class="hljs-comment">// 来自光源的贡献</span><br>  均匀地采样 x&#x27; 处的光源（pdf_light = 1 / A）<br>  如果 p 点和 x&#x27; 点之间没有遮挡<br>    L_dir <span class="hljs-punctuation">=</span> L_i * f_r * <span class="hljs-built_in">cos</span>θ * <span class="hljs-built_in">cos</span>θ&#x27; / |x&#x27; <span class="hljs-punctuation">-</span> p<span class="hljs-string">|^2 / pdf_light</span><br><br>  <span class="hljs-comment">// 来自其他表面的贡献</span><br>  如果通过以概率 P_RR 进行的轮盘赌测试<br>    均匀地采样半球（pdf_hemi <span class="hljs-punctuation">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">2</span>pi）<br>    追踪光线 r<span class="hljs-punctuation">(</span>p<span class="hljs-punctuation">,</span> wi<span class="hljs-punctuation">)</span><br>    如果在 q 点击中非光源表面<br>      L_indir <span class="hljs-punctuation">=</span> shade<span class="hljs-punctuation">(</span>q<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">-</span>wi<span class="hljs-punctuation">)</span> * f_r * <span class="hljs-built_in">cos</span>θ / pdf_hemi / P_RR<br><br>  return L_dir <span class="hljs-punctuation">+</span> L_indir<br></code></pre></td></tr></table></figure><h3 id="Lambertian-表面的的-BRDF"><a href="#Lambertian-表面的的-BRDF" class="headerlink" title="Lambertian 表面的的 BRDF"></a>Lambertian 表面的的 BRDF</h3><p><img src="/img/GAMES101Review/Lambertian.png" alt="Lambertian"></p><h2 id="Lecture-19-Cameras-Lenses-and-Light-Fields"><a href="#Lecture-19-Cameras-Lenses-and-Light-Fields" class="headerlink" title="Lecture 19 Cameras, Lenses and Light Fields"></a>Lecture 19 Cameras, Lenses and Light Fields</h2><p><img src="/img/GAMES101Review/gaussian.png" alt="Gaussian"></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101Review/CoC.png" alt="Coc"></div><div class="group-image-wrap"><img src="/img/GAMES101Review/CoC2.png" alt="Coc2"></div></div></div><p><img src="/img/GAMES101Review/DoF.png" alt="DoF"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Rendering</tag>
      
      <tag>RayTracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 工作流</title>
    <link href="/2023/07/22/GitHub/"/>
    <url>/2023/07/22/GitHub/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>&emsp;&emsp;一些工作中常用的 git &#x2F; GitHub 概念整理。</p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="https://zhuanlan.zhihu.com/p/51331026">如何为自己的 Github 项目选择开源许可证？</a></p><h2 id="分支与开发"><a href="#分支与开发" class="headerlink" title="分支与开发"></a>分支与开发</h2><p>对于正规一点的仓库，main branch 通常是受保护的，而我们的提交与推送都在单独的 branch 上进行。</p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><ul><li><code>git branch</code> 查看本地分支</li><li><code>git branch -r</code> 查看远程分支</li><li><code>git branch -a</code> 查看所有分支</li></ul><p>注意：如果远程新建了 branch，在本地运行 <code>git remote update origin</code> 之前，新的 branch 是不会显示在 <code>git branch -r</code> 上的。顺便在任意 branch 上的 <code>git pull</code> 也能实现这一效果。</p><h3 id="操作分支"><a href="#操作分支" class="headerlink" title="操作分支"></a>操作分支</h3><ul><li><code>git branch &lt;Name&gt;</code> 创建新的本地分支，不会 checkout</li><li><code>git branch -m &lt;OldName&gt; &lt;NewName&gt;</code> 重命名本地分支</li><li><code>git branch -d &lt;Name&gt;</code> 删除本地分支，不能删除当前分支</li><li><code>git branch -d -r &lt;Name&gt;</code> 删除远程分支</li></ul><h3 id="关联分支"><a href="#关联分支" class="headerlink" title="关联分支"></a>关联分支</h3><ul><li><code>git branch --set-upstream-to=origin/&lt;RemoteName&gt; &lt;LocalName&gt;</code> 将本地分支与远程分支关联起来</li><li><code>git push --set-upstream origin &lt;RemoteName&gt;</code> 在远程新建分支，并将当前分支与远程新分支关联并推送。</li></ul><p>当然最简单的命令是本地识别到远程新分支后直接：<br><code>git checkout &lt;RemoteName&gt;</code><br>这个命令相当于<br><code>git checkout -b &lt;LocalName&gt; origin/&lt;RemoteName&gt;</code><br>即在本地新建分支，并且切换过去，并且与远程分支建立联系。</p><ul><li><code>git branch -vv</code> 查看本地分支核远程的对应关系</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>当你的 branch 准备好之后，就可以在 github 上发起 Pull Request，通知仓库相关的开发者检查代码以及帮忙合并。<br><img src="/img/GitHub/pr.png" alt="Pull Request"></li><li>add, rm, commit, push 之类的操作直接用 VS 的 <code>Git 更改</code> 视图，或者 <code>Git GUI</code> 就好，比命令方便得多。</li><li>一般来说，除非很紧急的情况，请在获得 approve 和 review 之后再进行合并。</li><li>选择 Sauash Merge 的方式将 pr 内多个 commit 合并为一个 commit 提交到 main 分支上。</li></ul><h2 id="冲突与合并"><a href="#冲突与合并" class="headerlink" title="冲突与合并"></a>冲突与合并</h2><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>在发起 pr 后，github 会自动帮你检查该分支是否与主分支有冲突。简单的冲突可以直接在网页端解决，也可以回到本地进行如下操作：</p><ul><li><code>git checkout main</code> 切换回主分支</li><li><code>git pull</code> 拉取最新的主分支</li><li>可以顺便确认一下主分支的编译与运行是否正常</li><li><code>git checkout &lt;Name&gt;</code> 切换回冲突分支</li><li><code>git merge main</code> 合并主分支与冲突分支</li><li>进入 <code>Git 更改</code> 视图解决冲突</li><li>提交与推送，查看 github</li></ul><p>VS 提供了非常直观的图形界面来帮助我们解决冲突，在不确定如何解决的情况下可以联系冲突文件的上一个开发者帮忙合并。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ul><li>想在当前 branch 应用某个别的 branch 的修改？同样是将对应的 branch pull 下来，merge 即可。</li><li>不想 merge 整个 branch，或者 对方的 branch 还在开发中？使用 <code>git cherry-pick &lt;CommitHash&gt;</code> 以 commit 为粒度进行合并。</li></ul><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>本地所有未 add 的改动我都不想要，怎么撤销？</p><ul><li><code>git checkout .</code> 清除未 add 的所有改动，无法删除新增的文件。</li></ul><h3 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h3><p>本地 add 了的改动我也不想要，怎么撤销？</p><ul><li><code>git reset [--soft | --mixed | --hard] [HEAD]</code><ul><li><code>--mixed</code> 默认模式，不删除改动代码，撤销 commit，撤销 add</li><li><code>--soft</code> 不删除改动代码，撤销 commit，不撤销 add</li><li><code>--hard</code> 删除改动代码，撤销 commit，撤销 add</li><li><code>HEAD</code> 默认版本<ul><li><code>HEAD</code> 和 <code>HEAD~0</code> 表示当前版本</li><li><code>HEAD^</code> 和 <code>HEAD~1</code> 表示上一个版本</li><li><code>HEAD^^</code> 和 <code>HEAD~2</code> 表示上上个版本</li><li>依此类推</li></ul></li></ul></li></ul><p>当我们需要撤销暂存区里的代码时，可以 <code>git reset</code> 将暂存区回退到工作区，然后 <code>git checkout .</code> 清除工作区。<br>或者直接 <code>git reset --hard</code> 把工作区和暂存区的修改全扬了，这个指令也能删除暂存区中的新增文件，反而删除不了工作区中的新增文件。</p><h3 id="Git-更改视图"><a href="#Git-更改视图" class="headerlink" title="Git 更改视图"></a>Git 更改视图</h3><p>其实对工作区和暂存区的操作完全可以由 VS 提供的图形界面完成，非常方便直观。</p><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>上一个 commit 太蠢了，怎么撤销？</p><ul><li><code>git log</code> 查看提交日志，获取想要回退的 commit 哈希<br><em>ps: 按q退出</em></li><li><code>git reset --soft &lt;CommitHash&gt;</code> 回退到 CommitHash 对应的 commit，即如果我要撤销 commit <code>balabala</code>，reset 的参数应该是 <code>balabala</code> 的上一个 commit 的哈希。<br>这种情况下我比较习惯用 <code>--soft</code> 将 commit 回退到暂存区而非默认的工作区，如果此时本地工作区有修改便能将他们区分开来。</li></ul><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>commit 已经 push 上去了，怎么撤销？<br>在完成上一节之后，本地和远程其实处于一个冲突的状态，这时候只需要用<br><code>git push --force</code><br>强制将远程的 log 同步成本地的状态。</p><h3 id="PR"><a href="#PR" class="headerlink" title="PR"></a>PR</h3><p>pr 已经 merge 了，怎么撤销？<br>在该 pr 的最下方的 merge 右侧找到 <code>Revert</code>，这个按钮会自动创建一个新的 branch 以及 pr，并且在其中将原 pr 内的所有修改反向操作。当然尽量不要出现这种不得不 Revert 的情况。<br><img src="/img/GitHub/revert.png" alt="Revert"></p><h2 id="Git-Submodule"><a href="#Git-Submodule" class="headerlink" title="Git Submodule"></a>Git Submodule</h2><p>git 提供了子模块功能将一个仓库集成为另一个仓库的子目录，并且让他们保持独立的提交。<br>子模块有一个非常抽象的特性：在主仓库中如果不使用 <code>submodule</code> 相关的指令，子模块的内容不会受到任何 git 指令的影响，不受主仓库切换分支的影响，甚至不会在主仓库 clone 之后出现在你的硬盘里。</p><h3 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h3><p><code>git submodule add &lt;url&gt; &lt;path&gt;</code> 将 url 对应的仓库作为子模块添加到 path 路径下<br>添加子模块后主仓库会新增一个 <code>.gitmodules</code> 文件来描述子模块的信息。<br><img src="/img/GitHub/sb.png" alt=".gitmodules"><br><em>不想让第三方库的不受控的更新破坏自己的主仓库？将其 fork 一份再集成为子模块即可。</em></p><h3 id="Clone-带有子模块的仓库"><a href="#Clone-带有子模块的仓库" class="headerlink" title="Clone 带有子模块的仓库"></a>Clone 带有子模块的仓库</h3><p><code>git clone --recursive &lt;url&gt;</code> 将仓库内容以及子模块内容以及子模块的子模块内容递归地 clone 下来。<br>如果 clone 的时候没有带上 <code>--recursive</code> 参数，也可以在 clone 结束后在仓库目录运行 <code>git submodule update --init --recursive</code> 达成一样的效果。<br><code>--init</code> 参数用于在 <code>.git/config</code> 中注册子模块信息。</p><h3 id="更新子模块"><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h3><p><code>git submodule update</code> 将子模块更新到最新版本<br><code>git submodule update --remote</code> 将子模块更新到远程的最新版本<br>有什么区别呢，这里要引出子模块另一个非常抽象的特性：区分六个概念：<code>远程的主仓库</code>、<code>本地的主仓库</code>、<code>远程的子仓库</code>、<code>本地的子仓库</code>、<code>远程主仓库中的子仓库</code>、<code>本地主仓库中的子仓库</code>，这六个东西的版本是可以不同的。</p><ul><li>重点在于，主仓库中会存储一个子模块的 commit 版本，<code>git submodule update</code> 只能将 <code>本地的子仓库</code> 更新为 <code>本地主仓库中的子仓库</code> 版本。</li><li>或者先使用 <code>git pull</code> 将 <code>本地主仓库中的子仓库</code> 版本更新为 <code>远程主仓库中的子仓库</code> 版本，再结合使用 <code>git submodule update</code> 即可将 <code>本地的子仓库</code> 更新为 <code>远程主仓库中的子仓库</code> 版本。<br><em>这也是 clone 之后，对着空空如也的子模块文件夹使用 <code>git submodule update</code> 即可将其更新的原因</em></li><li>而 <code>git submodule update --remote</code> 实际上相当于进入每一个子模块执行 <code>git pull</code>，即将 <code>本地的子仓库</code> 更新为 <code>远程的子仓库</code>。</li><li>最后一步，如何更新 <code>远程主仓库中的子仓库</code> 版本呢？在 <code>本地主仓库中的子仓库</code> 版本与 <code>本地的子仓库</code> 不同时，在主仓库执行 commit 即可更新 <code>本地主仓库中的子仓库</code> 版本。在 <code>远程主仓库中的子仓库</code> 与 <code>本地主仓库中的子仓库</code> 版本不同时，在主仓库执行 push 即可更新 <code>远程主仓库中的子仓库</code> 版本。</li></ul><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul><li>如果 <code>.gitmodules</code> 中的 url 有变或者新增，<code>git submodule update</code> 是无法将其更新的，保险起见，我们可以在每一次 update 子模块之前执行 <code>git submodule init</code>。</li><li>只希望 <code>git submodule update --remote</code> 更新指定的子模块而非更新所有的子模块？使用 <code>git submodule update --remote &lt;Path&gt;</code> 指定子模块的路径即可。具体路径可以在 <code>.gitmodules</code> 文件中确认。</li></ul><h3 id="开发子模块"><a href="#开发子模块" class="headerlink" title="开发子模块"></a>开发子模块</h3><p>子模块最抽象的特性：当我们使用 <code>git submodule update</code> 对子模块进行更新之后，子模块实际上会处于一个游离的 branch 上并且这个 branch 是 main（不一定是 main，可以配置）的复制。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch</span><br><span class="hljs-keyword"></span>* (HEAD detached <span class="hljs-built_in">at</span> abcdefg)<br>  main<br></code></pre></td></tr></table></figure><p>在这个 branch 上的所有工作不但无法进行 push，甚至会在下一次 <code>git submodule update</code> 之后丢失。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>子模块的设计非常复杂且反直觉，好在我们可以通过一些项目规范和开发习惯来规避一些使用子模块带来的的副作用。</p><ul><li>对子模块的 main branch 进行保护，所有的开发都在特定的 branch 上进行，以避免游离的 HEAD 带来的困扰。</li><li>开发子模块时，将其单独 clone 下来或者复制出来，总之不要直接在主仓库里的子模块里进行开发，以免主仓库检测到子模块 commit 的更新。</li><li>在主仓库中更新子模块时，不要在更新 <code>主仓库中的子仓库</code> 版本之前更新依赖于子模块新版本的代码。</li><li>主仓库与子模块同步更新之后视情况通知其他开发者，毕竟在主仓库 <code>git pull</code> 只会更新依赖于子模块新版本的代码，而无法更新子模块。</li><li>当我们在主仓库 <code>git pull</code> 之后发现检测出了子模块的更新（这种情况属于 <code>本地的子仓库</code> 落后于 <code>本地主仓库中的子仓库</code> 版本），手动执行 submodule update。</li><li>项目保证主仓库只使用子模块的特定分支，且当 <code>主仓库中的子仓库</code> 产生冲突时，以最新的子模块版本为准。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://iphysresearch.github.io/blog/post/programing/git/git_submodule/">Git: submodule 子模块简明教程</a><br><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">7.11 Git 工具 - 子模块</a></p><h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p>GitHub Actions 是 github 推出的持续集成工具，简单来说就是可以在我们每次提交代码后在服务器上自动运行一些指令。我们不需要太复杂的 action，在仓库 build system 完备的基础上，只需要在代码提交后让 github 服务器自动运行我们的构建脚本并且检查仓库的构建与编译是否正常即可，以保证每一次 pr 都不会破坏仓库。</p><p><a href="https://docs.github.com/zh/actions">官方文档</a><br>GitHub Actions 使用 YAML 来定义工作流程。 每个工作流都作为单独的 YAML 文件存储在 <code>.github/workflows/*.yml</code>。</p><p>一个简单的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">build</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">&quot;main&quot;</span> ]<br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">&quot;main&quot;</span> ]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">Windows:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">windows-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">out</span> <span class="hljs-string">repository</span> <span class="hljs-string">under</span> <span class="hljs-string">$GITHUB_WORKSPACE.</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br>    <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Add</span> <span class="hljs-string">MSBuild</span> <span class="hljs-string">to</span> <span class="hljs-string">PATH.</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">microsoft/setup-msbuild@v1.1</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">project.</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/Setup.bat</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">x64</span> <span class="hljs-string">Debug.</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">msbuild</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/HinaEngine.sln</span> <span class="hljs-string">/p:Configuration=Debug</span> <span class="hljs-string">/p:Platform=x64</span><br>      <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">x64</span> <span class="hljs-string">Release.</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">msbuild</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/HinaEngine.sln</span> <span class="hljs-string">/p:Configuration=Release</span> <span class="hljs-string">/p:Platform=x64</span><br></code></pre></td></tr></table></figure><h3 id="on"><a href="#on" class="headerlink" title="on"></a>on</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">&quot;main&quot;</span> ]<br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">&quot;main&quot;</span> ]<br></code></pre></td></tr></table></figure><p>代表这个 actions 会被 main branch 上的 push 和 pr 动作触发。</p><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">Windows:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">windows-latest</span><br></code></pre></td></tr></table></figure><ul><li>job 定义了最粗粒度的任务，默认每个 job 之间是并行的， 也可以用 <code>needs:</code> 来指定 job 之间的依赖关系，不过我们习惯使用多个 .yml 每个运行一个 job。</li><li><code>Windows:</code> 是自定义的 job 名称，<code>runs-on:</code> 用于指定系统的运行环境，其他环境详见 <a href="https://docs.github.com/zh/actions/using-workflows/workflow-syntax-for-github-actions#%E9%80%89%E6%8B%A9-github-%E6%89%98%E7%AE%A1%E7%9A%84%E8%BF%90%E8%A1%8C%E5%99%A8">选择 GitHub 托管的运行器</a>。</li></ul><h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">steps:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">out</span> <span class="hljs-string">repository</span> <span class="hljs-string">under</span> <span class="hljs-string">$GITHUB_WORKSPACE.</span><br>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Add</span> <span class="hljs-string">MSBuild</span> <span class="hljs-string">to</span> <span class="hljs-string">PATH.</span><br>  <span class="hljs-attr">uses:</span> <span class="hljs-string">microsoft/setup-msbuild@v1.1</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">project.</span><br>  <span class="hljs-attr">run:</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/Setup.bat</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">x64</span> <span class="hljs-string">Debug.</span><br>  <span class="hljs-attr">run:</span> <span class="hljs-string">msbuild</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/HinaEngine.sln</span> <span class="hljs-string">/p:Configuration=Debug</span> <span class="hljs-string">/p:Platform=x64</span><br>  <br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">x64</span> <span class="hljs-string">Release.</span><br>  <span class="hljs-attr">run:</span> <span class="hljs-string">msbuild</span> <span class="hljs-string">$&#123;&#123;github.workspace&#125;&#125;/HinaEngine.sln</span> <span class="hljs-string">/p:Configuration=Release</span> <span class="hljs-string">/p:Platform=x64</span><br></code></pre></td></tr></table></figure><ul><li><code>steps:</code> 定义了该 job 中的每一步指令，在这里我们的流程是 1. 拉取仓库 2. 将 MSBuild 添加至环境变量 3. 构建与编译项目</li><li>不同仓库中的一些操作是类似的，github 也在 <a href="https://github.com/marketplace?type=actions">Actions 市场</a> 中提供了一系列封装好的命令。比如：<ul><li><code>actions/checkout@v3</code> 代表了将仓库拉取到 <code>$GITHUB_WORKSPACE</code>。<a href="https://github.com/marketplace/actions/checkout">Checkout</a></li><li><code>microsoft/setup-msbuild@v1.1</code> 代表寻找 MSBuild 的路径，并且将其添加到环境变量。<a href="https://github.com/marketplace/actions/setup-msbuild">setup-msbuild</a></li><li>检查这些 action 的官方页面以获取最新的版本号。</li></ul></li><li><code>$&#123;&#123;github.workspace&#125;&#125;</code> 代表了在命令行中该仓库的根目录。<code>Setup.bat</code> 是我们自定义的项目构建脚本，我们最终会在这个脚本中运行 premake 并且生成项目的 .sln 文件。</li><li>接着在命令行中编译项目的 Debug 和 Release 版本。msbuild 命令行详见 <a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/msbuild-command-line-reference?view=vs-2022">MSBuild 命令行参考</a> 和 <a href="https://learn.microsoft.com/zh-cn/visualstudio/msbuild/common-msbuild-project-properties?view=vs-2022">常用的 MSBuild 项目属性</a>。</li></ul><h3 id="Check-Failed"><a href="#Check-Failed" class="headerlink" title="Check Failed"></a>Check Failed</h3><p>Action 检查未通过是非常常见的，这时候只需要检查一下 Details 往往能帮我们定位错误。<br><img src="/img/GitHub/action.png" alt=".gitmodules"><br>有时候他的报错会非常抽象，如果你认为这个 failed 可能不是你的问题，可以尝试在失败的 Actions 界面点击 <code>Re-run job</code> 按钮。</p><h3 id="在-README-中添加状态徽章"><a href="#在-README-中添加状态徽章" class="headerlink" title="在 README 中添加状态徽章"></a>在 README 中添加状态徽章</h3><p>github actions 会将自身运行的状态生成为一张图片，我们可以用这个链接访问它：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/&lt;OWNER&gt;/</span>&lt;REPOSITORY&gt;<span class="hljs-regexp">/actions/</span>workflows<span class="hljs-regexp">/&lt;WORKFLOW_FILE&gt;/</span>badge.svg<br></code></pre></td></tr></table></figure><p>然后将其作为图片塞入 markdown 语法中并指向仓库的 actions 界面：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs md">[<span class="hljs-string">![win64_vs2022_msvc</span>](<span class="hljs-link">https://github.com/CatDogEngine/CatDogEngine/actions/workflows/win64_vs2022_msvc.yml/badge.svg?branch=main</span>)](<span class="hljs-link">https://github.com/CatDogEngine/CatDogEngine/actions/workflows/win64_vs2022_msvc.yml</span>)<br></code></pre></td></tr></table></figure><p>效果：<br><a href="https://github.com/CatDogEngine/CatDogEngine/actions/workflows/win64_vs2022_msvc.yml"><img src="https://github.com/CatDogEngine/CatDogEngine/actions/workflows/win64_vs2022_msvc.yml/badge.svg?branch=main" alt="win64_vs2022_msvc"></a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>歌单</title>
    <link href="/2023/07/01/Song/"/>
    <url>/2023/07/01/Song/</url>
    
    <content type="html"><![CDATA[<h2 id="日文"><a href="#日文" class="headerlink" title="日文"></a>日文</h2><h3 id="术力口"><a href="#术力口" class="headerlink" title="术力口"></a>术力口</h3><h4 id="glow"><a href="#glow" class="headerlink" title="glow"></a>glow</h4><ul><li>参考：<a href="https://www.bilibili.com/video/BV1Ne4y1j7E7/">https://www.bilibili.com/video/BV1Ne4y1j7E7/</a> （鹿乃）</li></ul><h4 id="オノマトペ-拟声词"><a href="#オノマトペ-拟声词" class="headerlink" title="オノマトペ &#x2F; 拟声词"></a>オノマトペ &#x2F; 拟声词</h4><ul><li>参考：<a href="https://www.bilibili.com/video/BV1vN411o7Bo/">https://www.bilibili.com/video/BV1vN411o7Bo/</a> （长泽陵川）</li><li>升降：+1</li></ul><h4 id="夏に去りし君を想フ-思念于夏日离去的你"><a href="#夏に去りし君を想フ-思念于夏日离去的你" class="headerlink" title="夏に去りし君を想フ &#x2F; 思念于夏日离去的你"></a>夏に去りし君を想フ &#x2F; 思念于夏日离去的你</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Tx411w7st/">https://www.bilibili.com/video/BV1Tx411w7st/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1cx411A7tJ/">https://www.bilibili.com/video/BV1cx411A7tJ/</a> （ダズビー）</li></ul><h4 id="独りんぼエンヴィー-孑然妒火"><a href="#独りんぼエンヴィー-孑然妒火" class="headerlink" title="独りんぼエンヴィー &#x2F; 孑然妒火"></a>独りんぼエンヴィー &#x2F; 孑然妒火</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1mx411F7Hm/">https://www.bilibili.com/video/BV1mx411F7Hm/</a> （原唱）</li><li>参考：<a href="https://www.bilibili.com/video/BV1TT411x7eE/">https://www.bilibili.com/video/BV1TT411x7eE/</a> （宵崎奏, 暁山瑞希, 初音ミク）</li></ul><h4 id="愛して愛して愛して"><a href="#愛して愛して愛して" class="headerlink" title="愛して愛して愛して"></a>愛して愛して愛して</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Qx411A7TS/">https://www.bilibili.com/video/BV1Qx411A7TS/</a> （初音）</li></ul><h4 id="ラヴィ-Lavie"><a href="#ラヴィ-Lavie" class="headerlink" title="ラヴィ &#x2F; Lavie"></a>ラヴィ &#x2F; Lavie</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1g8411Y7oW/">https://www.bilibili.com/video/BV1g8411Y7oW/</a> （鏡音レン）</li><li>参考：<a href="https://www.bilibili.com/video/BV1wH4y1r75r?p=2">https://www.bilibili.com/video/BV1wH4y1r75r?p=2</a> （异世界情绪）</li><li>参考：<a href="https://www.bilibili.com/video/BV1zG4y147Vv/">https://www.bilibili.com/video/BV1zG4y147Vv/</a> （麻婆豆腐）</li><li>升降：+5</li></ul><h4 id="限りなく灰色へ-向着无限之灰"><a href="#限りなく灰色へ-向着无限之灰" class="headerlink" title="限りなく灰色へ &#x2F; 向着无限之灰"></a>限りなく灰色へ &#x2F; 向着无限之灰</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1gy4y177Gf/">https://www.bilibili.com/video/BV1gy4y177Gf/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV14P4y1773j/">https://www.bilibili.com/video/BV14P4y1773j/</a> （25時、ナイトコードで。）</li></ul><h4 id="シャルル-夏露露"><a href="#シャルル-夏露露" class="headerlink" title="シャルル &#x2F; 夏露露"></a>シャルル &#x2F; 夏露露</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1gs41147c8/">https://www.bilibili.com/video/BV1gs41147c8/</a> （flower）</li><li>参考：<a href="https://www.bilibili.com/video/BV19C4y1a752/">https://www.bilibili.com/video/BV19C4y1a752/</a> （mega）</li><li>升降：-4</li></ul><h4 id="ヴィラン-Villain"><a href="#ヴィラン-Villain" class="headerlink" title="ヴィラン &#x2F; Villain"></a>ヴィラン &#x2F; Villain</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1K7411876y/">https://www.bilibili.com/video/BV1K7411876y/</a> （flower）</li><li>参考：<a href="https://www.bilibili.com/video/BV1SX4y157n5/">https://www.bilibili.com/video/BV1SX4y157n5/</a> （花谱）</li><li>参考：<a href="https://www.bilibili.com/video/BV1pP411z7os/">https://www.bilibili.com/video/BV1pP411z7os/</a> （朝比奈真冬, 暁山瑞希）</li></ul><h4 id="絶頂讃歌-绝顶赞歌"><a href="#絶頂讃歌-绝顶赞歌" class="headerlink" title="絶頂讃歌 &#x2F; 绝顶赞歌"></a>絶頂讃歌 &#x2F; 绝顶赞歌</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1vP41137me/">https://www.bilibili.com/video/BV1vP41137me/</a> （和ぬか）</li><li>参考：<a href="https://www.bilibili.com/video/BV1324y19793/">https://www.bilibili.com/video/BV1324y19793/</a> （Kotoha）</li><li>升降：Pending（-4 ~ -6）</li></ul><h4 id="チュルリラ・チュルリラ・ダッダッダ！-Chururira-Chururira-Daddadda"><a href="#チュルリラ・チュルリラ・ダッダッダ！-Chururira-Chururira-Daddadda" class="headerlink" title="チュルリラ・チュルリラ・ダッダッダ！&#x2F; Chururira Chururira Daddadda!"></a>チュルリラ・チュルリラ・ダッダッダ！&#x2F; Chururira Chururira Daddadda!</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1bs41197Th/">https://www.bilibili.com/video/BV1bs41197Th/</a> （结月缘）</li><li>参考：<a href="https://www.bilibili.com/video/BV1B44y1s7qL/">https://www.bilibili.com/video/BV1B44y1s7qL/</a> （ワンダーランズ×ショウタイム）</li></ul><h4 id="アンノウン・マザーグース-Unknown-Mother-Goose"><a href="#アンノウン・マザーグース-Unknown-Mother-Goose" class="headerlink" title="アンノウン・マザーグース &#x2F; Unknown Mother-Goose"></a>アンノウン・マザーグース &#x2F; Unknown Mother-Goose</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1hx411b7CZ/">https://www.bilibili.com/video/BV1hx411b7CZ/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1aG4y1C77W/">https://www.bilibili.com/video/BV1aG4y1C77W/</a> （异世界情绪）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Dx411t7XL/">https://www.bilibili.com/video/BV1Dx411t7XL/</a> （れい）</li></ul><h4 id="虎視眈々-虎视眈眈"><a href="#虎視眈々-虎视眈眈" class="headerlink" title="虎視眈々 &#x2F; 虎视眈眈"></a>虎視眈々 &#x2F; 虎视眈眈</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ns411o7PQ/">https://www.bilibili.com/video/BV1ns411o7PQ/</a> （ルカ, ミク, グミ, IA, リン）</li><li>参考：<a href="https://www.bilibili.com/video/BV1pd4y1f7rY/">https://www.bilibili.com/video/BV1pd4y1f7rY/</a> （明透）</li></ul><h4 id="強風オールバック-强风大背头"><a href="#強風オールバック-强风大背头" class="headerlink" title="強風オールバック &#x2F; 强风大背头"></a>強風オールバック &#x2F; 强风大背头</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1yL411X7dM/">https://www.bilibili.com/video/BV1yL411X7dM/</a> （歌愛ユキ）</li><li>参考：<a href="https://www.bilibili.com/video/BV1LL411B7RN/">https://www.bilibili.com/video/BV1LL411B7RN/</a> （里奈Rina）</li></ul><h4 id="ダーリン-Darling"><a href="#ダーリン-Darling" class="headerlink" title="ダーリン &#x2F; Darling"></a>ダーリン &#x2F; Darling</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV11P4y1z74f/">https://www.bilibili.com/video/BV11P4y1z74f/</a> （須田景凪）</li><li>参考：<a href="https://www.bilibili.com/video/BV1M24y1M7wk/">https://www.bilibili.com/video/BV1M24y1M7wk/</a> （LIZ）</li><li>升降：+6</li></ul><h4 id="ロウワー-Lower"><a href="#ロウワー-Lower" class="headerlink" title="ロウワー &#x2F; Lower"></a>ロウワー &#x2F; Lower</h4><ul><li>原唱：<a href="https://www.youtube.com/watch?v=3sEptl-psU0">https://www.youtube.com/watch?v=3sEptl-psU0</a> （FLOWER）</li><li>参考：<a href="https://www.bilibili.com/video/BV1cP4y1v7ML/">https://www.bilibili.com/video/BV1cP4y1v7ML/</a> （LIZ）</li><li>升降：-4</li></ul><h4 id="太陽系デスコ-太阳系迪斯科"><a href="#太陽系デスコ-太阳系迪斯科" class="headerlink" title="太陽系デスコ &#x2F; 太阳系迪斯科"></a>太陽系デスコ &#x2F; 太阳系迪斯科</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Fs411a7mr/">https://www.bilibili.com/video/BV1Fs411a7mr/</a> （初音）</li><li>升降：-4</li></ul><h4 id="銀河録-银河录"><a href="#銀河録-银河录" class="headerlink" title="銀河録 &#x2F; 银河录"></a>銀河録 &#x2F; 银河录</h4><ul><li>原唱：<a href="https://www.bilibili.com/list/ml1371645219/">https://www.bilibili.com/list/ml1371645219/</a> （花碳）</li></ul><h4 id="白い春-白春"><a href="#白い春-白春" class="headerlink" title="白い春 &#x2F; 白春"></a>白い春 &#x2F; 白春</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Df4y1X7yq/">https://www.bilibili.com/video/BV1Df4y1X7yq/</a> （flower）</li><li>参考：<a href="https://www.bilibili.com/video/BV1kN4y1T7KA/">https://www.bilibili.com/video/BV1kN4y1T7KA/</a> （异世界情绪）</li></ul><h4 id="浴槽とネオンテトラ-浴槽与霓虹灯鱼"><a href="#浴槽とネオンテトラ-浴槽与霓虹灯鱼" class="headerlink" title="浴槽とネオンテトラ &#x2F; 浴槽与霓虹灯鱼"></a>浴槽とネオンテトラ &#x2F; 浴槽与霓虹灯鱼</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV193411Y7ZE/">https://www.bilibili.com/video/BV193411Y7ZE/</a> （FLOWER）</li><li>参考：<a href="https://www.bilibili.com/video/BV1xf4y1V7jp/">https://www.bilibili.com/video/BV1xf4y1V7jp/</a> （熊子）</li></ul><h4 id="フォニイ-phony"><a href="#フォニイ-phony" class="headerlink" title="フォニイ &#x2F; phony"></a>フォニイ &#x2F; phony</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ih411e7gn/">https://www.bilibili.com/video/BV1ih411e7gn/</a> （可不）</li><li>参考：<a href="https://www.bilibili.com/video/BV1A24y1o7UT/">https://www.bilibili.com/video/BV1A24y1o7UT/</a> （HIMEHINA）</li><li>升降：-1</li></ul><h4 id="グッバイ宣言-再见宣言"><a href="#グッバイ宣言-再见宣言" class="headerlink" title="グッバイ宣言 &#x2F; 再见宣言"></a>グッバイ宣言 &#x2F; 再见宣言</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1194y197Re/">https://www.bilibili.com/video/BV1194y197Re/</a> （FLOWER）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Pb4y1k7PY/">https://www.bilibili.com/video/BV1Pb4y1k7PY/</a> （麻婆豆腐）</li><li>升降：-2</li></ul><h4 id="Airhead"><a href="#Airhead" class="headerlink" title="Airhead"></a>Airhead</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1cW411F7Em/">https://www.bilibili.com/video/BV1cW411F7Em/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1yp411o7Ku/">https://www.bilibili.com/video/BV1yp411o7Ku/</a> （れい）</li><li>升降：-6</li></ul><h4 id="Loveit"><a href="#Loveit" class="headerlink" title="Loveit?"></a>Loveit?</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1mg4y1M7Ee/">https://www.bilibili.com/video/BV1mg4y1M7Ee/</a> （LOLUET）</li></ul><h4 id="CH4NGE"><a href="#CH4NGE" class="headerlink" title="CH4NGE"></a>CH4NGE</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1YF411B7LL/%EF%BC%88%E5%8F%AF%E4%B8%8D%EF%BC%89">https://www.bilibili.com/video/BV1YF411B7LL/（可不）</a></li><li>参考：<a href="https://www.bilibili.com/video/BV1RV4y1y71q/%EF%BC%88HIMEHINA%EF%BC%89">https://www.bilibili.com/video/BV1RV4y1y71q/（HIMEHINA）</a></li><li>时间：-1</li></ul><h4 id="うっせぇわ-吵死了"><a href="#うっせぇわ-吵死了" class="headerlink" title="うっせぇわ &#x2F; 吵死了"></a>うっせぇわ &#x2F; 吵死了</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ih411b7La/">https://www.bilibili.com/video/BV1ih411b7La/</a> （Ado）</li><li>升降：+1</li></ul><h4 id="踊-舞"><a href="#踊-舞" class="headerlink" title="踊 &#x2F; 舞"></a>踊 &#x2F; 舞</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1z44y1X74y/">https://www.bilibili.com/video/BV1z44y1X74y/</a> （Ado）</li></ul><h4 id="唱-Show"><a href="#唱-Show" class="headerlink" title="唱 &#x2F; Show"></a>唱 &#x2F; Show</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV18N4y197aG/">https://www.bilibili.com/video/BV18N4y197aG/</a> （Ado）</li><li>参考：<a href="https://www.bilibili.com/video/BV1vc41197rr/">https://www.bilibili.com/video/BV1vc41197rr/</a> （HIMEHINA）</li></ul><h3 id="ピノキオピー"><a href="#ピノキオピー" class="headerlink" title="ピノキオピー"></a>ピノキオピー</h3><h4 id="神っぽいな-像神一样呢"><a href="#神っぽいな-像神一样呢" class="headerlink" title="神っぽいな &#x2F; 像神一样呢"></a>神っぽいな &#x2F; 像神一样呢</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1iP4y1Y7NE/">https://www.bilibili.com/video/BV1iP4y1Y7NE/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1zG4y1z7RZ/">https://www.bilibili.com/video/BV1zG4y1z7RZ/</a> （HIMEHINA）</li></ul><h4 id="転生林檎-转生苹果"><a href="#転生林檎-转生苹果" class="headerlink" title="転生林檎 &#x2F; 转生苹果"></a>転生林檎 &#x2F; 转生苹果</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1EY4y1V71F/">https://www.bilibili.com/video/BV1EY4y1V71F/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1z84y1Y7XD/">https://www.bilibili.com/video/BV1z84y1Y7XD/</a> （Roselia, ＋α）</li></ul><h4 id="魔法少女とチョコレゐト-魔法少女与巧克力"><a href="#魔法少女とチョコレゐト-魔法少女与巧克力" class="headerlink" title="魔法少女とチョコレゐト &#x2F; 魔法少女与巧克力"></a>魔法少女とチョコレゐト &#x2F; 魔法少女与巧克力</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV11Z4y1k7wC/">https://www.bilibili.com/video/BV11Z4y1k7wC/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV13V4y1x77w/">https://www.bilibili.com/video/BV13V4y1x77w/</a> （鹿乃, LON）</li></ul><h3 id="Kanaria"><a href="#Kanaria" class="headerlink" title="Kanaria"></a>Kanaria</h3><h4 id="百鬼祭"><a href="#百鬼祭" class="headerlink" title="百鬼祭"></a>百鬼祭</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Si421d783/">https://www.bilibili.com/video/BV1Si421d783/</a> （初音）</li><li>升降：-4 ~ -5</li></ul><h4 id="KING"><a href="#KING" class="headerlink" title="KING"></a>KING</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Ya4y1E7pk/">https://www.bilibili.com/video/BV1Ya4y1E7pk/</a> （GUMI）</li><li>参考：<a href="https://www.bilibili.com/video/BV1re411G7MW/">https://www.bilibili.com/video/BV1re411G7MW/</a> （LON）</li><li>升降：-1</li></ul><h4 id="QUEEN"><a href="#QUEEN" class="headerlink" title="QUEEN"></a>QUEEN</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ug411y7DX/">https://www.bilibili.com/video/BV1ug411y7DX/</a> （GUMI）</li><li>参考：<a href="https://www.bilibili.com/video/BV18D4y1r7jg/">https://www.bilibili.com/video/BV18D4y1r7jg/</a> （异世界情绪）</li><li>升降：-1</li></ul><h4 id="酔いどれ知らず-不知醉"><a href="#酔いどれ知らず-不知醉" class="headerlink" title="酔いどれ知らず &#x2F; 不知醉"></a>酔いどれ知らず &#x2F; 不知醉</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1oZ4y1C7Ta/">https://www.bilibili.com/video/BV1oZ4y1C7Ta/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1394y1x7f1/">https://www.bilibili.com/video/BV1394y1x7f1/</a> （HIMEHINA）</li></ul><h4 id="アイデンティティ-Identity"><a href="#アイデンティティ-Identity" class="headerlink" title="アイデンティティ &#x2F; Identity"></a>アイデンティティ &#x2F; Identity</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1nL41157aa/">https://www.bilibili.com/video/BV1nL41157aa/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1hY4y1p7q7/">https://www.bilibili.com/video/BV1hY4y1p7q7/</a> （异世界情绪）</li><li>升降：-1</li></ul><h4 id="ENVY-BABY"><a href="#ENVY-BABY" class="headerlink" title="ENVY BABY"></a>ENVY BABY</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Jf4y1z7hK/">https://www.bilibili.com/video/BV1Jf4y1z7hK/</a> （GUMI）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Wb4y197s8/">https://www.bilibili.com/video/BV1Wb4y197s8/</a> （绊爱）</li><li>升降：-1</li></ul><h3 id="DECO-27"><a href="#DECO-27" class="headerlink" title="DECO*27"></a>DECO*27</h3><h4 id="妄想感傷代償連盟"><a href="#妄想感傷代償連盟" class="headerlink" title="妄想感傷代償連盟"></a>妄想感傷代償連盟</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1gx411u76u/">https://www.bilibili.com/video/BV1gx411u76u/</a> （初音）</li></ul><h4 id="サラマンダー-沙拉曼达"><a href="#サラマンダー-沙拉曼达" class="headerlink" title="サラマンダー &#x2F; 沙拉曼达"></a>サラマンダー &#x2F; 沙拉曼达</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1qu411U7qv/">https://www.bilibili.com/video/BV1qu411U7qv/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1iS4y1S7Qj/">https://www.bilibili.com/video/BV1iS4y1S7Qj/</a> （東雲彰人, 東雲絵名）</li><li>升降：Pending (-2)</li></ul><h4 id="ヴァンパイア-吸血鬼"><a href="#ヴァンパイア-吸血鬼" class="headerlink" title="ヴァンパイア &#x2F; 吸血鬼"></a>ヴァンパイア &#x2F; 吸血鬼</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1by4y187EM/">https://www.bilibili.com/video/BV1by4y187EM/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV11e4y1276W/">https://www.bilibili.com/video/BV11e4y1276W/</a> （异世界情绪）</li><li>升降：-2</li></ul><h4 id="アニマル-Animal"><a href="#アニマル-Animal" class="headerlink" title="アニマル &#x2F; Animal"></a>アニマル &#x2F; Animal</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Ei4y1Z7uF/">https://www.bilibili.com/video/BV1Ei4y1Z7uF/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1f34y1i7GV/">https://www.bilibili.com/video/BV1f34y1i7GV/</a> （LIZ）</li><li>升降：-1</li></ul><h3 id="かいりきベア"><a href="#かいりきベア" class="headerlink" title="かいりきベア"></a>かいりきベア</h3><h4 id="天使"><a href="#天使" class="headerlink" title="天使"></a>天使</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1db411W7U1/">https://www.bilibili.com/video/BV1db411W7U1/</a> （鳴花ミコト）</li></ul><h4 id="Darling-Dance"><a href="#Darling-Dance" class="headerlink" title="Darling Dance"></a>Darling Dance</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Zi4y1M75s/">https://www.bilibili.com/video/BV1Zi4y1M75s/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1HT4y1r7cG/">https://www.bilibili.com/video/BV1HT4y1r7cG/</a> （Ado）</li></ul><h4 id="ベノム-猛毒"><a href="#ベノム-猛毒" class="headerlink" title="ベノム &#x2F; 猛毒"></a>ベノム &#x2F; 猛毒</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV17s41137mU/">https://www.bilibili.com/video/BV17s41137mU/</a> （FLOWER）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Qt4y117sb/">https://www.bilibili.com/video/BV1Qt4y117sb/</a> （Mega）</li></ul><h4 id="バグ-Bug"><a href="#バグ-Bug" class="headerlink" title="バグ &#x2F; Bug"></a>バグ &#x2F; Bug</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1n94y117jB/">https://www.bilibili.com/video/BV1n94y117jB/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1rY4y1g7qF/">https://www.bilibili.com/video/BV1rY4y1g7qF/</a> （25時、ナイトコードで。）</li><li>参考：<a href="https://www.bilibili.com/video/BV1bV411N7Ts/">https://www.bilibili.com/video/BV1bV411N7Ts/</a> （HIMEHINA）</li><li>升降：-1</li></ul><h3 id="柊キライ"><a href="#柊キライ" class="headerlink" title="柊キライ"></a>柊キライ</h3><h4 id="皱鳃鲨？"><a href="#皱鳃鲨？" class="headerlink" title="皱鳃鲨？"></a>皱鳃鲨？</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1VT4y1M7Ae/%EF%BC%88Ado%EF%BC%89">https://www.bilibili.com/video/BV1VT4y1M7Ae/（Ado）</a></li></ul><h4 id="ギャラリア-画廊"><a href="#ギャラリア-画廊" class="headerlink" title="ギャラリア &#x2F; 画廊"></a>ギャラリア &#x2F; 画廊</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1W44y1h7ib/">https://www.bilibili.com/video/BV1W44y1h7ib/</a> （FLOWER）</li><li>参考：<a href="https://www.bilibili.com/video/BV1fi4y127Rm/">https://www.bilibili.com/video/BV1fi4y127Rm/</a> （异世界情绪）</li><li>升降：-4</li></ul><h4 id="ボッカデラベリタ-真实之口"><a href="#ボッカデラベリタ-真实之口" class="headerlink" title="ボッカデラベリタ &#x2F; 真实之口"></a>ボッカデラベリタ &#x2F; 真实之口</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1m54y127fJ/">https://www.bilibili.com/video/BV1m54y127fJ/</a> （FLOWER）</li><li>参考：<a href="https://www.bilibili.com/video/BV1LM411N734/">https://www.bilibili.com/video/BV1LM411N734/</a> （HIMEHINA）</li><li>升降：-1</li></ul><h4 id="エバ-eva"><a href="#エバ-eva" class="headerlink" title="エバ &#x2F; eva"></a>エバ &#x2F; eva</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV19V41127ug/">https://www.bilibili.com/video/BV19V41127ug/</a> （FLOWER）</li><li>参考：<a href="https://www.bilibili.com/video/BV1RM4y1w74D/">https://www.bilibili.com/video/BV1RM4y1w74D/</a> （CIEL）</li><li>升降：-3</li></ul><h4 id="オートファジー-自我吞噬"><a href="#オートファジー-自我吞噬" class="headerlink" title="オートファジー &#x2F; 自我吞噬"></a>オートファジー &#x2F; 自我吞噬</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Vt4y1q7e3/">https://www.bilibili.com/video/BV1Vt4y1q7e3/</a> （FLOWER）</li><li>参考：<a href="https://www.bilibili.com/video/BV1SQ4y1B7Tp/">https://www.bilibili.com/video/BV1SQ4y1B7Tp/</a> （存流）</li><li>升降：Pending（-2）</li></ul><h3 id="syudou"><a href="#syudou" class="headerlink" title="syudou"></a>syudou</h3><h4 id="ジャックポットサッドガール-Jackpot-Sad-Girl"><a href="#ジャックポットサッドガール-Jackpot-Sad-Girl" class="headerlink" title="ジャックポットサッドガール &#x2F; Jackpot Sad Girl"></a>ジャックポットサッドガール &#x2F; Jackpot Sad Girl</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1gA411j7fr/">https://www.bilibili.com/video/BV1gA411j7fr/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Rh411z7Rc/">https://www.bilibili.com/video/BV1Rh411z7Rc/</a> （25時、ナイトコードで。）</li><li>升降：Pending (+4)</li></ul><h4 id="ビターチョコデコレーション-苦巧克力装饰"><a href="#ビターチョコデコレーション-苦巧克力装饰" class="headerlink" title="ビターチョコデコレーション &#x2F; 苦巧克力装饰"></a>ビターチョコデコレーション &#x2F; 苦巧克力装饰</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1m7411P7pL/">https://www.bilibili.com/video/BV1m7411P7pL/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1M3411X7jH/">https://www.bilibili.com/video/BV1M3411X7jH/</a> （25時、ナイトコードで。）</li><li>升降：-2</li></ul><h4 id="ギャンブル-赌局"><a href="#ギャンブル-赌局" class="headerlink" title="ギャンブル &#x2F; 赌局"></a>ギャンブル &#x2F; 赌局</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1By4y1K7og/">https://www.bilibili.com/video/BV1By4y1K7og/</a> （syudou）</li><li>升降：-2</li></ul><h4 id="キュートなカノジョ-可爱的女友"><a href="#キュートなカノジョ-可爱的女友" class="headerlink" title="キュートなカノジョ &#x2F; 可爱的女友"></a>キュートなカノジョ &#x2F; 可爱的女友</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1E5411N7nP/">https://www.bilibili.com/video/BV1E5411N7nP/</a> （可不）</li><li>参考：<a href="https://www.bilibili.com/video/BV1864y1y7hV/">https://www.bilibili.com/video/BV1864y1y7hV/</a> （鹿乃）</li><li>升降：-3</li></ul><h4 id="爆笑"><a href="#爆笑" class="headerlink" title="爆笑"></a>爆笑</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1rB4y1u7ub/">https://www.bilibili.com/video/BV1rB4y1u7ub/</a> （soydou）</li><li>升降：-2</li></ul><h3 id="MARETU"><a href="#MARETU" class="headerlink" title="MARETU"></a>MARETU</h3><h4 id="脳内革命ガール-脑内革命女孩"><a href="#脳内革命ガール-脑内革命女孩" class="headerlink" title="脳内革命ガール &#x2F; 脑内革命女孩"></a>脳内革命ガール &#x2F; 脑内革命女孩</h4><ul><li>原唱：<a href="https://www.youtube.com/watch?v=sjr-tPFADpM">https://www.youtube.com/watch?v=sjr-tPFADpM</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1v34y167XK/">https://www.bilibili.com/video/BV1v34y167XK/</a> （CIEL）</li></ul><h4 id="ナミダ-泪"><a href="#ナミダ-泪" class="headerlink" title="ナミダ &#x2F; 泪"></a>ナミダ &#x2F; 泪</h4><ul><li>原唱：<a href="https://www.youtube.com/watch?v=cDeJQZKEEQo">https://www.youtube.com/watch?v=cDeJQZKEEQo</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1gB4y1k7HL/">https://www.bilibili.com/video/BV1gB4y1k7HL/</a> （CIEL）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Zy4y1L735/">https://www.bilibili.com/video/BV1Zy4y1L735/</a> （Yuni）</li></ul><h3 id="ヰ世界情緒"><a href="#ヰ世界情緒" class="headerlink" title="ヰ世界情緒"></a>ヰ世界情緒</h3><h4 id="ハイドレンジア"><a href="#ハイドレンジア" class="headerlink" title="ハイドレンジア"></a>ハイドレンジア</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ov411B7Ed/">https://www.bilibili.com/video/BV1ov411B7Ed/</a> （异世界情绪）</li><li>升降：-1</li></ul><h4 id="いろはに咲きて"><a href="#いろはに咲きて" class="headerlink" title="いろはに咲きて"></a>いろはに咲きて</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1V54y1D7i4/">https://www.bilibili.com/video/BV1V54y1D7i4/</a> （异世界情绪）</li></ul><h4 id="とめどなき白情"><a href="#とめどなき白情" class="headerlink" title="とめどなき白情"></a>とめどなき白情</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Gz4y1o7wu/">https://www.bilibili.com/video/BV1Gz4y1o7wu/</a> （异世界情绪）</li></ul><h4 id="斯く美しき造花"><a href="#斯く美しき造花" class="headerlink" title="斯く美しき造花"></a>斯く美しき造花</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1hy4y1q72c/">https://www.bilibili.com/video/BV1hy4y1q72c/</a> （异世界情绪）</li></ul><h4 id="深渊"><a href="#深渊" class="headerlink" title="深渊"></a>深渊</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1no4y1k7Bs/">https://www.bilibili.com/video/BV1no4y1k7Bs/</a> （异世界情绪，花谱）</li></ul><h4 id="暮れなずむ約束"><a href="#暮れなずむ約束" class="headerlink" title="暮れなずむ約束"></a>暮れなずむ約束</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Pg411p7Zc/">https://www.bilibili.com/video/BV1Pg411p7Zc/</a> （异世界情绪）</li></ul><h3 id="カンザキイオリ"><a href="#カンザキイオリ" class="headerlink" title="カンザキイオリ"></a>カンザキイオリ</h3><h4 id="命に嫌われている-被生命所厌恶"><a href="#命に嫌われている-被生命所厌恶" class="headerlink" title="命に嫌われている &#x2F; 被生命所厌恶"></a>命に嫌われている &#x2F; 被生命所厌恶</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Hx411p7pH/">https://www.bilibili.com/video/BV1Hx411p7pH/</a> （初音）</li><li>参考：<a href="https://www.bilibili.com/video/BV1KN41187YQ/">https://www.bilibili.com/video/BV1KN41187YQ/</a> （黑柿子）</li><li>参考：<a href="https://www.bilibili.com/video/BV1pm4y1s7NY/">https://www.bilibili.com/video/BV1pm4y1s7NY/</a> （宵崎奏）</li><li>升降：-2</li></ul><h4 id="あの夏が飽和する-那个夏天已然饱和"><a href="#あの夏が飽和する-那个夏天已然饱和" class="headerlink" title="あの夏が飽和する &#x2F; 那个夏天已然饱和"></a>あの夏が飽和する &#x2F; 那个夏天已然饱和</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Ws411T7hx/">https://www.bilibili.com/video/BV1Ws411T7hx/</a> （鏡音レン，鏡音リン）</li><li>参考：<a href="https://www.bilibili.com/video/BV19J411D7co/">https://www.bilibili.com/video/BV19J411D7co/</a> （EMA）</li><li>参考：<a href="https://www.bilibili.com/video/BV1HS4y1v7Di/">https://www.bilibili.com/video/BV1HS4y1v7Di/</a> （黑柿子）</li><li>升降：-2</li></ul><h4 id="青い号哭-青色的号哭"><a href="#青い号哭-青色的号哭" class="headerlink" title="青い号哭 &#x2F; 青色的号哭"></a>青い号哭 &#x2F; 青色的号哭</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1X64y1i765/">https://www.bilibili.com/video/BV1X64y1i765/</a> （黑柿子）</li></ul><h4 id="偶像"><a href="#偶像" class="headerlink" title="偶像"></a>偶像</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1mr4y1z7ot/">https://www.bilibili.com/video/BV1mr4y1z7ot/</a> （黑柿子）</li></ul><h4 id="地獄に落ちる-坠入地狱"><a href="#地獄に落ちる-坠入地狱" class="headerlink" title="地獄に落ちる &#x2F; 坠入地狱"></a>地獄に落ちる &#x2F; 坠入地狱</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1PP4y1h7EG/">https://www.bilibili.com/video/BV1PP4y1h7EG/</a> （黑柿子）</li><li>原唱：<a href="https://www.bilibili.com/video/BV1XY411b7Zv/">https://www.bilibili.com/video/BV1XY411b7Zv/</a> （可不）</li><li>升降：-2</li></ul><h4 id="桜の子-樱之子"><a href="#桜の子-樱之子" class="headerlink" title="桜の子 &#x2F; 樱之子"></a>桜の子 &#x2F; 樱之子</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Tu411o7sm/">https://www.bilibili.com/video/BV1Tu411o7sm/</a> （黑柿子）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Gd4y1L7YJ/">https://www.bilibili.com/video/BV1Gd4y1L7YJ/</a> （异世界情绪, 花谱）</li></ul><h4 id="ダイヤモンド-钻石"><a href="#ダイヤモンド-钻石" class="headerlink" title="ダイヤモンド &#x2F; 钻石"></a>ダイヤモンド &#x2F; 钻石</h4><h4 id="吸血鬼"><a href="#吸血鬼" class="headerlink" title="吸血鬼"></a>吸血鬼</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Rf4y1M7vr/">https://www.bilibili.com/video/BV1Rf4y1M7vr/</a> （黑柿子）</li><li>升降：-2</li></ul><h3 id="米津玄师"><a href="#米津玄师" class="headerlink" title="米津玄师"></a>米津玄师</h3><h4 id="海の幽霊-海之幽灵"><a href="#海の幽霊-海之幽灵" class="headerlink" title="海の幽霊 &#x2F; 海之幽灵"></a>海の幽霊 &#x2F; 海之幽灵</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1X441167MX/">https://www.bilibili.com/video/BV1X441167MX/</a> （八爷）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Yi4y1R7b4/">https://www.bilibili.com/video/BV1Yi4y1R7b4/</a> （异世界情绪）</li><li>升降：+1</li></ul><h4 id="駄菓子屋商売-粗点心店生意"><a href="#駄菓子屋商売-粗点心店生意" class="headerlink" title="駄菓子屋商売 &#x2F; 粗点心店生意"></a>駄菓子屋商売 &#x2F; 粗点心店生意</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1S54y1H7dG/">https://www.bilibili.com/video/BV1S54y1H7dG/</a> （八爷）</li><li>升降：-2</li></ul><h4 id="マトリョシカ-俄罗斯套娃"><a href="#マトリョシカ-俄罗斯套娃" class="headerlink" title="マトリョシカ &#x2F; 俄罗斯套娃"></a>マトリョシカ &#x2F; 俄罗斯套娃</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Hh411t7uW/">https://www.bilibili.com/video/BV1Hh411t7uW/</a> （八爷）</li><li>参考：<a href="https://www.bilibili.com/video/BV153411d7Wm/">https://www.bilibili.com/video/BV153411d7Wm/</a> （异世界情绪）</li></ul><h3 id="ヨルシカ"><a href="#ヨルシカ" class="headerlink" title="ヨルシカ"></a>ヨルシカ</h3><h4 id="ただ君に晴れ"><a href="#ただ君に晴れ" class="headerlink" title="ただ君に晴れ"></a>ただ君に晴れ</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1dW41137on/">https://www.bilibili.com/video/BV1dW41137on/</a> （suis）</li></ul><h4 id="だから僕は音楽を辞めた"><a href="#だから僕は音楽を辞めた" class="headerlink" title="だから僕は音楽を辞めた"></a>だから僕は音楽を辞めた</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Qb411g7bY/">https://www.bilibili.com/video/BV1Qb411g7bY/</a> （suis）</li></ul><h4 id="八月、某、月明かり"><a href="#八月、某、月明かり" class="headerlink" title="八月、某、月明かり"></a>八月、某、月明かり</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1mP4y1q7MZ/">https://www.bilibili.com/video/BV1mP4y1q7MZ/</a> （suis）</li></ul><h4 id="思想犯"><a href="#思想犯" class="headerlink" title="思想犯"></a>思想犯</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Ap4y1Q7MD/">https://www.bilibili.com/video/BV1Ap4y1Q7MD/</a> （suis）</li><li>升降：+2</li></ul><h4 id="春泥棒"><a href="#春泥棒" class="headerlink" title="春泥棒"></a>春泥棒</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV17t4y1r7Jq/">https://www.bilibili.com/video/BV17t4y1r7Jq/</a> （suis）</li><li>升降：+2</li></ul><h3 id="ずっと真夜中でいいのに。"><a href="#ずっと真夜中でいいのに。" class="headerlink" title="ずっと真夜中でいいのに。"></a>ずっと真夜中でいいのに。</h3><h4 id="秒針を噛む"><a href="#秒針を噛む" class="headerlink" title="秒針を噛む"></a>秒針を噛む</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Es411L7Jn/">https://www.bilibili.com/video/BV1Es411L7Jn/</a> （ACAね）</li></ul><h4 id="サターン"><a href="#サターン" class="headerlink" title="サターン"></a>サターン</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1LU4y1Y793/">https://www.bilibili.com/video/BV1LU4y1Y793/</a> （ACAね）</li></ul><h4 id="勘冴えて悔しいわ"><a href="#勘冴えて悔しいわ" class="headerlink" title="勘冴えて悔しいわ"></a>勘冴えて悔しいわ</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1mh411S7fm/">https://www.bilibili.com/video/BV1mh411S7fm/</a> （ACAね）</li><li>升降：-1</li></ul><h4 id="お勉強しといてよ"><a href="#お勉強しといてよ" class="headerlink" title="お勉強しといてよ"></a>お勉強しといてよ</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1uf4y1U7wc/">https://www.bilibili.com/video/BV1uf4y1U7wc/</a> （ACAね）</li><li>升降：-2</li></ul><h4 id="ハゼ馳せる果てるまで"><a href="#ハゼ馳せる果てるまで" class="headerlink" title="ハゼ馳せる果てるまで"></a>ハゼ馳せる果てるまで</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Wm4y157iK/">https://www.bilibili.com/video/BV1Wm4y157iK/</a> （ACAね）</li></ul><h4 id="Dear-Mr「F」"><a href="#Dear-Mr「F」" class="headerlink" title="Dear Mr「F」"></a>Dear Mr「F」</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ch4y1P7bV/">https://www.bilibili.com/video/BV1ch4y1P7bV/</a> （ACAね）</li></ul><h4 id="MILABO"><a href="#MILABO" class="headerlink" title="MILABO"></a>MILABO</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1sD4y1S7pw/">https://www.bilibili.com/video/BV1sD4y1S7pw/</a> （ACAね）</li><li>升降：-1</li></ul><h4 id="正義"><a href="#正義" class="headerlink" title="正義"></a>正義</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1t4411v7ga/">https://www.bilibili.com/video/BV1t4411v7ga/</a> （ACAね）</li></ul><h4 id="Ham"><a href="#Ham" class="headerlink" title="Ham"></a>Ham</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Pi4y1g7Ub/">https://www.bilibili.com/video/BV1Pi4y1g7Ub/</a> （ACAね）</li><li>升降：-1</li></ul><h4 id="あいつら全員同窓会"><a href="#あいつら全員同窓会" class="headerlink" title="あいつら全員同窓会"></a>あいつら全員同窓会</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1oq4y1M7Y6/">https://www.bilibili.com/video/BV1oq4y1M7Y6/</a> （ACAね）</li></ul><h4 id="綺羅キラー"><a href="#綺羅キラー" class="headerlink" title="綺羅キラー"></a>綺羅キラー</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV18K411r7f4/">https://www.bilibili.com/video/BV18K411r7f4/</a> （ACAね）</li></ul><h3 id="JPOP"><a href="#JPOP" class="headerlink" title="JPOP"></a>JPOP</h3><h4 id="仆が死のうと思ったのは"><a href="#仆が死のうと思ったのは" class="headerlink" title="仆が死のうと思ったのは"></a>仆が死のうと思ったのは</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV164411c78H/">https://www.bilibili.com/video/BV164411c78H/</a> （中岛美嘉）</li></ul><h4 id="恐山ル・ヴォワール"><a href="#恐山ル・ヴォワール" class="headerlink" title="恐山ル・ヴォワール"></a>恐山ル・ヴォワール</h4><ul><li>参考：<a href="https://www.bilibili.com/video/BV1Bz4y1k7vu/">https://www.bilibili.com/video/BV1Bz4y1k7vu/</a> （漪月灵）</li></ul><h4 id="一夜之梦"><a href="#一夜之梦" class="headerlink" title="一夜之梦"></a>一夜之梦</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Ps411f77Y/">https://www.bilibili.com/video/BV1Ps411f77Y/</a> （3L）</li></ul><h4 id="命にふさわしい"><a href="#命にふさわしい" class="headerlink" title="命にふさわしい"></a>命にふさわしい</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1jV4y1H7ga/">https://www.bilibili.com/video/BV1jV4y1H7ga/</a> （秋田）</li><li>参考：<a href="https://www.bilibili.com/video/BV1j54y1n79U/">https://www.bilibili.com/video/BV1j54y1n79U/</a> （响重音）</li><li>升降：-1</li></ul><h4 id="Wherever-you-are"><a href="#Wherever-you-are" class="headerlink" title="Wherever you are"></a>Wherever you are</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1BB4y1U7Py/">https://www.bilibili.com/video/BV1BB4y1U7Py/</a> （ONE OK ROCK）</li><li>参考：<a href="https://www.bilibili.com/video/BV1ib411c7zy/">https://www.bilibili.com/video/BV1ib411c7zy/</a> （道明寺可可亚）</li><li>参考：<a href="https://www.bilibili.com/video/BV13s411c7qi/">https://www.bilibili.com/video/BV13s411c7qi/</a> （道明寺可可亚）</li><li>升降：+2</li></ul><h4 id="ドライフラワー"><a href="#ドライフラワー" class="headerlink" title="ドライフラワー"></a>ドライフラワー</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV13a411a72j/">https://www.bilibili.com/video/BV13a411a72j/</a> （优里）</li><li>参考：<a href="https://www.bilibili.com/video/BV1ki4y117D1/">https://www.bilibili.com/video/BV1ki4y117D1/</a> （小柔）</li><li>升降：+3</li></ul><h4 id="カルデラ"><a href="#カルデラ" class="headerlink" title="カルデラ"></a>カルデラ</h4><ul><li>参考：<a href="https://www.bilibili.com/video/BV1ED4y117Qf/">https://www.bilibili.com/video/BV1ED4y117Qf/</a> （桃几OvO）</li></ul><h4 id="inside-you"><a href="#inside-you" class="headerlink" title="inside you"></a>inside you</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1m24y1S769/">https://www.bilibili.com/video/BV1m24y1S769/</a></li><li>升降：+1</li></ul><h4 id="カタオモイ"><a href="#カタオモイ" class="headerlink" title="カタオモイ"></a>カタオモイ</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1hj411R76u/">https://www.bilibili.com/video/BV1hj411R76u/</a> （Aimer）</li></ul><h4 id="Daisy"><a href="#Daisy" class="headerlink" title="Daisy"></a>Daisy</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1hT4y1q7mQ/">https://www.bilibili.com/video/BV1hT4y1q7mQ/</a> （Aimer）</li></ul><h4 id="丸ノ内サディスティック"><a href="#丸ノ内サディスティック" class="headerlink" title="丸ノ内サディスティック"></a>丸ノ内サディスティック</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1V3411u7xx/">https://www.bilibili.com/video/BV1V3411u7xx/</a> （椎名林檎）</li></ul><h4 id="寄り酔い"><a href="#寄り酔い" class="headerlink" title="寄り酔い"></a>寄り酔い</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1yo4y1973T/">https://www.bilibili.com/video/BV1yo4y1973T/</a> （和ぬか）</li><li>参考：<a href="https://www.bilibili.com/video/BV14P411G7Gi/">https://www.bilibili.com/video/BV14P411G7Gi/</a> （EMA）</li><li>升降：-2</li></ul><h4 id="ネイティブダンサー-Native-Dancer"><a href="#ネイティブダンサー-Native-Dancer" class="headerlink" title="ネイティブダンサー &#x2F; Native Dancer"></a>ネイティブダンサー &#x2F; Native Dancer</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV123411k7wo/">https://www.bilibili.com/video/BV123411k7wo/</a> （sakanaction）</li><li>参考：<a href="https://www.bilibili.com/video/BV12m4y177YL/">https://www.bilibili.com/video/BV12m4y177YL/</a> （明透）</li><li>升降：-4</li></ul><h4 id="夜に駆ける"><a href="#夜に駆ける" class="headerlink" title="夜に駆ける"></a>夜に駆ける</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Ph411C7S5/">https://www.bilibili.com/video/BV1Ph411C7S5/</a> （ikura）</li></ul><h4 id="愛を伝えたいだとか"><a href="#愛を伝えたいだとか" class="headerlink" title="愛を伝えたいだとか"></a>愛を伝えたいだとか</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ay4y177kp/">https://www.bilibili.com/video/BV1ay4y177kp/</a> （あいみょん）</li><li>升降：+2</li></ul><h4 id="東京サマーセッション"><a href="#東京サマーセッション" class="headerlink" title="東京サマーセッション"></a>東京サマーセッション</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ps411Y7tW/">https://www.bilibili.com/video/BV1ps411Y7tW/</a> （鎖那, CHiCO）</li></ul><h4 id="世界は恋に落ちている"><a href="#世界は恋に落ちている" class="headerlink" title="世界は恋に落ちている"></a>世界は恋に落ちている</h4><ul><li>参考：<a href="https://www.bilibili.com/video/BV1dx41187d8/">https://www.bilibili.com/video/BV1dx41187d8/</a> （花碳）</li></ul><h4 id="フロントメモリー"><a href="#フロントメモリー" class="headerlink" title="フロントメモリー"></a>フロントメモリー</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1YX4y1V7Uo/">https://www.bilibili.com/video/BV1YX4y1V7Uo/</a> （小松菜奈）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Sz4y1T7eE/">https://www.bilibili.com/video/BV1Sz4y1T7eE/</a> （ACAね）</li></ul><h4 id="YELLOW"><a href="#YELLOW" class="headerlink" title="YELLOW"></a>YELLOW</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1YP4y1877f/">https://www.bilibili.com/video/BV1YP4y1877f/</a> （神山羊）</li></ul><h4 id="デスぺレート"><a href="#デスぺレート" class="headerlink" title="デスぺレート"></a>デスぺレート</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1RW4y1i7WK/">https://www.bilibili.com/video/BV1RW4y1i7WK/</a> （LOLUET）</li></ul><h4 id="第六感"><a href="#第六感" class="headerlink" title="第六感"></a>第六感</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1aV411z7DF/">https://www.bilibili.com/video/BV1aV411z7DF/</a> （Reol）</li><li>参考：<a href="https://www.bilibili.com/video/BV14j411M7uQ/">https://www.bilibili.com/video/BV14j411M7uQ/</a> （明透）</li></ul><h4 id="飛行艇"><a href="#飛行艇" class="headerlink" title="飛行艇"></a>飛行艇</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1C44y1p7wL/">https://www.bilibili.com/video/BV1C44y1p7wL/</a> （King Gnu）</li><li>升降：+2</li></ul><h3 id="AniSong"><a href="#AniSong" class="headerlink" title="AniSong"></a>AniSong</h3><h4 id="星座になれたら"><a href="#星座になれたら" class="headerlink" title="星座になれたら"></a>星座になれたら</h4><ul><li>升降：+1</li></ul><h4 id="忘れてやらない"><a href="#忘れてやらない" class="headerlink" title="忘れてやらない"></a>忘れてやらない</h4><ul><li>升降：+1</li></ul><h4 id="打上花火"><a href="#打上花火" class="headerlink" title="打上花火"></a>打上花火</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1F8411G7TJ/">https://www.bilibili.com/video/BV1F8411G7TJ/</a> （DAOKO, 米津玄师）</li></ul><h4 id="シュガーソングとビターステップ"><a href="#シュガーソングとビターステップ" class="headerlink" title="シュガーソングとビターステップ"></a>シュガーソングとビターステップ</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1f4411Q745/">https://www.bilibili.com/video/BV1f4411Q745/</a> （UNISON SQUARE GARDEN）</li></ul><h4 id="怪物"><a href="#怪物" class="headerlink" title="怪物"></a>怪物</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1bV411B7uK/">https://www.bilibili.com/video/BV1bV411B7uK/</a> （ikura）</li><li>升降：-1</li></ul><h4 id="ないない"><a href="#ないない" class="headerlink" title="ないない"></a>ないない</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1ZQ4y1y71J/">https://www.bilibili.com/video/BV1ZQ4y1y71J/</a> （ReoNa）</li></ul><h4 id="夜は眠れるかい"><a href="#夜は眠れるかい" class="headerlink" title="夜は眠れるかい?"></a>夜は眠れるかい?</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1CG4y1Y7AL/">https://www.bilibili.com/video/BV1CG4y1Y7AL/</a> （flumpool）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Mq4y1U7Tv/">https://www.bilibili.com/video/BV1Mq4y1U7Tv/</a> （幸祜）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Py4y1171g/">https://www.bilibili.com/video/BV1Py4y1171g/</a> （内德维德）</li><li>升降：-1</li></ul><h4 id="Again"><a href="#Again" class="headerlink" title="Again"></a>Again</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1yV4y167gk/">https://www.bilibili.com/video/BV1yV4y167gk/</a> （Yui）</li><li>参考：<a href="https://www.bilibili.com/video/BV1Th4y1t7FG/">https://www.bilibili.com/video/BV1Th4y1t7FG/</a> （雾氧Uo）</li></ul><h4 id="unravel"><a href="#unravel" class="headerlink" title="unravel"></a>unravel</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1rb411m7gE/">https://www.bilibili.com/video/BV1rb411m7gE/</a> （TK）</li></ul><h4 id="カワキヲアメク"><a href="#カワキヲアメク" class="headerlink" title="カワキヲアメク"></a>カワキヲアメク</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1gJ411H7jq/">https://www.bilibili.com/video/BV1gJ411H7jq/</a> （美波）</li></ul><h2 id="英文"><a href="#英文" class="headerlink" title="英文"></a>英文</h2><h3 id="Guns-N’-Roses"><a href="#Guns-N’-Roses" class="headerlink" title="Guns N’ Roses"></a>Guns N’ Roses</h3><h4 id="Don’t-Cry"><a href="#Don’t-Cry" class="headerlink" title="Don’t Cry"></a>Don’t Cry</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1G24y137Re/">https://www.bilibili.com/video/BV1G24y137Re/</a> （axl，hoon）</li><li>参考：<a href="https://www.bilibili.com/video/BV13f4y1H7gB/">https://www.bilibili.com/video/BV13f4y1H7gB/</a> （axl）</li></ul><h3 id="Nirvana"><a href="#Nirvana" class="headerlink" title="Nirvana"></a>Nirvana</h3><h4 id="Smells-Like-Teen-Spirit"><a href="#Smells-Like-Teen-Spirit" class="headerlink" title="Smells Like Teen Spirit"></a>Smells Like Teen Spirit</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1rM4y1g7BE/">https://www.bilibili.com/video/BV1rM4y1g7BE/</a> （Kurt）</li><li>升降：-6</li></ul><h4 id="Lithium"><a href="#Lithium" class="headerlink" title="Lithium"></a>Lithium</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1uP4y1s7VH/">https://www.bilibili.com/video/BV1uP4y1s7VH/</a> （Kurt）</li></ul><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><h4 id="Never-Enough"><a href="#Never-Enough" class="headerlink" title="Never Enough"></a>Never Enough</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1sP411p7Hm/">https://www.bilibili.com/video/BV1sP411p7Hm/</a> （Loren Allred）</li><li>参考：<a href="https://www.bilibili.com/video/BV1wZ4y197jA/">https://www.bilibili.com/video/BV1wZ4y197jA/</a> （黑泽诺亚NOIR）</li></ul><h4 id="Almost-Lover"><a href="#Almost-Lover" class="headerlink" title="Almost Lover"></a>Almost Lover</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1TZ4y1G7QC/">https://www.bilibili.com/video/BV1TZ4y1G7QC/</a> （A Fine Frenzy）</li><li>参考：<a href="https://www.bilibili.com/video/BV1hW4y1s7Gy/">https://www.bilibili.com/video/BV1hW4y1s7Gy/</a> （Sier）</li><li>升降：-4</li></ul><h4 id="Cure-For-Me"><a href="#Cure-For-Me" class="headerlink" title="Cure For Me"></a>Cure For Me</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1HU4y137jr/">https://www.bilibili.com/video/BV1HU4y137jr/</a> （小曦）</li></ul><h4 id="Cry-Baby"><a href="#Cry-Baby" class="headerlink" title="Cry Baby"></a>Cry Baby</h4><ul><li>原唱：Melanie Martinez</li></ul><h4 id="Wish-you-were-gay"><a href="#Wish-you-were-gay" class="headerlink" title="Wish you were gay"></a>Wish you were gay</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Pb411q7r9/">https://www.bilibili.com/video/BV1Pb411q7r9/</a> （Billie）</li><li>参考：<a href="https://www.bilibili.com/video/BV1oW4y1u7eQ/">https://www.bilibili.com/video/BV1oW4y1u7eQ/</a> （瑞娅Rhea）</li><li>升降：+2</li></ul><h4 id="You-and-I"><a href="#You-and-I" class="headerlink" title="You and I"></a>You and I</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1jt4y1z7LQ/">https://www.bilibili.com/video/BV1jt4y1z7LQ/</a> （Lady Gaga）</li><li>参考：<a href="https://www.bilibili.com/video/BV1We4y1u7Nq/">https://www.bilibili.com/video/BV1We4y1u7Nq/</a> （塞拉菲娜Serafina）</li></ul><h4 id="Bang-Bang"><a href="#Bang-Bang" class="headerlink" title="Bang Bang"></a>Bang Bang</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Lp411o7Kd/">https://www.bilibili.com/video/BV1Lp411o7Kd/</a> （Jessie J, Ariana Grande, Nicki Minaj）</li><li>参考：<a href="https://www.bilibili.com/video/BV1YZ4y1U79X/">https://www.bilibili.com/video/BV1YZ4y1U79X/</a> （塔克tako）</li></ul><h4 id="I-Wanna-Be-Your-Slave"><a href="#I-Wanna-Be-Your-Slave" class="headerlink" title="I Wanna Be Your Slave"></a>I Wanna Be Your Slave</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1nm4y1S7qF/">https://www.bilibili.com/video/BV1nm4y1S7qF/</a> （Måneskin）</li><li>参考：<a href="https://www.bilibili.com/video/BV17L411T7My/">https://www.bilibili.com/video/BV17L411T7My/</a> （塔克Tako）</li></ul><h4 id="Runaway-Baby"><a href="#Runaway-Baby" class="headerlink" title="Runaway Baby"></a>Runaway Baby</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV14v411k7dK/">https://www.bilibili.com/video/BV14v411k7dK/</a> （火星哥）</li><li>参考：<a href="https://www.bilibili.com/video/BV1dQ4y127dR/">https://www.bilibili.com/video/BV1dQ4y127dR/</a> （塔克Tako）</li></ul><h4 id="dramatic"><a href="#dramatic" class="headerlink" title="dramatic"></a>dramatic</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1vr4y1h71s/">https://www.bilibili.com/video/BV1vr4y1h71s/</a> （Cat &amp; Calmell）</li><li>参考：<a href="https://www.bilibili.com/video/BV1uT411o7iU/">https://www.bilibili.com/video/BV1uT411o7iU/</a> （塔克Tako）</li></ul><h4 id="River"><a href="#River" class="headerlink" title="River"></a>River</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV15x411S76P/">https://www.bilibili.com/video/BV15x411S76P/</a> （Bishop Briggs）</li><li>参考：<a href="https://www.bilibili.com/video/BV1zT411W7AS/">https://www.bilibili.com/video/BV1zT411W7AS/</a> （黑泽诺亚NOIR）</li><li>参考：<a href="https://www.bilibili.com/video/BV16L411L7am/">https://www.bilibili.com/video/BV16L411L7am/</a> （塔克Tako）</li></ul><h4 id="Believer"><a href="#Believer" class="headerlink" title="Believer"></a>Believer</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1b7411f7ay/">https://www.bilibili.com/video/BV1b7411f7ay/</a> （Imagine Dragons）</li><li>参考：<a href="https://www.bilibili.com/video/BV1zT411z7kt/">https://www.bilibili.com/video/BV1zT411z7kt/</a> （黑泽诺亚NOIR）</li></ul><h2 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h2><h3 id="阿刁"><a href="#阿刁" class="headerlink" title="阿刁"></a>阿刁</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV147411x7TL/">https://www.bilibili.com/video/BV147411x7TL/</a> （张韶涵）</li><li>参考：<a href="https://www.bilibili.com/video/BV1A341147uK/">https://www.bilibili.com/video/BV1A341147uK/</a> （Fever无糖）</li></ul><h3 id="赤伶"><a href="#赤伶" class="headerlink" title="赤伶"></a>赤伶</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Bp4y1a7ce/">https://www.bilibili.com/video/BV1Bp4y1a7ce/</a> （HITA）</li><li>参考：<a href="https://www.bilibili.com/video/BV1gL4y1Y7oq/">https://www.bilibili.com/video/BV1gL4y1Y7oq/</a> （艾因Eine）</li></ul><h3 id="乌兰巴托的夜"><a href="#乌兰巴托的夜" class="headerlink" title="乌兰巴托的夜"></a>乌兰巴托的夜</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV12W411e7G7/">https://www.bilibili.com/video/BV12W411e7G7/</a> （谭维维）</li><li>参考：<a href="https://www.bilibili.com/video/BV1gA411p7Kv/">https://www.bilibili.com/video/BV1gA411p7Kv/</a> （阿梓）</li></ul><h3 id="母系社会"><a href="#母系社会" class="headerlink" title="母系社会"></a>母系社会</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1YE411t7Zu/">https://www.bilibili.com/video/BV1YE411t7Zu/</a> （张惠妹）</li><li>参考：<a href="https://www.bilibili.com/video/BV1og411k7gJ/">https://www.bilibili.com/video/BV1og411k7gJ/</a> （塔克Tako）</li></ul><h3 id="目不转睛"><a href="#目不转睛" class="headerlink" title="目不转睛"></a>目不转睛</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1is411V7dj/">https://www.bilibili.com/video/BV1is411V7dj/</a> （王以太）</li><li>参考：<a href="https://www.bilibili.com/video/BV1bv411576n/">https://www.bilibili.com/video/BV1bv411576n/</a> （内德维德）</li></ul><h3 id="傲娇"><a href="#傲娇" class="headerlink" title="傲娇"></a>傲娇</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1tW411v75S/">https://www.bilibili.com/video/BV1tW411v75S/</a> （張惠妹）</li><li>参考：<a href="https://www.bilibili.com/video/BV1MK411B73F/">https://www.bilibili.com/video/BV1MK411B73F/</a> （薇Steria）</li></ul><h3 id="情人流浪记"><a href="#情人流浪记" class="headerlink" title="情人流浪记"></a>情人流浪记</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1LW411779V/">https://www.bilibili.com/video/BV1LW411779V/</a> （张韶涵）</li><li>参考：<a href="https://www.bilibili.com/video/BV1V44y1Z7xa/">https://www.bilibili.com/video/BV1V44y1Z7xa/</a> （Pomelo安妮）</li></ul><h3 id="绝世舞姬"><a href="#绝世舞姬" class="headerlink" title="绝世舞姬"></a>绝世舞姬</h3><ul><li>参考：<a href="https://www.bilibili.com/video/BV1WX4y1P72y/">https://www.bilibili.com/video/BV1WX4y1P72y/</a> （阿梓）</li></ul><h3 id="Simon"><a href="#Simon" class="headerlink" title="Simon"></a>Simon</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1BT411T7hs/">https://www.bilibili.com/video/BV1BT411T7hs/</a> （周菲戈）</li><li>参考：<a href="https://www.bilibili.com/video/BV1gM411F78E/">https://www.bilibili.com/video/BV1gM411F78E/</a> （Pomelo安妮）</li><li>参考：<a href="https://www.bilibili.com/video/BV1kN411w7z8/">https://www.bilibili.com/video/BV1kN411w7z8/</a> （妮莉安Lily）</li><li>升降：+5</li></ul><h3 id="肆意的河"><a href="#肆意的河" class="headerlink" title="肆意的河"></a>肆意的河</h3><ul><li>参考：<a href="https://www.bilibili.com/video/BV13d4y1z72k/">https://www.bilibili.com/video/BV13d4y1z72k/</a> （Pomelo安妮）</li><li>升降：+5</li></ul><h3 id="引路的风筝"><a href="#引路的风筝" class="headerlink" title="引路的风筝"></a>引路的风筝</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Vu411v79N/">https://www.bilibili.com/video/BV1Vu411v79N/</a> （张韶涵）</li><li>参考：<a href="https://www.bilibili.com/video/BV18L4y1w7q8/">https://www.bilibili.com/video/BV18L4y1w7q8/</a> （桃几OvO）</li></ul><h3 id="精卫"><a href="#精卫" class="headerlink" title="精卫"></a>精卫</h3><ul><li>原唱：<a href="https://www.bilibili.com/video/BV17y4y197dV/">https://www.bilibili.com/video/BV17y4y197dV/</a> （30年前，50年后）</li><li>参考：<a href="https://www.bilibili.com/video/BV1fg4y1T7qu/">https://www.bilibili.com/video/BV1fg4y1T7qu/</a> （露米Lumi）</li><li>升降：+2</li></ul><h3 id="胡桃夹子"><a href="#胡桃夹子" class="headerlink" title="胡桃夹子"></a>胡桃夹子</h3><ul><li>参考：<a href="https://www.bilibili.com/video/BV1Kg411p7Wy/">https://www.bilibili.com/video/BV1Kg411p7Wy/</a> （里奈Rina）</li></ul><h3 id="我管你"><a href="#我管你" class="headerlink" title="我管你"></a>我管你</h3><ul><li>参考：<a href="https://www.bilibili.com/video/BV1d94y117aZ/">https://www.bilibili.com/video/BV1d94y117aZ/</a> （内德维德）</li><li>升降：-6</li></ul><h4 id="归零"><a href="#归零" class="headerlink" title="归零"></a>归零</h4><ul><li>原唱：<a href="https://www.bilibili.com/video/BV1Z34y1H7dL">https://www.bilibili.com/video/BV1Z34y1H7dL</a> （林忆莲）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Assimp</title>
    <link href="/2023/03/06/Assimp/"/>
    <url>/2023/03/06/Assimp/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p><a href="https://github.com/assimp/assimp">Github</a><br>一个非常流行的模型导入库 Assimp(Open Asset Import Library)。它能够导入很多种不同的模型文件格式（也能导出一些），并在内存中呈现为 Assimp 的通用数据结构。一旦 Assimp 加载了模型，我们就可以通过 Assimp 提供的接口检索需要的数据。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>Assimp 官方比较推荐 vcpkg 的集成方式。<br>手动集成的话有三个坑：</p><ol><li>config.h<br>假设生成目录是 <code>assimp/build</code>，Assimp 会在 <code>assimp/build/include/assimp</code> 下生成一份 <code>config.h</code>，这个文件最终会被 include 进源码里。<br>所以在我们的项目中不但要包含 <code>assimp/include</code> 路径，还要包含 <code>assimp/build/include/assimp</code> 路径。</li><li>zlib<br>Assimp 依赖于 zlib 运行，所以在我们的项目中不但要链接 <code>assimp-vc143-mt</code> 库还要包含 <code>zlibstatic</code> 库，这个项目生成在 <code>assimp/build/contrib/zlib</code> 下，目标文件生成在 <code>assimp/build/contrib/zlib/Debug(or Release)</code> 下。</li><li>stb<br>Assimp 默认包含一份 stb_image 的定义，如果你的项目中需要手动包含 stb_image，其中一份实现会被忽略。<br>Assimp 默认会 define <code>STBI_ONLY_PNG</code>，导致 stb_image 只能读取 .png 格式。<br>这块的逻辑可以看下 <a href="https://github.com/assimp/assimp/blob/497e286cfa0fd7d055f867aa5aff43e089d7a849/code/Common/Assimp.cpp">Assimp.cpp</a> 最后几行。<br>解决办法是在 make Assimp 的时候使用 <code>-DASSIMP_NO_EXPORT=ON</code>。</li></ol><p>官方文档 <a href="https://github.com/assimp/assimp/blob/master/Build.md">assimp&#x2F;Build.md</a> 似乎没有提及这几件事，很坑。</p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>调用 <code>Assimp::Importer</code> 之后 Assimp 解析的模型数据会以一个只读的 <code>aiScene *</code> 的形式返回，并且当 Importer 实例销毁之后对应的 aiScene 也会销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assimp/Importer.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assimp/scene.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assimp/postprocess.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Import</span><span class="hljs-params">( <span class="hljs-type">const</span> std::string &amp;filePath)</span> </span>&#123;<br>    Assimp::Importer importer;<br><br>    <span class="hljs-type">const</span> aiScene *pScene = importer.<span class="hljs-built_in">ReadFile</span>( filePath,<br>        aiProcess_AAA | aiProcess_BBB);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == pScene) &#123;<br>        <span class="hljs-comment">// Import failed.</span><br>    &#125;<br><br>    <span class="hljs-built_in">ProcessScene</span>(pScene);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReadFile</code> 的 aiProcess_XXX 是一个比较重要的参数，是 Assimp 提供的对模型的后处理，比如 <code>aiProcess_GenNormals</code> 代表如果模型不包含法向量的话由 Assimp 生成法向量。更多的选项看：<a href="https://assimp.sourceforge.net/lib_html/postprocess_8h.html">postprocess.h File Reference</a>。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>默认：</p><ul><li>右手坐标系</li><li>CCW</li><li>UV 原点位于左下角</li></ul><p>矩阵有一点奇怪，<strong>左乘</strong>并且以<strong>行主序</strong>存储，例如：<br>$$<br>\left(<br>\begin{matrix}<br>X1 &amp; Y1 &amp; Z1 &amp; T1 \<br>X2 &amp; Y2 &amp; Z2 &amp; T2 \<br>X3 &amp; Y3 &amp; Z3 &amp; T3 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{matrix}<br>\right)<br>$$<br>在内存中的排列是：<code>[X1, Y1, Z1, T1, X2, Y2, Z2, T2, X3, Y3, Z3, T3, 0, 0, 0, 1]</code>。</p><p>以上规范大都可以通过 Post Process 进行修改。<br>比如 <code>aiProcess_ConvertToLeftHanded</code> 代表：</p><blockquote><p>Supersedes the <code>aiProcess_MakeLeftHanded</code> and <code>aiProcess_FlipUVs</code> and <code>aiProcess_FlipWindingOrder</code> flags. The output data matches Direct3D’s conventions: left-handed geometry, upper-left origin for UV coordinates and finally clockwise face order, suitable for CCW culling.</p></blockquote><h2 id="aiScene"><a href="#aiScene" class="headerlink" title="aiScene"></a>aiScene</h2><p>先看一个简化版的数据结构：<br><img src="/img/Assimp/aiScene.png" alt="LearnOpenGL"></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>首先整个场景是以 node 的形式层级组织起来的，意义在于对某一节点进行任意形式的变换时，我们会希望对该节点的所有子节点应用相同的变换。比如一个挖掘机的大臂（动臂）挥动时连接着的小臂（斗杆）会自然地发生相同的变换。<br>那么 node 中存储的便是：</p><ul><li>子 node 的索引</li><li>相对于父 node 的变换矩阵</li><li>对应 mesh 的索引</li></ul><p>当然 Assimp 也提供了后处理 <code>aiProcess_PreTransformVertices</code> 来移除层级结构并将所有变换矩阵直接应用的到顶点坐标上，不过这个选项同时会移除动画数据。</p><p>按照 node 递归读取 scene 的伪代码大致是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessNode</span><span class="hljs-params">(aiNode node, SceneObject parent, Mat4 transform)</span> </span>&#123;<br>    SceneObject nextParent;<br>    Mat4 nextTransform;<br><br>    <span class="hljs-keyword">if</span>(node.mNumMeshes &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// If node has meshes, create a new scene object for it.</span><br>        SceneObjekt newObject = <span class="hljs-keyword">new</span> SceneObject;<br>        parent.<span class="hljs-built_in">addChild</span>(newObject);<br>        <span class="hljs-built_in">ProcessMesh</span>(node, newObject);<br><br>        <span class="hljs-comment">// The new object is the parent for all child nodes.</span><br>        nextParent = newObject;<br>        nextTransform.<span class="hljs-built_in">SetUnity</span>();<br>    &#125; <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// If no meshes, skip the node, but keep its transformation.</span><br>        nextParent = parent;<br>        nextTransform = node.mTransform * transform;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(all of node.mChildren) &#123;<br>        <span class="hljs-comment">// Continue for all child nodes.</span><br>        <span class="hljs-built_in">ProcessNode</span>(node.mChildren[i], nextParent, nextTransform);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3><p>可以发现 mesh 并不是存储于 node 中的，node 只持有一个对于 mesh 的引用，而所有 mesh 都平铺在 <code>aiScene</code> 中。同理 mesh 也持有一个 material 的引用，要拿着该索引回到 <code>aiScene</code> 才能拿到对应的材质。<br>这样一来 node 可以复用 mesh，mesh 可以复用 material。有一点绕，但就像 index 复用 vertex 一样合理。<br>不同在于一个 node 可以持有多个 mesh，而一个 mesh 只能持有一个 material。<br>mesh 结构体的定义看：<a href="https://github.com/assimp/assimp/blob/master/include/assimp/mesh.h">mesh.h</a></p><h3 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h3><p>material 除了 <code>GetTexture</code> 接口可以拿到指定 <code>aiTextureType</code> 的贴图路径以外，还有 <code>Get</code> 接口可以拿到 Assimp 解析出来的材质定义。由于材质相关的定义与规范实属百花齐放，Assimp 也只提供了最简单的 MaterialProperty 的数据。<br>注意 <code>Get</code> 接口遵循十分严格的调用规范，并且需要由调用者保证正确的使用方式：<a href="https://assimp-docs.readthedocs.io/en/latest/usage/use_the_lib.html#constants">Material-System</a>。虽然约定俗成了不同 property 对应的数据类型，但好处是可以用简单的键值对获得十分复杂混乱的材质定义，也易于扩展，毕竟新增一个 MaterialProperty 也就是新增一对键值对的事。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/model.h">LearnOpenGL</a> 是一个相对完整的例子。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Assimp</tag>
      
      <tag>CPP</tag>
      
      <tag>Engineering</tag>
      
      <tag>Material</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大气散射</title>
    <link href="/2022/10/04/Atm/"/>
    <url>/2022/10/04/Atm/</url>
    
    <content type="html"><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>总览：<br><a href="https://www.bilibili.com/video/BV1i3411T7QL/">06.游戏中地形大气和云的渲染(下) | GAMES104-现代游戏引擎：从入门到实践</a><br>一个简短的公式推导：<br><a href="https://zhuanlan.zhihu.com/p/36498679">[Rendering] 基于物理的大气渲染</a><br>一个详细的推导和最暴力且直观的实现：<br><a href="https://zhuanlan.zhihu.com/p/237502022">【实战】从零实现一套完整单次大气散射</a><br>$I&#x3D;I_S\beta(\lambda)\gamma(\theta)\sum_{P\in\overline{AB}}T(\overline{CP})T(\overline{PA})\rho(h)ds$<br>$T(\overline{CP})T(\overline{PA})&#x3D;exp\lbrace-\beta(\lambda)(D(\overline{CP})+D(\overline{PA}))\rbrace$<br>这篇文章也不错：<br><a href="https://zhuanlan.zhihu.com/p/559466624">基于物理的大气体渲染从理论到实践（一）</a><br>天空为什么白天是蓝的，黄昏是红的：<br><a href="https://zhuanlan.zhihu.com/p/210745877">更通俗易懂之天空为啥那么蓝——瑞利散射</a><br>一个有趣的实验：<br><a href="https://www.bilibili.com/video/BV1Te411A76j/">麻省理工教授：答应我，如果不是为瑞利散射，永远不要同时抽四根烟！！！</a><br>一篇详尽过头的文章，我的建议是当小说看：<br><a href="https://zhuanlan.zhihu.com/p/548799663">游戏魔法编程：unity 实现完整大气散射</a></p><h3 id="Accurate-Atmospheric-Scattering"><a href="#Accurate-Atmospheric-Scattering" class="headerlink" title="Accurate Atmospheric Scattering"></a>Accurate Atmospheric Scattering</h3><p>只考虑单次散射，预计算并拟合了任意两点间的光学距离：<br><a href="https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering">GPU Gems 2 Chapter 16. Accurate Atmospheric Scattering</a><br>这也是 Unity 的做法：<br><a href="https://zhuanlan.zhihu.com/p/448521659">在 Unity 中制作 Procedural Sky</a><br>解除了 Sean O’Neil 实现中标准海拔、大气高度和地球半径之间比例的限制。<br><a href="https://atomworld.wordpress.com/2014/12/22/flexible-physical-accurate-atmosphere-scattering-part-1/">Flexible Physical Accurate Atmosphere Scattering</a></p><h3 id="Precomputed-Atmospheric-Scattering"><a href="#Precomputed-Atmospheric-Scattering" class="headerlink" title="Precomputed Atmospheric Scattering"></a>Precomputed Atmospheric Scattering</h3><p>预计算了<strong>多重散射</strong>，考虑了相机在太空的情况，考虑了臭氧层对光线的吸收，考虑了太阳对着色点 Direct Irradiance 的贡献，考虑了大气对着色点 Indirect Irradiance 的贡献，考虑了看向着色点时视线光路上发生的散射，考虑了位于阴影中的大气部分产生的 LightShafts:<br><a href="https://ebruneton.github.io/precomputed_atmospheric_scattering/">Precomputed Atmospheric Scattering</a><br><a href="https://zhuanlan.zhihu.com/p/76844937">Precomputed Atmospheric Scattering</a><br><a href="https://zhuanlan.zhihu.com/p/380531599">Precomputed Atmosphere Scaterring</a><br><a href="https://zhuanlan.zhihu.com/p/410000571">【Unreal 从 0 到 1】【第四章：天气系统】4.2，从零开始的物理大气散射</a><br><a href="https://zhuanlan.zhihu.com/p/344296264">解读 GLSL 的大气散射函数学习笔记</a><br><a href="https://zhuanlan.zhihu.com/p/498287539">Precomputed Atmospheric Scattering Shader 代码笔记</a><br><a href="https://ebruneton.github.io/precomputed_atmospheric_scattering/atmosphere/reference/test_report.html">CPU 精确计算与 GPU 近似的对比</a><br><a href="https://ebruneton.github.io/precomputed_atmospheric_scattering/atmosphere/reference/model_test.cc.html">对不同近似的对比的描述</a> Test cases 部分</p><h4 id="如何在-win-VS2022-编译该工程"><a href="#如何在-win-VS2022-编译该工程" class="headerlink" title="如何在 win + VS2022 编译该工程"></a>如何在 win + VS2022 编译该工程</h4><p><a href="https://github.com/ebruneton/precomputed_atmospheric_scattering">ebruneton&#x2F;precomputed_atmospheric_scattering</a><br>文档中的 <code>make demo</code> 是 linux 的编译方式，windows 的编译方式藏在：<br> <code>precomputed_atmospheric_scattering/platform/windows/</code>。<br><code>download_build_run.bat</code> 会依次运行 <code>download_dependencies.bat</code>，<code>generate_project.bat</code>，<code>build.bat</code>，<code>run.bat</code>。中间如果出错会直接关闭命令提示符窗口，手动一个个试才能知道具体报错。<br><strong>generate_project.bat</strong><br>报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">CMake Error at CMakeLists.txt:<span class="hljs-number">78</span> (project):<br>Failed to run MSBuild command:<br>    MSBuild.exe<br>to get the value of VCTargetsPath:<br>-- Configuring incomplete, errors occurred!<br></code></pre></td></tr></table></figure><p>将 MSBuild.exe 加入环境变量即可，我的在 <code>C:\Program Files\Microsoft Visual Studio\2022\Community\Msbuild\Current\Bin</code>。<br>报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">无法找到 Visual Studio <span class="hljs-number">2017</span> 的生成工具(平台工具集 =“v141”)。若要使用 v141 生成工具进行生成，<br>请安装 Visual Studio <span class="hljs-number">2017</span> 生成工具。或者，可以升级到当前 Visual Studio 工具，方式是通过选择<br>“项目”菜单或右键单击该解决方案，然后选择“重定解决方案目标”。<br></code></pre></td></tr></table></figure><p>VisualStudio Installer，修改，单个组件，搜索 2017，勾选 <code>MSVC v141 - VS2017 C++ x64/x86 生成工具(v14.16)</code>。<br>报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">无法启动程序 /ALL_BUILD 拒绝访问<br></code></pre></td></tr></table></figure><p>右键项目设为启动项目。</p><h3 id="A-Scalable-and-Production-Ready-Sky-and-Atmosphere-Rendering-Technique"><a href="#A-Scalable-and-Production-Ready-Sky-and-Atmosphere-Rendering-Technique" class="headerlink" title="A Scalable and Production Ready Sky and Atmosphere Rendering Technique"></a>A Scalable and Production Ready Sky and Atmosphere Rendering Technique</h3><p>UE 的新做法，更少的预计算开销，更少的 LUT 存储开销，可实时更新的大气参数。<br><a href="https://sebh.github.io/publications/">A Scalable and Production Ready Sky and Atmosphere Rendering Technique</a> 2020 那两篇<br><a href="https://zhuanlan.zhihu.com/p/150963038">UE4 新版大气实时渲染-论文导读</a><br>功能演示视频：<br><a href="https://www.bilibili.com/video/BV1hv411z7c5/">[功能介绍]深度探索新天空大气系统 | Exploring the depths of the new Sky&amp;Atmosphere system</a></p><h3 id="大镖客中的天气"><a href="#大镖客中的天气" class="headerlink" title="大镖客中的天气"></a>大镖客中的天气</h3><p><a href="http://advances.realtimerendering.com/s2019/index.htm">Siggraph 2019</a> 最下面一篇<br><a href="https://zhuanlan.zhihu.com/p/91359071">[siggraph19]《荒野大镖客2》的大气云雾技术</a><br><a href="https://zhuanlan.zhihu.com/p/76273445">【SIGGRAPH2019】荒野大镖客 救赎 2 中的天气系统</a><br><a href="https://zhuanlan.zhihu.com/p/337895373">图形学研究：《荒野大镖客2》</a></p><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><p>关于渲染方程：<br><a href="http://mathinfo.univ-reims.fr/IMG/pdf/PreethamSig2003CourseNotes.pdf">Modeling Skylight and Aerial Perspective</a><br><a href="http://developer.amd.com/wordpress/media/2012/10/ATI-LightScattering.pdf">Rendering Outdoor Light Scattering in Real Time</a></p><p>关于几种新做法的系列文章：<br><a href="https://www.zhihu.com/column/c_1366713442364088320">大气散射相关</a></p><p>这篇是 Eric Bruneton 那篇的进一步改进：<br><a href="http://www.cescg.org/CESCG-2009/papers/PragueCUNI-Elek-Oskar09.pdf">Rendering Parametrizable Planetary Atmospheres with Multiple Scattering in Real-Time</a><br><a href="https://zhuanlan.zhihu.com/p/345916725">【译】【大气散射】[Elek09] 实时渲染参数化的、有多次散射的行星大气</a></p><p>寒霜引擎的实现，Oskar Elek 那篇进一步改进：<br><a href="https://sebh.github.io/publications/">Physically Based Sky, Atmosphere &amp; Cloud Rendering in Frostbite</a> 2016 那篇<br><a href="https://zhuanlan.zhihu.com/p/349472710">【译】【寒霜引擎】【大气渲染】基于物理的天空、大气和云的渲染（上）</a></p><p>英特尔的实现，包括完整的大气+地形+阴影+后处理。<br><a href="https://www.intel.com/content/dam/develop/external/us/en/documents/outdoor-light-scattering-update.pdf">Outdoor Light Scattering Update</a><br><a href="https://github.com/GameTechDev/OutdoorLightScattering">GameTechDev&#x2F;OutdoorLightScattering</a></p><p>纯拟合：<br><a href="https://cgg.mff.cuni.cz/projects/SkylightModelling/">An Analytic Model for Full Spectral Sky-Dome Radiance</a> 最后一篇</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Single-Scattering"><a href="#Single-Scattering" class="headerlink" title="Single Scattering"></a>Single Scattering</h3><p>$I&#x3D;I_S\beta(\lambda)\gamma(\theta)\sum_{P\in\overline{AB}}T(\overline{CP})T(\overline{PA})\rho(h)ds$<br>$T(\overline{CP})T(\overline{PA})&#x3D;exp\lbrace-\beta(\lambda)(D(\overline{CP})+D(\overline{PA}))\rbrace$<br>单个 Fragment Shader 即可实现，LightDir 和 CameraPos 由 uniform 传入，viewDir 由 skyBox 的坐标得到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs c">$input v_worldPos<br><br>uniform vec4 u_cameraPos[<span class="hljs-number">1</span>];<br>uniform vec4 u_LightDir[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// 单位：km</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _PlanetRadius 6371.0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _AtmosphereHeight 80.0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _DensityScaleHeight vec2(7.994, 1.2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _PlanetCenter vec3(0.0, -_PlanetRadius, 0.0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ExtinctionR vec3(0.0058, 0.0135, 0.0331)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ExtinctionM vec3(0.0200, 0.0200, 0.0200)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _MieG 0.98</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IncomingLight vec3(12.0, 12.0, 12.0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _PI 3.1415926</span><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">GetAltitude</span><span class="hljs-params">(vec3 position)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(length(position - _PlanetCenter) - _PlanetRadius);<br>&#125;<br><br><span class="hljs-comment">// 射线球面相交函数</span><br>vec2 <span class="hljs-title function_">RaySphereIntersection</span><span class="hljs-params">(vec3 rayOrigin, vec3 rayDir,</span><br><span class="hljs-params">    vec3 sphereCenter, <span class="hljs-type">float</span> sphereRadius)</span> &#123;<br>    rayOrigin -= sphereCenter;<br>    <span class="hljs-type">float</span> a = dot(rayDir, rayDir);<br>    <span class="hljs-type">float</span> b = <span class="hljs-number">2.0</span> * dot(rayOrigin, rayDir);<br>    <span class="hljs-type">float</span> c = dot(rayOrigin, rayOrigin) - (sphereRadius * sphereRadius);<br>    <span class="hljs-type">float</span> d = b * b - <span class="hljs-number">4.0</span> * a * c;<br>    <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0.0</span>) &#123;<br>    <span class="hljs-keyword">return</span> vec2(<span class="hljs-number">-1.0</span>, <span class="hljs-number">-1.0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    d = <span class="hljs-built_in">sqrt</span>(d);<br>    <span class="hljs-keyword">return</span> vec2(-b - d, -b + d) / (<span class="hljs-number">2.0</span> * a);<br>    &#125;<br>&#125;<br><br>vec2 <span class="hljs-title function_">RayEarthIntersection</span><span class="hljs-params">(vec3 rayOrigin, vec3 rayDir)</span> &#123;<br>    <span class="hljs-keyword">return</span> RaySphereIntersection(rayOrigin, rayDir, _PlanetCenter, _PlanetRadius);<br>&#125;<br><br>vec2 <span class="hljs-title function_">RayAtmosphereIntersection</span><span class="hljs-params">(vec3 rayOrigin, vec3 rayDir)</span> &#123;<br>    <span class="hljs-keyword">return</span> RaySphereIntersection(rayOrigin, rayDir, _PlanetCenter,  <br>        _PlanetRadius + _AtmosphereHeight);<br>&#125;<br><br><span class="hljs-comment">// 采样得到两点之间的光学深度。</span><br>vec2 <span class="hljs-title function_">DensitySampling</span><span class="hljs-params">(vec3 startPos, vec3 endPos)</span> &#123;<br>vec2 opticalDepth = vec2_splat(<span class="hljs-number">0.0</span>);<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> stepCount = <span class="hljs-number">16</span>;<br>vec3 step = (endPos - startPos) / stepCount;<br><span class="hljs-type">float</span> stepSize = length(step);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt;= stepCount; ++s) &#123;<br>vec3 position = startPos + step * s;<br><span class="hljs-type">float</span> height = GetAltitude(position);<br>vec2 localDensity = <span class="hljs-built_in">exp</span>(-vec2_splat(height) / _DensityScaleHeight.xy);<br><br><span class="hljs-comment">// 梯形法则</span><br><span class="hljs-type">float</span> weight = (s == <span class="hljs-number">0</span> || s == stepCount) ? <span class="hljs-number">0.5</span> : <span class="hljs-number">1.0</span>;<br>opticalDepth += localDensity * stepSize * weight;<br>&#125;<br><br><span class="hljs-keyword">return</span> opticalDepth;<br>&#125;<br><br><span class="hljs-comment">// 射线起点到射线与大气顶部交点之间的光学深度。</span><br>vec2 <span class="hljs-title function_">LightDensitySampleing</span><span class="hljs-params">(vec3 position, vec3 lightDir)</span> &#123;<br>    <span class="hljs-comment">// 在这里假设射线一定不与地表相交。</span><br>vec2 atmIntersection = RayAtmosphereIntersection(position, lightDir);<br>vec3 rayEnd = position + lightDir * atmIntersection.y;<br><span class="hljs-keyword">return</span> DensitySampling(position, rayEnd);<br>&#125;<br><br><span class="hljs-comment">// T(PC) * T(PA) * rho(h)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ComputeLocalInscattering</span><span class="hljs-params">(vec2 rho, vec2 densityCP, vec2 densityPA,</span><br><span class="hljs-params">    out vec3 localInscatterR, out vec3 localInscatterM)</span> &#123;<br>vec2 densityCPA = densityCP + densityPA;<br><br>vec3 Tr = densityCPA.x * _ExtinctionR;<br>vec3 Tm = densityCPA.y * _ExtinctionM;<br><br>vec3 extinction = <span class="hljs-built_in">exp</span>(-(Tr + Tm));<br><br>localInscatterR = extinction * rho.x;<br>localInscatterM = extinction * rho.y;<br>&#125;<br><br><span class="hljs-comment">// 相函数。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ApplyPhaseFunction</span><span class="hljs-params">(inout vec3 scatterR, inout vec3 scatterM, <span class="hljs-type">float</span> cosAngle)</span> &#123;<br><span class="hljs-type">float</span> cosAngle2  = cosAngle * cosAngle;<br><span class="hljs-type">float</span> g = _MieG;<br><span class="hljs-type">float</span> g2 = g * g;<br><br><span class="hljs-type">float</span> phase = (<span class="hljs-number">3.0</span> / (<span class="hljs-number">16.0</span> * _PI)) * (<span class="hljs-number">1.0</span> + cosAngle2);<br>scatterR *= phase;<br><br>phase = (<span class="hljs-number">1.0</span> / (<span class="hljs-number">4.0</span> * _PI)) *<br>        ((<span class="hljs-number">3.0</span> * (<span class="hljs-number">1.0</span> - g2)) / (<span class="hljs-number">2.0</span> * (<span class="hljs-number">2.0</span> + g2))) *<br>        ((<span class="hljs-number">1.0</span> + cosAngle2) / (<span class="hljs-built_in">pow</span>(<span class="hljs-built_in">abs</span>((<span class="hljs-number">1.0</span> + g2 - <span class="hljs-number">2.0</span> * g * cosAngle)), <span class="hljs-number">1.5</span>)));<br>scatterM *= phase;<br>&#125;<br><br>vec3 <span class="hljs-title function_">IntegrateInscattering</span><span class="hljs-params">(vec3 rayStart, vec3 rayDir, <span class="hljs-type">float</span> rayLength, vec3 lightDir)</span> &#123;<br><span class="hljs-comment">// 在循环中累加</span><br>vec3 scatterR  = vec3_splat(<span class="hljs-number">0.0</span>);<br>vec3 scatterM  = vec3_splat(<span class="hljs-number">0.0</span>);<br>vec2 densityPA = vec2_splat(<span class="hljs-number">0.0</span>);<br>vec2 densityCP = vec2_splat(<span class="hljs-number">0.0</span>);<br><br><span class="hljs-comment">// P - 当前发生散射的位置</span><br><span class="hljs-comment">// A - 相机位置</span><br><span class="hljs-comment">// C - 与大气顶部的交点</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> sampleCount = <span class="hljs-number">256</span>;<br>vec3 step = rayDir * (rayLength / sampleCount);<br><span class="hljs-type">float</span> stepSize = length(step);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt;= sampleCount; ++s) &#123;<br>vec3 samplePos = rayStart + step * s;<br><br>        <span class="hljs-comment">// 这里只考虑单次散射，所以如果一个采样点对太阳不可见</span><br>        <span class="hljs-comment">// 他不会收到任何 Radiance 自然也不会散射出任何 Radiance。</span><br>vec2 crtEarthIntersection = RayEarthIntersection(samplePos, lightDir);<br><span class="hljs-type">bool</span> vis = (crtEarthIntersection.x &gt; <span class="hljs-number">0.0</span> || crtEarthIntersection.y &gt; <span class="hljs-number">0.0</span>)<br>            ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span>(vis) &#123;<br>densityCP = LightDensitySampleing(samplePos, lightDir);<br><br>            <span class="hljs-comment">// DensityPA 可以在每一次采样点 P 步进的时候累加，这样可以省下 PA 之间的积分。</span><br><span class="hljs-type">float</span> height = GetAltitude(samplePos);<br>vec2 localDensityPA = <span class="hljs-built_in">exp</span>(-vec2_splat(height) / _DensityScaleHeight.xy);<br>densityPA += localDensityPA * stepSize;<br><br><span class="hljs-comment">// localDensityPA 便是 rho(h)。</span><br>vec3 localInscatterR;<br>vec3 localInscatterM;<br>ComputeLocalInscattering(localDensityPA, densityCP, densityPA,<br>            localInscatterR, localInscatterM);<br><br><span class="hljs-comment">// 梯形法则</span><br><span class="hljs-type">float</span> weight = (s == <span class="hljs-number">0</span> || s == sampleCount) ? <span class="hljs-number">0.5</span> : <span class="hljs-number">1.0</span>;<br>scatterR += localInscatterR * stepSize * weight;<br>scatterM += localInscatterM * stepSize * weight;<br>&#125;<br>&#125;<br>ApplyPhaseFunction(scatterR, scatterM, dot(rayDir, lightDir));<br><span class="hljs-keyword">return</span> (scatterR * _ExtinctionR + scatterM * _ExtinctionM) * _IncomingLight.xyz;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>vec3 rayStart = u_cameraPos[<span class="hljs-number">0</span>].xyz;<br>vec3 rayDir = normalize(v_worldPos.xyz);<br><br>    <span class="hljs-comment">// 当相机位于太空时，沿着视线方向将相机移动至大气顶部。</span><br>vec2 atmIntersection = RayAtmosphereIntersection(rayStart, rayDir);<br><span class="hljs-keyword">if</span>(atmIntersection.x &gt; <span class="hljs-number">0.0</span>) &#123;<br>rayStart +=  rayDir * atmIntersection.x;<br>atmIntersection = RayAtmosphereIntersection(rayStart, rayDir);<br>&#125;<br><span class="hljs-type">float</span> rayLength = atmIntersection.y;<br><br><span class="hljs-comment">// 如果射线与地表相交，更新射线的长度。</span><br>vec2 earthIntersection = RayEarthIntersection(rayStart, rayDir);<br><span class="hljs-keyword">if</span> (earthIntersection.x &gt; <span class="hljs-number">0.0</span> || earthIntersection.y &gt; <span class="hljs-number">0.0</span>) &#123;<br>rayLength = earthIntersection.x;<br>&#125;<br><br>vec3 lightDir = -normalize(u_LightDir[<span class="hljs-number">0</span>].xyz);<br>vec3 radiance = IntegrateInscattering(rayStart, rayDir, rayLength, lightDir);<br><br>gl_FragColor = vec4(radiance, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Accurate-Atmospheric-Scattering-1"><a href="#Accurate-Atmospheric-Scattering-1" class="headerlink" title="Accurate Atmospheric Scattering"></a>Accurate Atmospheric Scattering</h3><p><a href="https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering">GPU Gems 2 Chapter 16. Accurate Atmospheric Scattering</a><br>提出了预计算光学深度的做法，高度视线天顶角夹角作为参数得到一张二维的 LUT，代表了任意一点到大气顶部的光学深度。如果要计算 AB 两点之间的光学深度，假设射线 AB 与大气顶部的交点为 C，Density(AB) 即 Density(AC) - Density(BC)。如果射线 AB 指向地表，因为 Density(AB) &#x3D;&#x3D; Density(BA)，这时计算 BA 两点之间的光学深度即可。<br>然后作者又将该 LUT 进行了拟合，公式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GetDensityFit</span><span class="hljs-params">(<span class="hljs-type">float</span> height, <span class="hljs-type">float</span> cosine)</span> </span>&#123;<br>    <span class="hljs-type">float</span> heightTerm = <span class="hljs-built_in">exp</span>(<span class="hljs-number">-4.0</span> * height);<br>    <span class="hljs-type">float</span> c = <span class="hljs-number">1.0</span> - cosine;<br>    <span class="hljs-type">float</span> cosineTerm =<br>        <span class="hljs-number">0.25</span> * <span class="hljs-built_in">exp</span>(<span class="hljs-number">-0.00287</span> + c * (<span class="hljs-number">0.459</span> + c * (<span class="hljs-number">3.38</span> + c * (<span class="hljs-number">-6.8</span> + c * <span class="hljs-number">5.25</span>))));<br>    <span class="hljs-keyword">return</span> heightTerm * cosineTerm;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Precomputed-Atmospheric-Scattering-1"><a href="#Precomputed-Atmospheric-Scattering-1" class="headerlink" title="Precomputed Atmospheric Scattering"></a>Precomputed Atmospheric Scattering</h3><p>内容比较多，建议直接看 <a href="https://ebruneton.github.io/precomputed_atmospheric_scattering/">Precomputed Atmospheric Scattering</a>，这里只有一些笔记。<br>如果仅仅要实现大气散射，这篇文档包含了不少冗余的内容：</p><ol><li>额外提供了全光谱的渲染模式，而非只使用 RGB 对应的三种波长。</li><li>为防止不合理的类型转换，自定义了所有物理量，但是 glsl 没有静态类型检查，所以所有物理量实际上都是 <code>float</code> 或 <code>vec3</code>。</li><li>为验证各个 trick 的效果，额外提供了 CPU 版本的渲染模式，通过 <code>#include &quot;atmosphere/functions.glsl&quot;</code> 和一些宏定义，使得 CPU、GPU 共用同一份代码。</li></ol><p>所以 demo 和 reference 下的文件是基本不用看的。<br>还有一些：</p><ol><li>没有实际的 Shader 文件，所有 Shader 代码是在 model 类里用 string 拼出来的。</li><li>model 类的初始化包括了最重要的 <code>AtmosphereParameters</code> 结构体的初始化。<br><a href="https://github.com/roeas/PrecomputedAtmosphereTexture">roeas&#x2F;PrecomputedAtmosphereTexture</a> 是一个用来验证预计算贴图可行性的小工程，只计算了 Transmittance 并将其保存为图片，其中还包括了如何生成定义 <code>AtmosphereParameters</code> 对象的 GLSL 代码。</li><li>Sharer 里同一张 Texture 名有时代表的是最终存储的 LUT，有时代表的是临时的 delta LUT，具体要看 CUP 端绑的是哪张。为防止混淆我做了一点整理：</li></ol><h4 id="存储并使用的贴图"><a href="#存储并使用的贴图" class="headerlink" title="存储并使用的贴图"></a>存储并使用的贴图</h4><ol><li>transmittance_texture_</li><li>scattering_texture_</li><li>irradiance_texture_</li><li>optional_single_mie_scattering_texture_（可选项）</li></ol><h4 id="临时贴图"><a href="#临时贴图" class="headerlink" title="临时贴图"></a>临时贴图</h4><ol><li>delta_irradiance_texture</li><li>delta_rayleigh_scattering_texture（仅用于计算二阶散射）</li><li>delta_mie_scattering_texture（仅用于计算二阶散射）</li><li>delta_scattering_density_texture</li><li>delta_multiple_scattering_texture &#x3D; delta_rayleigh_scattering_texture（复用，仅用于计算三阶及以上的散射）</li></ol><h4 id="Transmittance"><a href="#Transmittance" class="headerlink" title="Transmittance"></a>Transmittance</h4><p><strong>输入</strong></p><ol><li>无</li></ol><p><strong>输出</strong></p><ol><li>transmittance_texture_</li></ol><h4 id="direct-Irradiance"><a href="#direct-Irradiance" class="headerlink" title="direct Irradiance"></a>direct Irradiance</h4><p><strong>输入</strong></p><ol><li>transmittance_texture_</li></ol><p><strong>输出</strong></p><ol><li>delta_irradiance_texture</li><li>irradiance_texture_ &#x3D; 0.0</li></ol><h4 id="single-Scattering"><a href="#single-Scattering" class="headerlink" title="single Scattering"></a>single Scattering</h4><p><strong>输入</strong></p><ol><li>transmittance_texture_</li></ol><p><strong>输出</strong></p><ol><li>delta_rayleigh_scattering_texture</li><li>delta_mie_scattering_texture</li><li>scattering_texture_ &#x3D; rayleigh.rgb + mie.r</li><li>optional_single_mie_scattering_texture_ &#x3D; mie（可选项）</li></ol><h4 id="Scattering-Density"><a href="#Scattering-Density" class="headerlink" title="Scattering Density"></a>Scattering Density</h4><p><strong>输入</strong></p><ol><li>transmittance_texture_</li><li>delta_rayleigh_scattering_texture</li><li>delta_mie_scattering_texture</li><li>delta_multiple_scattering_texture</li><li>delta_irradiance_texture</li></ol><p><strong>输出</strong></p><ol><li>delta_scattering_density_texture</li></ol><h4 id="indirect-Irradiance"><a href="#indirect-Irradiance" class="headerlink" title="indirect Irradiance"></a>indirect Irradiance</h4><p><strong>输入</strong></p><ol><li>delta_rayleigh_scattering_texture</li><li>delta_mie_scattering_texture</li><li>delta_multiple_scattering_texture</li></ol><p><strong>输出</strong></p><ol><li>delta_irradiance_texture</li><li>irradiance_texture_</li></ol><h4 id="multiple-Scattering"><a href="#multiple-Scattering" class="headerlink" title="multiple Scattering"></a>multiple Scattering</h4><p><strong>输入</strong></p><ol><li>transmittance_texture_</li><li>delta_scattering_density_texture</li></ol><p><strong>输出</strong></p><ol><li>delta_multiple_scattering_texture</li><li>scattering_texture_</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>AtmosphericScattering</tag>
      
      <tag>GlobalIllumination</tag>
      
      <tag>Math</tag>
      
      <tag>Rendering</tag>
      
      <tag>VolumeRendering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Archive】笔记 E 星计划</title>
    <link href="/2022/05/01/EStar/"/>
    <url>/2022/05/01/EStar/</url>
    
    <content type="html"><![CDATA[<h2 id="E-星计划"><a href="#E-星计划" class="headerlink" title="E 星计划"></a>E 星计划</h2><p><a href="https://game.academy.163.com/activity/talent?page=course">E 星计划</a><br><em>网易不知道什么时候关闭了这门公开课的浏览权限，笑死</em></p><h3 id="02-渲染流程简述"><a href="#02-渲染流程简述" class="headerlink" title="02 渲染流程简述"></a>02 渲染流程简述</h3><p>GPU Driven、Mesh Cluster Rendering、Cluster whith LOD（nanite）<br>Mesh Shader</p><h3 id="04-纹理综述"><a href="#04-纹理综述" class="headerlink" title="04 纹理综述"></a>04 纹理综述</h3><p>MRT（Multiple Render Targets）<br>Virtual Texture</p><h3 id="05-光照综述"><a href="#05-光照综述" class="headerlink" title="05 光照综述"></a>05 光照综述</h3><h4 id="直接光漫反射"><a href="#直接光漫反射" class="headerlink" title="直接光漫反射"></a>直接光漫反射</h4><ul><li>$\pi f_{dif}$ 的范围是 $[0, 1]$，那么 $f_{dif}$ 的范围是 $[0, \frac{1}{\pi}]$ 难以理解。不如使 $f_{dif}&#x3D;\frac{albedo}{\pi}$，这样一来 $albedo$ 的范围就是 $[0, 1]$ 了。</li><li>布林冯的 Diffuse Map 比较灵活，可以将一部分阴影和高光直接绘制在贴图上，但是 PBR 的 Albedo Map 只能绘制漫反射的贴图。albedo 要除以 $\pi$，看起来会比 diffuse 亮一点。</li></ul><p><a href="https://marmoset.co/posts/pbr-texture-conversion/">PBR Texture Conversion</a></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/EStar/5.1.png"></div><div class="group-image-wrap"><img src="/img/EStar/5.2.png"></div></div></div><h4 id="直接光高光"><a href="#直接光高光" class="headerlink" title="直接光高光"></a>直接光高光</h4><ul><li>非金属的 F0 普遍非常小且相差无几，在实际计算中可以用一个常量（比如 0.04）代替所有非金属的材质的 F0 属性。</li><li>菲涅尔项也会影响漫反射的强度 $F_d&#x3D;1-F-s$ 然后 $L_o(v)&#x3D;F_d\frac{albedo}{\pi}L_i(n\cdot l)$，但是实际上不一定必须这么做。</li><li>金属没有 Diffuse 反射，所以 $L_o(v)&#x3D;(1-metallic)F_d^*\frac{albedo}{\pi}L_i(n\cdot l)$ （这个 Fd 加不加都行）。</li></ul><p>Light Culling、Clustered Shading</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/EStar/5.3.png"></div><div class="group-image-wrap"><img src="/img/EStar/5.4.png"></div><div class="group-image-wrap"><img src="/img/EStar/5.5.png"></div></div></div><h4 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h4><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/EStar/5.6.png"></div><div class="group-image-wrap"><img src="/img/EStar/5.7.png"></div></div></div><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>游戏中的 HDR 与显示器的 HDR 不是一个概念，如果显示器启用了 HDR，游戏 Tone Mapping 的曲线需要调整。<br>split sum approximate</li></ul><p><img src="/img/EStar/5.8.png"></p><h3 id="06-性能优化综述"><a href="#06-性能优化综述" class="headerlink" title="06 性能优化综述"></a>06 性能优化综述</h3><p>视锥剔除、遮挡剔除（硬件遮挡查询、软件遮挡查询、与计算可见集）、Triangle Cluster Culling<br><strong>渲染合批</strong><br>每次渲染调用涉及大量渲染状态设置和切换，显卡驱动需要根据状态组装命令队列（编码成 GPU 能理解的微指令，塞到队列里），CPU 产生开销。<br><strong>骨骼动画压缩</strong><br>对原始数据进行去重抽帧，拆分变换矩阵（可以进一步抽帧），对移动和缩放矩阵做线性插值，对旋转矩阵做球面插值。<br>用四元数表示的旋转可以用半精度的 float16 存储。<br><strong>虚拟纹理</strong><br>极大降低 GPU 开销：物理贴图不需要每帧更新。<br>消耗大量显存。<br>Compute Shader 可以进行运行时纹理压缩（TEC2，显卡可以直接使用，不需要解压）<br>可以用公式拟合一些贴图（Matlab 曲面拟合）<br><strong>TBDR</strong><br>过去：一个个 tile 算，算完一整张 G-Buffer 后将其存入内存，算完所有 G-Buffer 后将他们传回 GPU 进行最终的着色计算。<br>现在：在一个 tile 内完成全部的 G-Buffer 与着色的计算，这一小块 G-Buffer 用完即丢，不会实际进入内存。<br>新的 API 才支持，省显存又省带宽。<br>缺点是这些丢弃的 G-Buffer 在之后的流程中（比如一些后处理）无法再被访问。</p><h3 id="07-全局光照技术综述"><a href="#07-全局光照技术综述" class="headerlink" title="07 全局光照技术综述"></a>07 全局光照技术综述</h3><p>LightMap<br>Point-Based Global Illumination<br><img src="/img/EStar/7.1.png"><br>Light Propagation Volumes<br><img src="/img/EStar/7.2.png"><br>SVO Cone Tracing</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/EStar/7.3.png"></div><div class="group-image-wrap"><img src="/img/EStar/7.4.png"></div></div></div><p>SVGF</p>]]></content>
    
    
    
    <tags>
      
      <tag>GlobalIllumination</tag>
      
      <tag>Rendering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记 C++ Primer</title>
    <link href="/2021/11/27/CppPrimer/"/>
    <url>/2021/11/27/CppPrimer/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2 初识输入输出"></a>1.2 初识输入输出</h2><p><code>#include &lt;iostream&gt;</code><br>使用了 iostream 库，包含了 istream 类和 ostream 类，分别表示输入流和输出流。</p><p><strong>向流写入数据</strong><br>输出运算符（&lt;&lt;）接受两个运算对象，左侧必须是一个 ostream 对象，右侧是要打印的值，然后返回其左侧的对象。<br><code>std::endl</code><br>这是一个被称为操作符的特殊值，写入 endl 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。调试时应保证一直刷新流，避免程序崩溃时输出还留在缓冲区中。<br><code>std::cerr</code><br>一个 ostream 对象，写到 cerr 的数据是不缓冲的。<br><code>std::clog</code><br>一个 ostream 对象，写到 clog 的数据是被缓冲的。</p><p><strong>从流读取数据</strong><br>输入运算符（&gt;&gt;）接受两个运算对象，左侧必须是一个 istream 对象，右侧是要接收值的对象，然后返回其左侧的对象。</p><h2 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4 控制流"></a>1.4 控制流</h2><h3 id="1-4-3-读取数量不定的输入数据"><a href="#1-4-3-读取数量不定的输入数据" class="headerlink" title="1.4.3 读取数量不定的输入数据"></a>1.4.3 读取数量不定的输入数据</h3><p><code>while(std::cin &gt;&gt; value)</code><br>当我们使用一个 istream 对象作为条件时，其效果是检测流的状态。当遇到文件结束符，或遇到无效输入时，istream 对象的状态会变为无效。</p><h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><h3 id="2-1-1-算术类型"><a href="#2-1-1-算术类型" class="headerlink" title="2.1.1 算术类型"></a>2.1.1 算术类型</h3><p><strong>带符号类型和无符号类型</strong><br>尽管字符型有三种<code>char</code>、<code>signed char</code>、<code>unsigned char</code>，字符的表现形式却只有两种：类型<code>char</code>实际上会表现为另两种的一种，具体是否带符号由编译器决定，所以使用字符型进行运算特别容易出问题。</p><h3 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h3><p>无符号超范围时取模，有符号超范围时结果未定义。</p><p><strong>含有无符号类型的表达式</strong><br>当一个表达式里既有带符号数又有无符号数时，带符号数会自动转换成无符号数时。这个过程相当于将一个带符号数直接赋给成无符号变量，那么当带符号数为负时就会出现异常的结果。</p><h3 id="2-1-3-字面值查常量"><a href="#2-1-3-字面值查常量" class="headerlink" title="2.1.3 字面值查常量"></a>2.1.3 字面值查常量</h3><p><strong>字符字面值和字串符字面值</strong><br>字符串字面值的类型实际上是由常量字符构成的数组。编译器在每个字符串的结尾处添加一个空字符(‘\0’)，因此，字符串字面值的实际长度要比它的内容多1。<br>如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一 个整体。</p><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><p><strong>默认初始化</strong><br>定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将不被初始化。string 类规定如果没有指定初值则生成一个空串。</p><h3 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h3><p>声明使得名字为程序所知。而定义负责创建与名字关联的实体。变量声明规定了变量的类型和名字。定义还申请存储空间，也可能会为变量赋一个初始值。</p><p><strong>extern</strong><br>如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显式地初始化变量。extern 语句如果包含初始值就不再是声明，而变成定义了。变量能且只能被定义一次，但是可以被多次声明。<br>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p><h2 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h2><h3 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h3><p>因为无法令引用重新绑定到另外一个对象，因此引用必须初始化为一个对象。因为引用本身不是一个对象，所以不能定义引用的引用。</p><h2 id="2-4-const-限定符"><a href="#2-4-const-限定符" class="headerlink" title="2.4 const 限定符"></a>2.4 const 限定符</h2><h3 id="2-4-1-const-的引用"><a href="#2-4-1-const-的引用" class="headerlink" title="2.4.1 const 的引用"></a>2.4.1 const 的引用</h3><p>所谓常量引用是对常量的引用，因为引用不是一个对象，所以不存在常量引用。在初始化常量引用时允许用任意表达式作为初始值，此时该引用会绑定到一个临时量对象（常量）上，而与原本等号右侧的表达式几乎不相关。</p><h3 id="2-4-2-指针和-const"><a href="#2-4-2-指针和-const" class="headerlink" title="2.4.2 指针和 const"></a>2.4.2 指针和 const</h3><p>允许一个指向常量的指针指向一个非常量对象，所谓的底层 const，不过是指针或引用自己认为自己指向了常量，然后自觉地不去改变所指对象的值。</p><h3 id="2-4-3-顶层-const"><a href="#2-4-3-顶层-const" class="headerlink" title="2.4.3 顶层 const"></a>2.4.3 顶层 const</h3><p>用于声明引用的 const 都是底层 const。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</p><h3 id="2-4-4-constexpr-表达式"><a href="#2-4-4-constexpr-表达式" class="headerlink" title="2.4.4 constexpr 表达式"></a>2.4.4 constexpr 表达式</h3><p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。显然字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。<br>将变量声明为 constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式。</p><p><strong>字面值类型</strong><br>算术类型、引用和指针都属于字面值类型。一个 constexpr 指针的初始值必须是 nullptг 或者 0，或者是存储于某个固定地址中的对象（定义于所有函数体之外的变量）。</p><p><strong>指针和 constexpr</strong><br>在 constexpr 声明中如果定义了一个指针，无论限定符 constexpr 出现在什么位置，都仅对指针生效，与指针所指的对象无关。</p><h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><p>使用<code>typedef char *pstr;</code>或<code>using pstr = char *;</code><br>注意<code>const pstr cstr</code>不等于<code>const char *cstr</code>，就像是类型别名决定了声明中结合的优先级一样。<br>前者声明了一个指向 char 的常量指针，后者声明了一个指向 const char 的指针。</p><h3 id="2-5-2-auto-类型说明符"><a href="#2-5-2-auto-类型说明符" class="headerlink" title="2.5.2 auto 类型说明符"></a>2.5.2 auto 类型说明符</h3><p>auto —般会忽略掉顶层 const 和引用，如果希望推断出的 auto 类型是一个顶层 const，需要明确指出。<br>auto 引用会保留初始值中的顶层常量属性。<br><code>int i = 0;</code><br><code>cosnt int ci = i, &amp;cr = ci;</code><br><code>auto b = ci; auto c = cr</code> b 和 c 是 int。<br><code>auto d = &amp;i; auto e = &amp;ci;</code> d 是一个 int 指针，e 是一个指向 const int 的指针。<br><code>const auto f = ci;</code> f 是一个指向 int 的常量指针。<br><code>auto &amp;g = ci; const auto &amp;j = 42;</code> g 和 j 都是 const int 引用。</p><h3 id="2-5-3-decltype-类型指示"><a href="#2-5-3-decltype-类型指示" class="headerlink" title="2.5.3 decltype 类型指示"></a>2.5.3 decltype 类型指示</h3><p>编译器分析表达式并得到它的类型，却不实际计算表达式的值。decltype 完整地保留参数的类型，包括 const 与引用。</p><p><strong>decltype 和引用</strong><br>如果表达式的内容是解引用操作，则decltype将得到引用类型。如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。如果表达式的求值结果是左值，decltype 得到一个引用类引用型。因为变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 decltype 就会得到引用类型。<br>切记：<code>decltype((variaide))</code>的结果永远是引用类型。</p><h3 id="2-6-3-编写自己的头文件"><a href="#2-6-3-编写自己的头文件" class="headerlink" title="2.6.3 编写自己的头文件"></a>2.6.3 编写自己的头文件</h3><p>有必要在书写 头文件时做适当处理，使其遇到多次包含情况也能安全和正常地工作。</p><p><strong>预处理器概述</strong><br>预处理器是在编译之前执行的一段程序。</p><p><strong>头文件保护符</strong><br>头文件保护符依赖于预处理变量。<br><code>#define</code>指令把一个名字设定为预处理变量。<br><code>#ifdef</code>当且仅当变量已定义时为真。<br><code>#ifndef</code>当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>指令为止。<br>整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CLASS_NAME_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLASS_NAME_H</span><br><span class="hljs-comment">// 各种包含与定义。</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h1 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h1><h2 id="3-2-标准库类型-string"><a href="#3-2-标准库类型-string" class="headerlink" title="3.2 标准库类型 string"></a>3.2 标准库类型 string</h2><h3 id="3-2-1-定义和初始化-string-对象"><a href="#3-2-1-定义和初始化-string-对象" class="headerlink" title="3.2.1 定义和初始化 string 对象"></a>3.2.1 定义和初始化 string 对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>; <span class="hljs-comment">// s 的内容是 cccccccccc</span><br>string s2 = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 拷贝初始化</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>; <span class="hljs-comment">// 直接初始化</span><br></code></pre></td></tr></table></figure><p><strong>读写 string 对象</strong><br>string 对象会自动忽略开头的空白，直到遇见下一处空白为止。</p><p><strong>使用 getline 读取一整行</strong><br>getline 函数的参数是一个输入流和一个 string 对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个 string 对象中去（注意不存换行符）。</p><p><strong>string::size_type 类型</strong><br>size() 函数返回的是一个 string::size_type类型的值，它是一 个无符号类型的值（参见2.1.1节，第30页）而且能足够存放下任何string对象的大小。如果一条表达式中已经有了 size() 函数就不要再使用 int 了，这样可以避免<br>混用 int 和 unsigned 可能带来的问题。</p><h2 id="3-3-标准库类型-vector"><a href="#3-3-标准库类型-vector" class="headerlink" title="3.3 标准库类型 vector"></a>3.3 标准库类型 vector</h2><p>因为引用不是对象，所以不存在包含引用的 vector。</p><h3 id="3-3-1-定义和初始化-vector-对象"><a href="#3-3-1-定义和初始化-vector-对象" class="headerlink" title="3.3.1 定义和初始化 vector 对象"></a>3.3.1 定义和初始化 vector 对象</h3><p><strong>值初始化</strong><br>可以只提供 vector 对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由 vector 对象中元素的类型决定。如果 vector 对象的元素是内置类型，比如 int，则元素初始值自动设为 0。如果元素是某种类类型，比如 string，则元素由类默认初始化。<br>如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象了。</p><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><h3 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a>3.4.1 使用迭代器</h3><p><code>vector&lt;Type&gt;::iterator</code>与<code>vector&lt;Type&gt;::const_iterator</code>类型</p><p><strong>结合解引用与成员访问操作</strong><br><code>(*it).mem();</code>括号必不可少。为了简化上述表达式，C++ 语言定义了箭头运算符（-&gt;）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code>和<code>(*it) .mem</code>表达的意思相同。<br>任何一种可能改变 vector 对象容量的操作，比如 push_back，都会使该 vector 对象的迭代器失效。<br>两个迭代器相减所得结果的类型是名为 difference_type 的带符号整型数。</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组的大小确定不变，维度必须是一个常量表达式，必须指定类型，不存在引用的数组，不允许拷贝和赋值。</p><p><strong>复杂的数组声明</strong><br><code>int *(&amp;arry)[10] = prts; // 首先arry是一个引用，引用对象为大小为10的数组，数组类型是指向int的指针</code></p><h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// ia2是指向is第一个元素的指针</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// ia3是长度为5的整型数组</span><br></code></pre></td></tr></table></figure><p><strong>标准库函数 begin 和 end</strong><br>begin() 函数返回指向数组首元素的指针，end() 函数返回指向数组尾元素下一位置的指针，这两个函数定义在 iterator 头文件中。</p><p><strong>指针运算</strong><br>两个指针相减的结果的类型是一种名为 ptrdiff_t 的标准库类型，和 size_t —样，ptrdiff_t 也是一种定义在 cstddef 头文件中的机器相关的类型。因为差值可能为负值，所以 ptrdiff_t 是一种带符号类型。</p><h3 id="3-5-4-C-风格字符串"><a href="#3-5-4-C-风格字符串" class="headerlink" title="3.5.4 C 风格字符串"></a>3.5.4 C 风格字符串</h3><p>string 类提供了 c_str() 函数，返回的是一个 C 风格字符串。<br>允许使用数组来初始化 vector 对象。<br><code>vectro&lt;int&gt; ivec(begin(int_arr), end(int_arr));</code></p><h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2><p><code>int ia[3][4] = &#123;&#123;0&#125;, &#123;1&#125;, &#123;3&#125;&#125;; // 显示地初始化每行的首元素</code><br>要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，否则 auto 的类型会是一个指针。</p><h1 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h1><h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><h3 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a>4.1.1 基本概念</h3><p><strong>运算对象转换</strong><br>小整数类型（如 bool、char、short 等）通常会被提升成较大的整数类型，主要是 int。</p><h3 id="4-1-3-求值顺序"><a href="#4-1-3-求值顺序" class="headerlink" title="4.1.3 求值顺序"></a>4.1.3 求值顺序</h3><p>编译器不会明确指定表达式中运算对象的求值顺序。<code>i++ + ++i</code>自然是未定义的操作。</p><h2 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h2><p>m%(-n)&#x3D;m%n; (-m)%n&#x3D;-(m%n)</p><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4 赋值运算符"></a>4.4 赋值运算符</h2><p>右侧运算对象将转换成左侧运算对象的类型，赋值运算返回的是其左侧运算对象。<br>复合运算符只求值一次。</p><h2 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h2><p>前置版本将更新后的对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。除非必须，否则不用递增递减运算符的后置版本。</p><h2 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a>4.7 条件运算符</h2><p>条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通 常需要在它两端加上括号。</p><h2 id="4-8-位运算符"><a href="#4-8-位运算符" class="headerlink" title="4.8 位运算符"></a>4.8 位运算符</h2><p>如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且, 此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。<br>左移运算符（&lt;&lt;）在右侧插入值为 0 的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为 0 的二进制位: 如果该运算对象是带符号类型，在左侧插入符号位的副本或值为 0 的二进制位。</p><h2 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h2><h3 id="4-11-1-算术转换"><a href="#4-11-1-算术转换" class="headerlink" title="4.11.1 算术转换"></a>4.11.1 算术转换</h3><p>算数表达式中运算符的运算对象将转换成最宽的类型。<br>带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。</p><h3 id="4-11-2-其他隐式类型转换"><a href="#4-11-2-其他隐式类型转换" class="headerlink" title="4.11.2 其他隐式类型转换"></a>4.11.2 其他隐式类型转换</h3><p>包括常量整数值 0 或者字面值 nullptr 能转换成任意指针类型。指向任意非常量的指针能转换成 void<em>。指向任意对象的指针能转换成 const void</em>。</p><h3 id="4-11-3-显示转换"><a href="#4-11-3-显示转换" class="headerlink" title="4.11.3 显示转换"></a>4.11.3 显示转换</h3><p><strong>static_cast</strong><br>任何具有明确定义的类型转换，只要不包含底层 const，都可以使用 static_cast。</p><p><strong>const_cast</strong><br>const_cast只能改变运算对象的底层 const。</p><p><strong>reinterpret_cast</strong><br>通常为运算对象的位模式提供较低层次上的重新解释。reinterpret_cast 本质上依赖于机器且非常危险。</p><p><strong>旧式的强制转换</strong><br><code>type(exper)</code>或<code>(type)exper</code><br>如果替换为 static_cast 或 const_cast 也合法，则执行与他们相似的行为，否则执行与 reinterpret_cast 相似的行为。</p><h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h1><h2 id="5-6-try-语句和异常处理"><a href="#5-6-try-语句和异常处理" class="headerlink" title="5.6 try 语句和异常处理"></a>5.6 try 语句和异常处理</h2><p>抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。<br>在 try 中 throw 异常，然后层层查找符合的 catch。如果最终还是没能找到任何匹配的catch子句，程序转到名为 terminate 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p><h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><h2 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h2><p><strong>形参和实参</strong><br>实参是形参的初始值。编译器能以任意可行的顺序对实参求值。</p><h3 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h3><p><strong>自动对象</strong><br>我们把只存在于块执行期间的对象称为自动对象。</p><p><strong>局部静态对象</strong><br>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。<br>如果局部静态变量没有显式的初始值，它将执行值初始化。</p><h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><h3 id="6-2-3-const-形参和实参"><a href="#6-2-3-const-形参和实参" class="headerlink" title="6.2.3 const 形参和实参"></a>6.2.3 const 形参和实参</h3><p>当用实参初始化形参时会忽略掉顶层 const。换句话说，形参的顶层 const 被忽略掉了。</p><p><strong>尽量使用常量引用</strong><br>一个非常量引用的形参无法接受一个常量的实参</p><h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><span class="hljs-comment">// 这三个函数是等价的。</span><br></code></pre></td></tr></table></figure><p><strong>数组引用形参</strong><br>形参是数组的引用，维度是类型的一部分。<br><code>void fun(int (&amp;arr)[10]);</code></p><p><strong>传递多维数组</strong><br>数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：<br><code>void fun(int (*mat)[10])</code></p><h3 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h3><p><strong>initializer_list 形参</strong><br>实参数量未知但是全部实参的类型都相同，initializer_list 也是一种模板类型，对象中的元素永远是常量值。如果想向 initializer_list 形参中传递一个值的序歹，则必须把序列放在一对花括号内：<br><code>fun(&#123;a, b, c&#125;);</code></p><p><strong>省略符形参</strong><br>省略符形参只能出现在形参列表的最后一个位置，大多数类类型的对象在传递给省略符形参时都无法正确拷贝，省略符形参所对应的实参无须类型检查。<br><code>void fun(int a, ...)</code></p><h2 id="6-3-返回类型和-return-语句"><a href="#6-3-返回类型和-return-语句" class="headerlink" title="6.3 返回类型和 return 语句"></a>6.3 返回类型和 return 语句</h2><h3 id="6-3-1-无返回值函数"><a href="#6-3-1-无返回值函数" class="headerlink" title="6.3.1 无返回值函数"></a>6.3.1 无返回值函数</h3><p>在这类函数的最后一句后面会隐式地执行 return。一个返冋类型是 void 的函数也能返回另一个返回 void 的函数。</p><h3 id="6-3-2-有返回值函数"><a href="#6-3-2-有返回值函数" class="headerlink" title="6.3.2 有返回值函数"></a>6.3.2 有返回值函数</h3><p>返冋的值用于初始化调 用点的一个临时量，该临时量就是函数调用的结果。</p><h3 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a>6.3.3 返回数组指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> arrT[<span class="hljs-number">10</span>]; <span class="hljs-comment">// arrT的类型是长度为10的int数组</span><br><span class="hljs-keyword">using</span> arrT = <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 等价</span><br></code></pre></td></tr></table></figure><p>返回数组指针的函数形如：<br><code>Type(*fun(par_list))[dim]</code></p><p><strong>使用尾置返回类型</strong><br>尾置返冋类型跟在形参列表后面并以一个（-&gt;）符号开头。在本应该出现返回类型的地方放置一个 auto。<br><code>auto fun(int i) -&gt; int (*) [10];</code><br>注意：decltype 并不负责把数组类型转换成对应的指针。</p><h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h2><p>一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参R分开来。</p><h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h3><p>为了使得窗口函数既能接纳默认值，也能接受用户指定的值，我们把它定义成如下的形式：<br><code>void fun(int a, int b = 0, int c = 1);</code><br>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值，默认实参负责填补函数调用缺少的尾部实参。<br>用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时。</p><h3 id="6-5-2-内联函数和-constexpr-函数"><a href="#6-5-2-内联函数和-constexpr-函数" class="headerlink" title="6.5.2 内联函数和 constexpr 函数"></a>6.5.2 内联函数和 constexpr 函数</h3><p><strong>内联函数可避免函数调用的开销</strong><br>在函数的返回类型前面加上关键字 inline，内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p><p><strong>constexpr 函数</strong><br>函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条 return 语句。<br>编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr 函数被隐式地指定为内联函数。<br>我们允许 constexpr 函数的返回值并非一个常量。</p><h3 id="6-5-3-调试帮助"><a href="#6-5-3-调试帮助" class="headerlink" title="6.5.3 调试帮助"></a>6.5.3 调试帮助</h3><p><code>assert(expr);</code><br>如果表达式为真（即非0），assert 什么也不做。assert 宏常用于检查“不能发生”的条件。</p><p><strong>NDEBUG 预处理变量</strong><br><code>#define NDEBUG</code><br>如果定义了 NDEBUG, 则 assert 什么也不做。定义 NDEBUG 能避免检查各种条件所需的运行时开销。</p><h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h2><p><strong>确定候选函数和可行函数</strong><br>候选函数：一是与被调用的函数同名，二是其声明在调用点可见。<br>可行函数：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p><p><strong>寻找最佳匹配</strong><br>如果有且只有一个函数满足下列条件，则匹配成功：</p><ul><li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。</li><li>至少有一个实参的匹配优于其他可行函数提供的匹配。</li></ul><p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报 告二义性调用的信息。</p><h2 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h2><p><strong>使用函数指针</strong><br>当我们把函数名作为一个值使用时，该函数自动地转换成指针（取地址符可选）<br>我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针（解引用符可选）<br>在指向不同函数类型的指针间不存在转换规则。</p><p><strong>函数指针形参</strong><br>形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> fun2())</span></span>; <span class="hljs-comment">// 形参是函数类型，它会自动地转换成指向函数的指针。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fun2)())</span></span>; <span class="hljs-comment">// 显式地将形参定义成指向函数的指针。</span><br></code></pre></td></tr></table></figure><p>直接把函数作为实参使用，此时它会自动转换成指针。<br><code>fun1(fun);</code></p><p><strong>返回指向函数的指针</strong><br>编译器不会自动地将函数返回类型当成对应的指针类型处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> F = <span class="hljs-built_in">int</span>();<br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in">int</span>(*)();<br><br><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// PF是指向函数的指针，fl返回指向函数的指针。</span><br><span class="hljs-function">F *<span class="hljs-title">fi</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 显式地指定返回类型是指向函数的指针。</span><br></code></pre></td></tr></table></figure><h1 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h1><h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><p><strong>引入 this</strong><br><code>total.isbn()</code><br>当 isbn() 返冋 bookNo 时，实际上它隐式地返回 total.bookNo。<br>编译器负责把 total 的地址传递给 isbn() 的隐式形参 this，任何对类成员的直接访问都被看作this的隐式引用。<br>因为 this 的目的总是指向“这个”对象，所以 this 是一个常量指针。</p><p><strong>引入 const 成员函数</strong><br>默认情况下，this 的类型是指向类类型非常量版本的常量指针。由于底层 const 不匹配，我们不能在一个常量对象上调用普通的成员函数。<br>紧跟在参数列表后面的 const 表示 this 是一个指向常量的指针，常量成员函数不能改变调用它的对象的内容。常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p><h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h3><p>构造函数不能被声明成 const 的，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在 const 对象的构造过程中可以向其写值。</p><h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3><p>友元声明只能出现在类定义的内部，友元不是类的成员也不受它所在区域访问控制级别的约束。</p><p><strong>友元的声明</strong><br>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p><h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><h3 id="7-3-1-类成员再探"><a href="#7-3-1-类成员再探" class="headerlink" title="7.3.1 类成员再探"></a>7.3.1 类成员再探</h3><p><strong>定义_个类型成员</strong><br>类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> pos = std::string::size_type;<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义在类内部的成员函数是自动 inline 的。</p><p><strong>可变数据成员</strong><br>在变量的声明中加入 mutable 关键字，一个可变数据成员永远不会是 const，即使它是 const 对象的成员。因此，一个 const 成员函数可以改变一个可变成员的值。</p><h3 id="7-3-2-返回-this-的成员函数"><a href="#7-3-2-返回-this-的成员函数" class="headerlink" title="7.3.2 返回 *this 的成员函数"></a>7.3.2 返回 *this 的成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ClassName &amp;<span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回引用的函数是左值的，所以这样的操作将在同一个对象上执行：<br><code>实例.fun1().fun2().fun3()</code><br>如果定义的返回类型不是引用，则函数的返回值将是 *this 的副本，因此调用函数只能改变临时副本，而不能改变原实例的值。</p><p>*<em>从 const 成员函数返回 <em>this</em></em><br>一个 const 成员函数如果以引用的形式返回 *this，那么它的返回类里将是常量引用，因为非常量版本的函数对于常量对象是不可用的。<br>根据对象是否是常量重载函数，隐式传入的 this 参数同样参与函数匹配的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ClassName &amp;<span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> ClassName &amp;<span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a>7.3.3 类类型</h3><p>在类声明之后定义之前是一个不完全类型，可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。一旦一个类的名字出现后，它就被认为是声明过了。</p><h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h3><p>友元关系不存在传递性。<br>友元类的成员函数和友元成员函数可以访问此类包括非公有成员在内的所有成员。<br>如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。</p><p><strong>友元声明和作用域</strong><br>当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-built_in">ClassName</span>() &#123;<br>        <span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// 错误</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClassName::a</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// 错误</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClassName::b</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fun</span>(); <span class="hljs-comment">// 正确</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><p>在类的外部定义其成员函数时，因为返回类型出现在类名之前，所以事实上返回类型是位于类的作用域之外的。</p><p><strong>类作用域之后，在外围的作用域中查找</strong><br>如果我们需要的是外层作用域中的名字，可以显式地通过作用域运算符（::）来进行请求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> tmp)</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">2</span> * ::tmp; <span class="hljs-comment">// 此时的in是最外层的全局变量</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><h3 id="7-5-1-构造函数初姶值列表"><a href="#7-5-1-构造函数初姶值列表" class="headerlink" title="7.5.1 构造函数初姶值列表"></a>7.5.1 构造函数初姶值列表</h3><p>如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。<br>如果成员是 const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。<br>成员的初始化顺序与它们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。<br>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p><h3 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a>7.5.4 隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制（转换构造函数）。在需要使用类类型的地方，我们可以使用转换构造函数的参数的类型作为替代。<br>只允许一步类类型转换，隐式地使用两种转换规则是错误的。比如只定义了 string 的转换构造函数却提供了一个字符串常量实参。</p><p><strong>抑制构造函数定义的隐式转换</strong><br>将构造函数声明为 explicit 加以抑制隐式转换。<br>关键字 explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换。只能在类内声明构造函数时使用 explicit 关键字，在类外部定义时不应重复。<br>显示地进行强制转换依旧可以正常地发挥转换构造函数的效果。</p><h3 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a>7.5.5 聚合类</h3><p>当一个类满足如下条件时，我们说它是聚合的：</p><ul><li>所有成员都是 public 的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类，也没有 virtual 函数。<br>可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员，初始值的顺序必须与声明的顺序一致。</li></ul><h3 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a>7.5.6 字面值常量类</h3><p>数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：</p><ul><li>数据成员都必须是字面值类型。</li><li>类必须至少含有一个 constexpr 构造函数。</li><li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数。</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。</li></ul><p><strong>constexpr 构造函数</strong><br>尽管构造函数不能是 const 的，但是字面值常量类的构造函数可以是 constexpr 函数，constexpr 构造函数体一般来说应该是空的，或者声明成<code>= default</code>.<br>constexpr 构造函数必须初始化所有数据成员.</p><h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><p>对象中不包含任何与静态数据成员有关的数据，静态成员函数不能声明成 const 的，而且我们也不能在 static 函数体内使用 this 指针。<br>使用作用域运算符直接访问静态成员，使用类的对象、引用或者指针的点运算符来访问静态成员。</p><p><strong>定义静态成员</strong><br>当在类的外部定义静态成员时，不能重复 static 关键字，该关键字只出现在类内部的声明语句。<br>我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。</p><p><strong>静态成员的类内初始化</strong><br>我们可以为静态成员提供 const 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 constexpr。即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外<br>部定义一下该成员。<br>静态数据成员可以是不完全类型。</p><h1 id="第八章-IO-库"><a href="#第八章-IO-库" class="headerlink" title="第八章 IO 库"></a>第八章 IO 库</h1><h2 id="8-1-IO-类"><a href="#8-1-IO-类" class="headerlink" title="8.1 IO 类"></a>8.1 IO 类</h2><h3 id="8-1-1-IO-对象无拷贝或赋值"><a href="#8-1-1-IO-对象无拷贝或赋值" class="headerlink" title="8.1.1 IO 对象无拷贝或赋值"></a>8.1.1 IO 对象无拷贝或赋值</h3><p>进 IO 操作的函数通常以引用方式传递和返回流。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 const 的。</p><h3 id="8-1-2-条件状态"><a href="#8-1-2-条件状态" class="headerlink" title="8.1.2 条件状态"></a>8.1.2 条件状态</h3><p>如果我们输入一个非期望的数据类型或一个文件结束标识，cin 会进入错误状态。<br>一个流一旦发生错误，其上后续 IO 操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。</p><h3 id="8-1-3-管理输出缓冲"><a href="#8-1-3-管理输出缓冲" class="headerlink" title="8.1.3 管理输出缓冲"></a>8.1.3 管理输出缓冲</h3><p>读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。</p><p><strong>unitbf</strong><br>unitbuf 操纵符告诉流在接下来的每次写操作之后都进行一次 flush 操作。而 nounitbuf 操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; unitbuf;<br>cout &lt;&lt; nounitbuf;<br></code></pre></td></tr></table></figure><p><strong>关联输入和输出流</strong><br>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。<br>标准库将 cout 和 cin 关联在一起，<br>tie 有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie 的第二个版本接受一个指向 ostream 的指针，将自己关联到此 ostream。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">in.<span class="hljs-built_in">tie</span>(&amp;out);<br><span class="hljs-comment">// old_tie 指向当前关联到 in 的流，in 不再与其他流关联。</span><br>ostream *old_out = in.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>in.<span class="hljs-built_in">tie</span>(&amp;new_out);<br>in.<span class="hljs-built_in">tie</span>(old_out);<br></code></pre></td></tr></table></figure><h2 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h2><p>ifstream 从一个给定文件读取数据，ofstream 向一个给定文件写入数据，以及 fstream 可以读写给定文件。</p><h3 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h3><p>创建文件流对象时，我们可以提供文件名。如果提供了一个文件名，则 open 会自动被调用。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。当一个 fstream 对象被销毁时，close 会自动被调用。</p><h3 id="8-2-2-文件模式"><a href="#8-2-2-文件模式" class="headerlink" title="8.2.2 文件模式"></a>8.2.2 文件模式</h3><p>in：以读方式打开；out：以写方式打开；app：每次写操作前均定位到文件末尾；ate：打开文件后立即定位到文件末尾；trunc：截断文件；binary：以二进制方式进 IO；<br>在 app 模式下，即使没有显式指定 out 模式，文件也总是以输出方式被打开。<br>即使我们没有指定 trun ，以 out 模式打幵的文件也会被截断。<br>与 ifstream 关联的文件默认以 in 模式打幵；与 ofstream 关联的文件默认以 out 模式打开；与 fstream 关联的文件默认以 in 和 out 模式打幵。<br>默认情况下，当我们打开一个 ofstream 时，文件的内容会被丢弃。每当打开文件时，都可以改变其文件模式。</p><h2 id="8-3-string-流"><a href="#8-3-string-流" class="headerlink" title="8.3 string 流"></a>8.3 string 流</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">sstream <span class="hljs-title">strm</span><span class="hljs-params">(s)</span></span>; <span class="hljs-comment">// strm 保存 string s 的一个拷贝。</span><br>strm.<span class="hljs-built_in">str</span>(); <span class="hljs-comment">// 返回 strm 保存的 string 拷贝。</span><br>strm.<span class="hljs-built_in">str</span>(s); <span class="hljs-comment">// 将 string s 拷贝到 strm 中，返回 void。</span><br></code></pre></td></tr></table></figure><h1 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h1><h2 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h2><p><strong>vector</strong>：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。<br><strong>deque</strong>：双端队列。支持快速随机访问。在头尾位置插入&#x2F;删除速度很快。<br><strong>list</strong>：双向链表。只支持双向顺序访问。在list中任何位置进行插入&#x2F;删除 操作速度都很快。<br><strong>forward_list</strong>：单向链表。只支持单向顺序访问。在链表任何位置进行插入&#x2F;删除操作速度都很快。<br><strong>array</strong>：固定大小数组。支持快速随机访问。不能添加或删除元素。<br><strong>string</strong>：与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入&#x2F;删除速度快。</p><p><strong>确定使用哪种顺序容器</strong></p><ul><li>除非你有很好的理由选择其他容器，否则应使用 vector。</li><li>如果你的程序有很多小的元素，且空间的额外开销很重要，则不耍使用 list 或 forward_list。</li><li>如果程序要求随机访问兀素，应使用 vector 或 deque。</li><li>如果程序要求在容器的中间插入或删除元素，应使用 list 或 forward_list。</li><li>如果程序需要在头尾位置插入或刪除元素，但不会在中间位置进行插入或删除操作，则使用 deque。</li></ul><h3 id="9-2-4-容器定义和初始化"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化</h3><p><strong>标准库 array 具有固定大小</strong><br>当定义一个 array 时，除了指定元素类型，还要指定容器大小。<br>一个默认构造的 array 是非空的，它包含了与其大小一样多的元素。这些元素都被默认初始化。<br>如果初始值列表中的初始值数目小于 array 的大小，则它们被用来初始化 array 中靠前的元素，所有剩余元素都会进行值初始化。<br>此外，array 还要求初始值元素类型和大小也都一样，因为大小是 array 类型的一部分。</p><h3 id="9-2-5-赋值和-swap"><a href="#9-2-5-赋值和-swap" class="headerlink" title="9.2.5 赋值和 swap"></a>9.2.5 赋值和 swap</h3><p>array 类型不支持 assign, 也不允许用花括号包围的值列表进行赋值。<br>賦值相关运算会导致指向左边容器内部的迭代器、引用和指针失效而 swap 操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效。</p><p><strong>使用 assign (仅顺序容器）</strong><br>assign 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。用参数所指定的元素（的拷贝）替换左边容器中Й所有元素。<br>传递给 assign 的迭代器不能指向调用 assign 的容器。</p><p><strong>使用 swap</strong><br>swap 不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。<br>元素不会被移动意味着，除 string 外，指向容器的迭代器、引用和指针在 swap 操作之后都不会失效。它们仍指向 swap 操作之前所指向的那些元素。但是，在 swap 之后，这些元素已经属于不同的容器了。<br>与其他容器不同，swap 两个 array 会真正交换它们的元素。因此，交换两个 array 所需的时间与 array 中元素的数目成正比。</p><h3 id="9-2-7-关系运算符"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符</h3><p>关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。比较两个容器实际上是逐元素使用元素的关系运算符完成比较。<br>如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。</p><h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><h3 id="9-3-1-向顺序容器添加元素"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素</h3><p><strong>使用 emplace 操作</strong><br>当调用 push 或 insert 成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。<br>而当我们调用一个 emplace 成员函数时，则是将参数传递给元素类型的构造函数。emplace 成员使用这些参数在容器管理的内存空间中直接构造元素。</p><h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><p>front() 返回首元素的引用，back() 返回尾元素的引用。c[n] 与 a.at(n) 在 n 未越界时效果相同，越界时 at() 抛出 out_of_range 异常。</p><h3 id="9-3-5-改变容器大小"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ilist</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>)</span></span>;<br>ilist.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// 将 5 个 -1 添加到 ilist 的末尾。</span><br>ilist.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 从 ilist 的末尾删除 10 个元素。</span><br></code></pre></td></tr></table></figure><h3 id="9-3-6-容器操作可能使迭代器失效"><a href="#9-3-6-容器操作可能使迭代器失效" class="headerlink" title="9.3.6 容器操作可能使迭代器失效"></a>9.3.6 容器操作可能使迭代器失效</h3><p>当我们删除元素时，尾后迭代器总是会失效。保证每次改变谷器的操作之后都正确地重新定位迭代器。<br>不能在循环之前保存 end 返回的迭代器，通常 end() 操作都很快。</p><h2 id="9-4-vector-对象是如何增长的"><a href="#9-4-vector-对象是如何增长的" class="headerlink" title="9.4 vector 对象是如何增长的"></a>9.4 vector 对象是如何增长的</h2><p>没有空间容纳新元素，因为元素必须连续存储，容器必须分配新的内存空间来保存己有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。<br>vector 和 string 的实现通常会分配比新的空间需求更大的内存空间，容器预留这些空间作为备用。<br>补充：<a href="http://blog.sina.com.cn/s/blog_a2a6dd380102w73e.html">push_back 的时间复杂度为什么是 o(1)</a></p><p><strong>管理容量的成员函数</strong><br>c.shrink_to_fit()：请求将 capacity() 减少为与 size() 相同d 大小，标准库并不保证一定能退还内存。<br>c.capacity()：不重新分配内存空间的话，容器可以保存多少兀素。<br>c.reserve(n)：分配至少能容纳 n 个元素的内存空间。<br>reserve 并不改变容器中元素的数量，它仅影响 vector 預先分配多大的内存空间。只有当需要的内存空间超过当前容量时，reserve 调用才会改变 vector 的容量，否则什么也不做，所以说调用 reserve 永远也不会减少容器占用的内存空间。</p><h2 id="9-5-额外的-string-操作"><a href="#9-5-额外的-string-操作" class="headerlink" title="9.5 额外的 string 操作"></a>9.5 额外的 string 操作</h2><h3 id="9-5-3-string-搜索操作"><a href="#9-5-3-string-搜索操作" class="headerlink" title="9.5.3 string 搜索操作"></a>9.5.3 string 搜索操作</h3><p>如果搜索失败，则返回一个名为 stringr::npos 的 static 成员。<br>string 搜索函数返回 string::size_type 值，该类型是一个 unsigned 类型。因此，用一个 int 或其他带符号类型来保存这些函数的返回值不是一个好主意。</p><h1 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h1><h2 id="10-2-初始泛型算法"><a href="#10-2-初始泛型算法" class="headerlink" title="10.2 初始泛型算法"></a>10.2 初始泛型算法</h2><h3 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h3><p><strong>介绍 back_inserter</strong><br>back_inserter 接受一个指向容器的引用，当我们通过此迭代器赋值时，赋值运算符会调用 push_back 将一个具有给定值的元素添加到容器中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">// 空向量</span><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">back_inserter</span>(vec); <span class="hljs-comment">// 通过它賦值会将元素添加到 vec 中</span><br>it = <span class="hljs-number">42</span>; <span class="hljs-comment">// vec 中现在有一个元素，值为 42</span><br></code></pre></td></tr></table></figure><h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p><strong>谓词</strong><br>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为一元谓词和二元谓词。</p><h3 id="10-3-2-lambda-表达式"><a href="#10-3-2-lambda-表达式" class="headerlink" title="10.3.2 lambda 表达式"></a>10.3.2 lambda 表达式</h3><p><strong>介绍lambda</strong><br>可以将其理解为一个未命名的内联函数。lambda可能定义在函数内部。lambda 必须使用尾置返回。一个lambda表达式具有如下形式：<br>[capture list] (parameter list) -&gt; return type { function body }<br>如果 lambda 的函数体包含任何单一 return 语句之外的内容，且未指定返回类型，则返回 void。</p><p><strong>向lambda传递参数</strong><br>lambda 不能有默认参数。一个 lambda 通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引 lambda 在其内部包含访问局部变量所需的信息。<br>捕获列表只用于局部非 static 变量，lambda 可以直接使用局部 static 变量和在它所在函数之外声明的名字。</p><h3 id="10-3-3-lambda-捕获的返回"><a href="#10-3-3-lambda-捕获的返回" class="headerlink" title="10.3.3 lambda 捕获的返回"></a>10.3.3 lambda 捕获的返回</h3><p>当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象。<br>值捕获则是在定义之时进行捕获，而引用捕获在调用时进行捕获。</p><p><strong>值捕获</strong><br>采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝，随后对其修改不会影响到 lambda 内对应的值。</p><p><strong>引用捕获</strong><br>采用引用方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的。</p><p><strong>隐式捕获</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[=](<span class="hljs-type">const</span> string &amp;s)<br>&#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span> () &gt;= sz; &#125; <span class="hljs-comment">// sz 未隐式的值捕获</span><br></code></pre></td></tr></table></figure><p>如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// os隐式捕获，引用捕获方式；c 显式捕获，值捕获方式</span><br>[&amp;, c](<span class="hljs-type">const</span> string &amp;s)&#123; os &lt;&lt; s &lt;&lt; c; &#125;<br><span class="hljs-comment">// os显式捕获，引用捕获方式；c隐式捕获，值捕获方式</span><br>[=, &amp;os](<span class="hljs-type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;<br></code></pre></td></tr></table></figure><p>当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个 &amp; 或 &#x3D;。此符号指定了默认捕获方式为引用或值，显式捕获的变量必须使用与隐式捕获不同的方式。</p><p><strong>可变 lambda</strong><br>如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> fсп() &#123;<br><span class="hljs-type">int</span> vl = <span class="hljs-number">42</span>; <span class="hljs-comment">// 局部变量</span><br><span class="hljs-comment">// f 可以改变它所捕获的变量的值</span><br><span class="hljs-keyword">auto</span> f = [vl] () <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> ++vl; &#125;;<br>vl = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// j 为 43</span><br></code></pre></td></tr></table></figure><h3 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h3><p><strong>标准库 bind 函数</strong><br>bind 接受一个可调用对象，生成一个新的可调用对 象来“适应”原对象的参数列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> newCallable = <span class="hljs-built_in">bind</span> (callable, arg_list);<br></code></pre></td></tr></table></figure><p>当我们调用 newCallable 时 newCallable 会调用 callable，并传递给它中的参数。<br>arg_list 参数可能包含形如 _n 的名字。这些参数是“占位符”，其本身的位置代表其在原函数形参列表中的位置，其数字代表其在新函数形参列表中的位置。<br>名字 _n 都定义在一个名为 placeholders 的命名空间中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> newFun = <span class="hljs-built_in">bind</span>(oldFun, a, b, _2, c, _1);<br></code></pre></td></tr></table></figure><p>这个 bind 调用会将 <code>newFun(_1, _2);</code> 映射为 <code>oldFun(a, b, _2, с, _1);</code></p><p><strong>绑定引用参数</strong><br>如果我们希望传递给 bind 一个对象而又不拷贝它，就必须使用标准库 ref 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 我们无法拷贝 ostream</span><br>for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(print, <span class="hljs-built_in">ref</span>(os), _1, <span class="hljs-string">&#x27; &#x27;</span>));<br></code></pre></td></tr></table></figure><p>函数 ref 返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个 cref 函数，生成一个保存 const 引用的类。</p><h1 id="第十一章-关联容器"><a href="#第十一章-关联容器" class="headerlink" title="第十一章 关联容器"></a>第十一章 关联容器</h1><p>允许重复关键字的容器的名字中都包含单词 multi，不保持关键字按顺序存储的容器的名字都以单词 unordered 开头。</p><h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><p>如果下标还未在 map 中，下标运算符会创建一个新元素，其关键字为下标，值为值初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(target) == set.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// set 中不存在 target</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><h3 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h3><p>对于有序容器 map、multimap、set 以及 multiset，关键字类型必须定义元素比较的方法</p><h3 id="11-2-3-pair-类型"><a href="#11-2-3-pair-类型" class="headerlink" title="11.2.3 pair 类型"></a>11.2.3 pair 类型</h3><p>一个 pair 保存两个 public 数据成员， 两个成员分别命名为 first 和 second。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">make_pair</span>(v1, v2); <span class="hljs-comment">// pair 的类型由 v1 v2 推断出来。</span><br></code></pre></td></tr></table></figure><h2 id="11-3-关联容器的操作"><a href="#11-3-关联容器的操作" class="headerlink" title="11.3 关联容器的操作"></a>11.3 关联容器的操作</h2><p>key_type：此容器类型的关键字类型。<br>mapped_type：每个关键字关联的类型，只适用于map。<br>value_type：对于 set，与 key_type 相同；对于 map，为 <code>pair&lt;const key_type, mapped_type&gt;</code><br>关键字是 const 的。</p><h3 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h3><p>插入一个已存在的元素对容器没有任何影响。</p><p><strong>检测 insert 的返回值</strong><br>添加单一元素的 insert 和 emplace 版本返冋一个 pair，first 成员是一个迭代器，指向具有给定关键字的元素；second 成员是一个 bool 值，指出元素是插入成功还是已经存在于容器中。</p><h3 id="11-3-4-map-的下标操作"><a href="#11-3-4-map-的下标操作" class="headerlink" title="11.3.4 map 的下标操作"></a>11.3.4 map 的下标操作</h3><p>set 类型不支持下标，也不能对一个 multimap 或一个 unordered_multimap 进行下标操作。<br>如果关键字并不在 map 中，会为它创建一个元素并插入到 map 中，关联值将进行值初始化。如果不希望产生新的插入，可以使用 at()。<br>当对一个 map 进行下标操作时，会获得一个 mapped_type 对象；但当解引用一个 map 迭代器时，会得到一个 value_type 对象。</p><h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><p>c.lower_bound(k)：返回一个迭代器，指向第一个关键字不小于к的元素。<br>с.upper_bound(k)：返回一个迭代器，指向第一个关键字大于к的元素。<br>с.equal_range(k)：返回一个迭代器 pair，表示关键字等于 K 的元素的范围。若不存在，pair 的两个成员均等于 c.end()。<br>若关键字未匹配，他们都返回一个迭代器，指向不影响排序的关键字插入位置。</p><p><strong>在 multimap 或 multiset 中查找元素</strong><br>如果一个 multimap 或 multiset 中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。</p><h2 id="在容器中使用自定义的类"><a href="#在容器中使用自定义的类" class="headerlink" title="在容器中使用自定义的类"></a>在容器中使用自定义的类</h2><p>如果要在 map&#x2F;set 中使用自定义的类，需要提供判断 &lt; 的方法。<br>如果要在 unordered_map&#x2F;unordered_set 中使用自定义的类，需要提供计算哈希值的方法，以及判断 &#x3D;&#x3D; 的方法。</p><ul><li>使用函数指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span>&#123;<span class="hljs-comment">/* 成员与构造函数 */</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">m_hash</span> <span class="hljs-params">(<span class="hljs-type">const</span> Line &amp;l)</span> </span>&#123;<br><span class="hljs-keyword">return</span> l.k * <span class="hljs-number">100</span> + l.b;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">m_equal</span> <span class="hljs-params">(<span class="hljs-type">const</span> Line &amp;l1, <span class="hljs-type">const</span> Line &amp;l2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> l<span class="hljs-number">1.</span>k == l<span class="hljs-number">2.</span>k &amp;&amp; l<span class="hljs-number">1.</span>b == l<span class="hljs-number">2.</span>b;<br>&#125;;<br><br><span class="hljs-comment">// 参数代表了桶的大小、哈希函数指针、相等性判断运算符函数指针</span><br><span class="hljs-function">unordered_set&lt;Line, <span class="hljs-title">decltype</span><span class="hljs-params">(m_hash)</span>*, <span class="hljs-title">decltype</span><span class="hljs-params">(m_equal)</span>*&gt; <span class="hljs-title">h_set</span><span class="hljs-params">(<span class="hljs-number">42</span>, m_hash, m_equal)</span></span>;<br></code></pre></td></tr></table></figure></li><li>如果我们的类重载了 &#x3D;&#x3D; 运算符，则可以只重载哈希函数。<br>并且，我们可以通过重载函数调用运算符的方式提供一个函数对象。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;<br>    <span class="hljs-comment">// 成员与构造函数</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> Line &amp;l) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span>  k == l.k &amp;&amp; b == l.b;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LineHash</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> Line &amp;l)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  l.k * <span class="hljs-number">100</span> + l.b;<br>    &#125;<br>&#125;;<br><br>unordered_set &lt;Line, LineHash&gt; h_set;<br>unordered_map &lt;Line, string, LineHash&gt; h_map;<br></code></pre></td></tr></table></figure></li><li>最后，在 C++20 中似乎可以用 lambda 代替这个函数对象。<blockquote><p>C++11 到 C++17 里，lambda 表达式的复制运算符被删除了，这导致 lambda 表达式无法复制构造，不满足哈希函数所需的条件（是函数对象，可复制构造，可析构，调用时对相同对象返回相同哈希）。<br>C++20 里据说无捕获的 lambda 表达式可以复制构造了。理论上这应该解决了 lambda 表达式不能做哈希的缺陷。<br><a href="https://www.zhihu.com/question/469655331">知乎</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span>&#123;<span class="hljs-comment">/* 成员与构造函数 */</span>&#125;;<br><br><span class="hljs-keyword">auto</span> m_hash = [](<span class="hljs-type">const</span> Line &amp;l) &#123;<br><span class="hljs-built_in">return</span> (<span class="hljs-type">size_t</span>)(l.k * <span class="hljs-number">100</span> + l.b);<br>&#125;;<br><span class="hljs-keyword">auto</span> m_equal = [](<span class="hljs-type">const</span> Line &amp;l1, <span class="hljs-type">const</span> Line &amp;l2) &#123;<br><span class="hljs-keyword">return</span> l<span class="hljs-number">1.</span>k == l<span class="hljs-number">2.</span>k &amp;&amp; l<span class="hljs-number">1.</span>b == l<span class="hljs-number">2.</span>b;<br>&#125;;<br><br>unordered_set&lt;Line, <span class="hljs-keyword">decltype</span>(m_hash), <span class="hljs-keyword">decltype</span>(m_equal)&gt; h_set;<br><span class="hljs-comment">// 或者写成</span><br><span class="hljs-function">unordered_set&lt;Line, <span class="hljs-title">decltype</span><span class="hljs-params">(m_hash)</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(m_equal)</span>&gt; <span class="hljs-title">h_set</span><span class="hljs-params">(<span class="hljs-number">42</span>, m_hash, m_equal)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h1 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="headerlink" title="第十二章 动态内存"></a>第十二章 动态内存</h1><p>分配在静态或栈内存中的对象由编译器自动创建和销毁。每个程序还拥有一个内存池，这部分内存被称作自由空间或堆。程序用堆来存储动态分配的对象。</p><h2 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h2><h3 id="12-1-1-shared-ptr-类"><a href="#12-1-1-shared-ptr-类" class="headerlink" title="12.1.1 shared_ptr 类"></a>12.1.1 shared_ptr 类</h3><p>最安全的分配和使用动态内存的方法是调用一个名为 make_shared&lt;&gt;() 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象 shared_ptr。<br>每个 shared_ptr 都有一个关联的计数器，通常称其为引用计数。一旦一个 shared_ptr 的计数器变为 0，它就会自动释放自己所管理的对象。但只要有其他 shared_ptr 也指向这块内存，它就不会被释放掉。<br>补充：<a href="https://www.jianshu.com/p/a704fef4809c">shared_ptr 导致的循环引用及其解决方法</a></p><h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3><p><strong>使用 new 动态分配和初始化对象</strong><br>new 无法为其分配的对象命名，而是返回一个指向该对象的指针。动态分配的对象是默认初始化的，而类类型对象将用默认构造函数进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// 默认初始化</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(); <span class="hljs-comment">// 值初始化</span><br></code></pre></td></tr></table></figure><p>只有当括号中仅有单一初始化器时才可以使用 auto 推断 new 的返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p2 = <span class="hljs-built_in">new</span> (nothrow) <span class="hljs-type">int</span>; <span class="hljs-comment">//如果分配失败，new 返回一个空才旨针，不抛出异常</span><br></code></pre></td></tr></table></figure><h3 id="12-1-3-shared-ptr-和-new-结合使用"><a href="#12-1-3-shared-ptr-和-new-结合使用" class="headerlink" title="12.1.3 shared_ptr 和 new 结合使用"></a>12.1.3 shared_ptr 和 new 结合使用</h3><p>不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;<span class="hljs-type">int</span>&gt; pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">//错误：必须使用直接初始化形式</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>; <span class="hljs-comment">// 正确：使用了直接初始化形式</span><br></code></pre></td></tr></table></figure><p>一个临时的 shared_ptr 指向的内存会立刻被释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>; <span class="hljs-comment">//危险：x 是一个普通指针，不是一个智能指针</span><br><span class="hljs-built_in">process</span> (x); <span class="hljs-comment">// 错误：不能将 int* 转换为一个 shared_ptr&lt;int&gt;</span><br><span class="hljs-built_in">process</span> (<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(x)); <span class="hljs-comment">// 合法的，但内存会被释放</span><br><span class="hljs-type">int</span> j = *x; <span class="hljs-comment">// 未定义的：X 是一个空悬指针</span><br></code></pre></td></tr></table></figure><p>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。<br>也不要使用 get 初始化另一个智能指针或为智能指针赋值，因为另一个智能指针会做额外的 delete。<br>而且使用 get 返回的指针的代码不能 delete 此指针。</p><h3 id="12-1-4-智能指针的异常"><a href="#12-1-4-智能指针的异常" class="headerlink" title="12.1.4 智能指针的异常"></a>12.1.4 智能指针的异常</h3><p>在 new 之后在对应的 delete 之前发生了异常，则内存不会被释放。</p><p><strong>使用我们自己的释放操作</strong><br>当我们创建一个 shared_ptr 时，可以传递一个指向删除器函数的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;connection&gt; <span class="hljs-title">p</span><span class="hljs-params">(&amp;c, end_connection)</span></span>;<br></code></pre></td></tr></table></figure><p>当 p 被销毁时，它不会对自己保存的指针执行 delete，而是调用 end_connection。</p><h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><p>某个时刻只能有一个 unique_ptr 指向一个给定对象。初始化 unique_ptr 必须采用直接初始化形式。unique_ptr 不支持普通的拷贝或赋值操作。</p><p><strong>传递 unique_ptr 参数和返回 unique_ptr</strong><br>有一个例外：我们可以拷贝或赋值一个将要被销毁的 unique_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unique一<span class="hljs-function">ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br><span class="hljs-comment">// 正确：从 int* 创建一个 unique_ptr&lt;int&gt;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p));<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以返回一个局部对象的拷贝</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span> <span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> (p))</span></span>;<br>    <span class="hljs-comment">//… </span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>向 unique_ptr 传递删除器</strong><br>unique_ptr 默认情况下用 delete 释放它指向的对象。<br>必须在尖括号中 unique_ptr 指向类型之后提供删除器类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;objT, delT&gt; <span class="hljs-title">p</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> objT, fun)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><p>weak_ptr 是一种不控制所指向对象生存期的智能指针。创建一个 weak_ptr 时，要用一个 shared_ptr 来初始化它。<br>由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须调用lock检查 weak_ptr 指向的对象是否仍存在。</p><h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><h3 id="12-2-1-new-和数组"><a href="#12-2-1-new-和数组" class="headerlink" title="12.2.1 new 和数组"></a>12.2.1 new 和数组</h3><p><strong>分配一个数组会得到一个元素类型的指针</strong><br>当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。<br>由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 或 end，也不能用范围 for。 </p><p><strong>动态分配一个空数组是合法的</strong><br>当我们用 new 分配一个大小为0的数组时，new 返回一个合法的非空指针。此指针保证与 new 返回的其他任何指针都不相同，但此指针不能解引用。</p><p><strong>释放动态数组</strong><br>销毁 p 指向的数组中的元素，并释放对应的内存，数组中的元素按逆序销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">delete</span> [] p; <span class="hljs-comment">// p 必须指向一个动态分配的数组或为空</span><br></code></pre></td></tr></table></figure><p><strong>智能指针和动态数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br>p.<span class="hljs-built_in">release</span> (); <span class="hljs-comment">// 自动用 delete [] 销毁其指针</span><br></code></pre></td></tr></table></figure><p>对于指向数组的 unique_ptr 我们不能使用点和箭头成员运算符，可以使用下标运算符来访问数组中的元素。<br>shared_ptr 不直接支持管理动态数组。如果希望使用 shared_ptr 管理一个动态数组，必须提供自己定义的删除器。<br>shared_ptr 未定义下标运算符，而且智能指针类型不支持指针算术运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i) &#123;<br>    *(sp.<span class="hljs-built_in">get</span>() + i) = i; <span class="hljs-comment">// 使用get获取一个内置指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-2-2-allocator-类"><a href="#12-2-2-allocator-类" class="headerlink" title="12.2.2 allocator 类"></a>12.2.2 allocator 类</h3><p>allocator 分配的内存是原始的、未构造的。construct 成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">allocator&lt;string&gt; alloc; <span class="hljs-comment">// 可以分配 string 的 allocator 对象</span><br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> p = alloc.<span class="hljs-built_in">allocate</span>(n); <span class="hljs-comment">// 分配 n 个未初始化的 string</span><br></code></pre></td></tr></table></figure><p>当我们用完对象后，必须对每个构造的元素调用 destroy 来销毁它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> q = p; <span class="hljs-comment">// q 指向最后构造的元素之后的位置</span><br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// *q 为 cccccccccc</span><br><span class="hljs-keyword">while</span> (q != p) &#123;<br>    alloc. <span class="hljs-built_in">destroy</span> (--q) ;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放内存通过调用 deallocate 来完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">alloc.<span class="hljs-built_in">deallocate</span>(p, n); <span class="hljs-comment">// n 就是 allocate(n) 时的大小</span><br></code></pre></td></tr></table></figure><h1 id="第十三章-拷贝控制"><a href="#第十三章-拷贝控制" class="headerlink" title="第十三章 拷贝控制"></a>第十三章 拷贝控制</h1><h2 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h2><h3 id="13-1-1-拷贝构造函数"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值， 则此构造函数是拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span> (<span class="hljs-type">const</span> Foo&amp;); <span class="hljs-comment">//拷贝构造函数</span><br>&#125;；<br></code></pre></td></tr></table></figure><p><strong>合成拷贝构造函数</strong><br>合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中，并且会逐元素地拷贝一个数组类型的成员。</p><h3 id="13-1-3-析构函数"><a href="#13-1-3-析构函数" class="headerlink" title="13.1.3 析构函数"></a>13.1.3 析构函数</h3><p>析构函数的名字由波浪号接类名构成，它没有返回值，不接受参数，也不能被重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    〜<span class="hljs-built_in">Foo</span>(); <span class="hljs-comment">//析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>析构函数完成什么工作</strong><br>在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。<br>成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。<br>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。与普通指针不同，智能指针成员在析构阶段会被自动销毁。</p><p><strong>什么时候会调用析构函数</strong><br>无论何时一个对象被销毁，就会自动调用其析构函数。<br>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</p><p><strong>合成析构函数</strong><br>析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。</p><h3 id="13-1-4-三-五法则"><a href="#13-1-4-三-五法则" class="headerlink" title="13.1.4 三&#x2F;五法则"></a>13.1.4 三&#x2F;五法则</h3><p><strong>需要析构函数的类也需要拷贝和赋值操作</strong><br>合成析构函数不会delete—个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。</p><p><strong>合成的拷贝构造函数和拷贝</strong><br>赋值运算符简单拷贝指针成员，这意味着多个指针可能指向相同的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HasPtr <span class="hljs-title">f</span> <span class="hljs-params">(HasPtr hp)</span> &#125; <span class="hljs-comment">// HasPtr 是传值参数，所以将被拷贝</span></span><br><span class="hljs-function">    HasPtr ret </span>= hp; <span class="hljs-comment">// 拷贝给定的 HasPtr</span><br>    <span class="hljs-keyword">return</span> ret;<span class="hljs-comment">// ret 和 hp 被销毁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当 f 返回时，hp 和 ret 都被销毁。此代码会导致此指针被 delete 两次，将要发生什么是未定义的。</p><p><strong>需要拷贝搡作的类也需要赋值操作，反之亦然</strong></p><h3 id="13-1-5-使用-default"><a href="#13-1-5-使用-default" class="headerlink" title="13.1.5 使用 &#x3D;default"></a>13.1.5 使用 &#x3D;default</h3><p>如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用 &#x3D;default。</p><h3 id="13-1-6-阻止拷贝-delete"><a href="#13-1-6-阻止拷贝-delete" class="headerlink" title="13.1.6 阻止拷贝 &#x3D;delete"></a>13.1.6 阻止拷贝 &#x3D;delete</h3><p>可以将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。我们虽然声明了删除的函数，但不能以任何方式使用它们。<br>与 &#x3D;default 不同，&#x3D;delete 必须出现在函数第一次声明的时候。</p><p><strong>析构函数不能是删除的成员</strong><br>对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。<br>如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。<br>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象。</p><p><strong>合成的拷贝控制成员可能是删除的</strong><br>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p><h2 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h2><p>通常，管理类外资源的类必须定义拷贝控制成员。</p><h3 id="13-2-1-行为像值的类"><a href="#13-2-1-行为像值的类" class="headerlink" title="13.2.1 行为像值的类"></a>13.2.1 行为像值的类</h3><p><strong>类值拷贝赋值运算符</strong><br>类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。<br>如果将一个对象赋予它自身，赋值运算符必须能正确工作。<br>大多数赋值运算符组合了析构函数和拷贝构造函数的工作，当右侧拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。</p><h3 id="13-2-2-定义行为像指针的类"><a href="#13-2-2-定义行为像指针的类" class="headerlink" title="13.2.2 定义行为像指针的类"></a>13.2.2 定义行为像指针的类</h3><p>令一个类展现类似指针的行为的最好方法是使用 shared_ptr 来管理类中的资源。</p><h2 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h2><p>在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。<br>使用移动而不是拷贝的另一个原因源于 IO 类或 unique_ptr 这样的类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型对象不能拷贝但可以移动。</p><h3 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h3><p>右值引用只能绑定到一个将要销毁的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r = i * <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确：我们可以将一个 const 的引用绑定到一个右值上</span><br><span class="hljs-type">int</span> &amp;&amp;rr = i * <span class="hljs-number">42</span>; <span class="hljs-comment">// 正确：将 rr 绑定到乘法结果上</span><br></code></pre></td></tr></table></figure><p><strong>左值持久；右值短暂</strong></p><ul><li>所引用的对象将要被销毁</li><li>该对象没有其他用户</li></ul><p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。</p><p><strong>变量是左值</strong><br>变量表达式都是左值，所以我们不能将一个右值引用绑定到一个右值引用类型的变量上。</p><p><strong>标准库 move 函数</strong><br>可以显式地将一个左值转换为对应的右值引用类型。<br>还可以通过调用一个名为 move 的新标准库函数来获得绑定到左值上的右值引用。<br>move 调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。<br>调用 move 就意味着承诺：除了对rrl赋值或销毁它外，我们将不再使用它，我们不能对移后源对象的值做任何假设。<br>我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p><h3 id="13-6-2-移动构造函数和移动赋值运算符"><a href="#13-6-2-移动构造函数和移动赋值运算符" class="headerlink" title="13.6.2 移动构造函数和移动赋值运算符"></a>13.6.2 移动构造函数和移动赋值运算符</h3><p>为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符，它们从给定对象“窃取”资源而不是拷贝资源。<br>移动构造函数的第一个参数是该类类型的一个右值引用，任何额外的参数都必须有默认实参。<br>移动构造函数还必须确保销毁移后源对象是无害的。一旦资源完成移动，源对象必须不再指向被移动的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">StrVec::<span class="hljs-built_in">StrVec</span> (StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span><br>:<span class="hljs-built_in">elements</span>(s.elements), <span class="hljs-built_in">first_free</span>(s.first_free), <span class="hljs-built_in">cap</span>(s.cap)<br>&#123;<br>    <span class="hljs-comment">// 令 s 进入这样的状态：对其运行析构函数是安全的</span><br>    s.elements = s.first_free = s.cap = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>移动操作、标准库容器和异常</strong><br>除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。<br>noexcept 是我们承诺一个函数不抛出异常的一种方法。在一个构造函数中，noexcept 出现在参数列表和初始化列表开始的冒号之间。<br>如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题：旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。<br>为了避免这种潜在问题，除非 vector 知道元素类型的移动构造函数不会抛出异常， 否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。如果希望在 vector 重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数（及移动赋值运算符）标记为 noexcept 来做到这一点。</p><p><strong>移动赋值运算符</strong><br>移动赋值运算符不抛出任何异常，移动赋值运算符必须正确处理自赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">StrVec StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-comment">// 直接检测自賦值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>        <span class="hljs-built_in">free</span>();<br>        elements = rhs.elements; <span class="hljs-comment">// 从 rhs 接管资源</span><br>        first_free = rhs.first_free;<br>        cap = rhs.cap;<br>        <span class="hljs-comment">// 将 rhs 置于可析构状态</span><br>        rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>移后源对象必须可析构</strong><br>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设</p><p><strong>合成的移动操作</strong><br>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。<br>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成 员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。<br>移动操作永远不会隐式定义为删除的函数，如果我们显式地要求编译器生成 &#x3D;default 的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。<br>如果类定义了一个移动构造函数和&#x2F;或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。</p><p><strong>移动右值，拷贝左值……</strong><br>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。</p><p><strong>……但如果没有移动构造函数，右值也被拷贝</strong><br>如果一个类有一个拷贝构造函数但未定义移动构造函数，编译器不会合成移动构造函数</p><p><strong>移动迭代器</strong><br>移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器，移动迭代器的解引用运算符生成一个右值引用。<br>通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。</p><h3 id="13-6-3-右值引用和成员函数"><a href="#13-6-3-右值引用和成员函数" class="headerlink" title="13.6.3 右值引用和成员函数"></a>13.6.3 右值引用和成员函数</h3><p><strong>右值和左值引用成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sl + s2 = <span class="hljs-string">&quot;wow!&quot;</span><br></code></pre></td></tr></table></figure><p>此处我们对两个 string 的连接结果（右值），进行了赋值。新标准库类仍然允许向右值赋值，阻止这种用法的方式是在参数列表后放置一个引用限定符。<br>引用限定符可以是 &amp; 或 &amp;&amp;，分别指出 this 可以指向一个左值或右值。类似 const 限定符, 引用限定符只能用于（非 static）成员函数，且必须同时出现在函数的声明和定义中。引用限定符必须跟随在 const 限定符之后。</p><p><strong>重载和引用函数</strong><br>如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加。</p><h1 id="第十四章-重载运算与类型转换"><a href="#第十四章-重载运算与类型转换" class="headerlink" title="第十四章 重载运算与类型转换"></a>第十四章 重载运算与类型转换</h1><h2 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h2><p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。<br>除了重载的函数调用运算符 operator() 之外，其他重载运算符不能含有默认实参。<br>如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的 this 指针上。<br>对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数，这意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。<br>我们无权发明新的运算符号。<br>重载的运算符的优先级和结合律与对应的内置运算符保持一致。</p><p><strong>某些运算符不应该被重载</strong><br>因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。</p><p><strong>选择作为成员或者非成员</strong></p><ul><li>赋值、下标、调用和成员访问箭头运算符必须是成员</li><li>复合赋值运算符一般来说应该是成员</li><li>改变对象状态的运算符或者与给定类型密切相关的运算符，通常应该是成员</li><li>具有对称性的运算符可能转换任意一端的运算对象，通常应该是普通的非成员函数</li></ul><p>当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。</p><h2 id="14-2-输入和输出运算符"><a href="#14-2-输入和输出运算符" class="headerlink" title="14.2 输入和输出运算符"></a>14.2 输入和输出运算符</h2><h3 id="14-2-1-重载输出运算符"><a href="#14-2-1-重载输出运算符" class="headerlink" title="14.2.1 重载输出运算符 &lt;&lt;"></a>14.2.1 重载输出运算符 &lt;&lt;</h3><p>输出运算符的第一个形参是一个非常量 ostream 对象的引用，第二个形参一般来说是一个常量的引用，一般要返回它的 ostream 形参。</p><p><strong>输入输出运算符必须是非成员函数</strong><br>否则它左侧的运算对象将是我们的类的一个对象。<br>IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元。</p><h3 id="14-2-2-重载输人运算符"><a href="#14-2-2-重载输人运算符" class="headerlink" title="14.2.2 重载输人运算符 &gt;&gt;"></a>14.2.2 重载输人运算符 &gt;&gt;</h3><p>常会返回某个给定流的引用。<br>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。<br>如果在发生错误前对象已经有一部分被改变，则适时地将对象置为合法状态显得异常重要。</p><h2 id="14-3-算术和关系运算符"><a href="#14-3-算术和关系运算符" class="headerlink" title="14.3 算术和关系运算符"></a>14.3 算术和关系运算符</h2><p>通常把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。<br>操作完成后返回该局部变量的副本作为其结果。<br>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</p><h3 id="14-3-1-相等运算符"><a href="#14-3-1-相等运算符" class="headerlink" title="14.3.1 相等运算符"></a>14.3.1 相等运算符</h3><p>相等运算符和不相等运算符中的一个应该把工作委托给另外一个。</p><h2 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h2><p>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p><h2 id="14-6-递增和递减运算符"><a href="#14-6-递增和递减运算符" class="headerlink" title="14.6 递增和递减运算符"></a>14.6 递增和递减运算符</h2><p><strong>定义前置递增&#x2F;递减运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">StrBlobPtrS <span class="hljs-keyword">operator</span>++(); <span class="hljs-comment">// 前置运算符</span><br></code></pre></td></tr></table></figure><p><strong>区分前置和后置运算符</strong><br>后置版本接受一个额外的（不被使用）int 类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为 0 的实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">StrBlobPtr <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>); <span class="hljs-comment">// 后置运算符</span><br></code></pre></td></tr></table></figure><p><strong>显式地调用后置运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p.<span class="hljs-keyword">operator</span>++(<span class="hljs-number">0</span>); <span class="hljs-comment">// 调用后置版本的 operator++</span><br></code></pre></td></tr></table></figure><h2 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrBlobPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::strings <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    std::string* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-comment">// 将实际工作委托给解引用运算符 </span><br>        <span class="hljs-keyword">return</span> &amp; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>*();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。</p><p><strong>对箭头运算符返回值的限定</strong><br>根据 point 类型的不同，point-&gt;mem 分别等价于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(*point).mem; <span class="hljs-comment">// point 是一个内置的指针类型</span><br>point.<span class="hljs-built_in">operator</span>()-&gt;mem;<span class="hljs-comment">// point 是类的一个对象</span><br></code></pre></td></tr></table></figure><p>如果 point 是定义了 operator-&gt; 的类的一个对象，则我们使用 point.operator-&gt;() 的结果来获取 mem。其中，如果该结果是一个指针，则执行 (*point).mem。如果该结果本身含有重载的 operator-&gt;()，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。</p><h2 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h2><p>可以像使用函数一样使用该类的对象。函数调用运算符必须是成员函数。如果类定义了调用运算符，则该类的对象称作函数对象。</p><h3 id="14-8-1-lambda-是函数对象"><a href="#14-8-1-lambda-是函数对象" class="headerlink" title="14.8.1 lambda 是函数对象"></a>14.8.1 lambda 是函数对象</h3><p>当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象，在 lambda 表达式产生的类中含有一个重载的函数调用运算符。</p><p><strong>表示 lambda 及相应捕获行为的类</strong><br>当一个 lambda 表达式通过引用捕获变量时，编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。<br>相反，通过值捕获的变量被拷贝到 lambda 中，这种类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。<br>lambda 表达式产生的类不含默认构造函数、赋值运算符及默认析构函数。它是否含有默认的拷贝&#x2F;移动构造函数则通常要视捕获的数据成员类型而定。</p><h3 id="14-8-3-可调用对象与-function"><a href="#14-8-3-可调用对象与-function" class="headerlink" title="14.8.3 可调用对象与 function"></a>14.8.3 可调用对象与 function</h3><p>两个不同类型的可调用对象却可能共享同一种调用形式。调用形式指明了调用返回的类型以及传递给调用的实参类型。</p><p><strong>标准库function类型</strong><br>当创建一个具体的 function 类型时我们必须提供该 function 类型能够表示的对象的调用形式，如：<br><code>function&lt;int(int, int)&gt;</code><br>function 类型重载了调用运算符，该运算符接受它自己的实参然后将其传递给存好的可调用对象:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; binops = &#123;<br>    &#123;<span class="hljs-string">&quot;*&quot;</span>, [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> i * j; &#125;&#125;<br>&#125;<br>binops[<span class="hljs-string">&quot;*&quot;</span>](<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 调用 lambda 对象</span><br></code></pre></td></tr></table></figure><p><strong>重载的函数与 function</strong><br>我们不能（直接）将重载函数的名字存入 function 类型的对象中，解决上述二义性问题的一条途径是存储函数指针，而非函数名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> i + j; &#125;<br><span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data&amp;, <span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<br>map&lt;string, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; binops;<br>binops.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;+&quot;</span>, add&#125;); <span class="hljs-comment">// 错误：哪个 add？</span><br><span class="hljs-built_in">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = add; <span class="hljs-comment">// 指针所指的 add 是接受两个 int 的版本</span><br>binops.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;+&quot;</span>, fp&#125;); <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><h2 id="14-9-重载、类型转换与运算符"><a href="#14-9-重载、类型转换与运算符" class="headerlink" title="14.9 重载、类型转换与运算符"></a>14.9 重载、类型转换与运算符</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换。</p><h3 id="14-9-1-类型转换运算符"><a href="#14-9-1-类型转换运算符" class="headerlink" title="14.9.1 类型转换运算符"></a>14.9.1 类型转换运算符</h3><p>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。<br><code>operator type() const;</code><br>不允许转换成数组或者函数类型，但允许转换成指针或者引用类型。<br>类型转换运算符既没有敁式的返回类型，也没有形参，而且必须定义成类的成员函数，一般被定义成 const 成员。</p><p><strong>显式的类型转换运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallInt</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//编译器不会自动执行这一类型转换</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br>&#125;；<br>SmallInt si = <span class="hljs-number">1</span>;<br>si + <span class="hljs-number">3</span>; <span class="hljs-comment">// 错误：此处需要隐式的类型转换，但类的运算符是显式的</span><br><span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(si) + <span class="hljs-number">3</span>; <span class="hljs-comment">// 正确：显式地请求类型转换</span><br></code></pre></td></tr></table></figure><p>该规定存在一个例外，即如果表达式被用作条件，显式的类型转换将被隐式地执行。</p><h1 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h1><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><p>基类通常都应该定义一个虚析构函数。</p><p><strong>成员函数与继承</strong><br>关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p><h3 id="15-2-2-定义派生类"><a href="#15-2-2-定义派生类" class="headerlink" title="15.2.2 定义派生类"></a>15.2.2 定义派生类</h3><p><strong>派生类中的虚函数</strong><br>派生类可以在它覆盖的函数前使用 virtual 关键字，但不是非得这么做。C++11 新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在后面添加一个关键字 override。</p><p><strong>派生类构造函数</strong><br>派生类必须使用基类的构造函数来初始化它的基类部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-type">const</span> std::string&amp; book, <span class="hljs-type">double</span> p, std::<span class="hljs-type">size_t</span> qty, <span class="hljs-type">double</span> disc) :<br>    <span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">min_qty</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123; &#125;<br>&#125;；<br></code></pre></td></tr></table></figure><p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p><p><strong>派生类使用基类的成员</strong><br>派生类的作用域嵌套在基类的作用域之内。<br>派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p><p><strong>继承与静态成员</strong><br>不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p><p><strong>派生类的声明</strong><br>声明中包含类名但是不包含它的派生列表，派生列表以及与定义有关的其他细节必须与类的主体一起出现。</p><p><strong>被用作基类的类</strong><br>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p><p><strong>防止继承的发生</strong><br>C++11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final。</p><h3 id="15-2-3-类型转换与继承"><a href="#15-2-3-类型转换与继承" class="headerlink" title="15.2.3 类型转换与继承"></a>15.2.3 类型转换与继承</h3><p><strong>静态类型与动态类型</strong><br>动态类型直到运行时才可知。如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p><p><strong>不存在从基类向派生类的隐式类型转换……</strong><br>如果我们己知某个基类向派生类的转换是安全的，则我们可以使用 static_cast 来强制覆盖掉编译器的检查工作。</p><p><strong>……在对象之间不存在类型转换</strong><br>派生类向基类的自动类型转换只对指针或引用类型有效。<br>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p><h2 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h2><p>当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定，因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。</p><p><strong>对虚函数的调用可能在运行时才被解析</strong><br>被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p><p><strong>派生类中的虚函数</strong><br>一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。<br>派生类中虚函数的返回类型必须与基类函数匹配。当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。<br>基类的虚函数在派生类中隐含的也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p><p><strong>final 和 override 说明符</strong><br>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。<br>在 C++11 新标准中我们可以使用 override 关键字来说明派生类中的虚函数，使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误。<br>final 和 override 说明符出现在形参列表以及尾置返冋类型之后。</p><p><strong>虚函数与默认实参</strong><br>如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p><p><strong>回避虚函数的机制</strong><br>在某些情况下，我们希望强制执行虚函数的某个特定版本，使用作用域运算符可以实现这一目的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> undiscounted = baseP-&gt;Quote::<span class="hljs-built_in">net_price</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>该代码强行调用 Quote 的 net_price 函数，而不管 baseP 实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p><h2 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h2><p><strong>纯虚函数</strong><br>一个纯虚函数无须定义，我们通过在函数体的位置书写 &#x3D;0 就可以将一个虚函数说明为纯虚函数。&#x3D;0 只能出现在类内部的虚函数声明语句处。<br>我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。</p><p><strong>含有纯虚函数的类是抽象基类</strong><br>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类。我们不能（直接）创建一个抽象基类的对象。</p><h2 id="15-5-访问控制与继承"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承</h2><p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。<br>派生类的成员的友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类对象中的成员没有特殊的访问权限。</p><p><strong>公有、私有和受保护继承</strong><br>派生类访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。派生类访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限，以及继承自派生类的新类的访问权限。</p><p><strong>派生类向基类转换的可访问性</strong><br>假定 D 继承自 B：</p><ul><li>只有当 D 公有地继承 В 时，用户代码才能使用派生类向基类的转换。</li><li>不论 D 以什么方式继承 B, D 的成员函数和友元都能使用派生类向基类的转换。</li><li>如果 D 继承 В 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 В 的类型转换。</li></ul><p><strong>友元与继承</strong><br>友元关系同样也不能继承， 基类的友元在访问派生类成员时不具有特殊性。<br>对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此。</p><p><strong>改变个别成员的可访问性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::<span class="hljs-type">size_t</span> n;<br>&#125;；<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">private</span> Base &#123; <span class="hljs-comment">// 注意：private 继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::n;<br>&#125;；<br></code></pre></td></tr></table></figure><p>using 声明语句中名字的访问权限由该 using 声明语句之前的访问说明符来决定。<br>using 只影响派生类的使用者对基类成员的访问权限，派生类只能为那些它可以访问的名字提供 using 声明。</p><h2 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h2><p>派生类的作用域嵌套在其基类的作用域之内，如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。</p><p><strong>在编译时进行名字查找</strong><br>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。不能通过基类对象&#x2F;指针&#x2F;引用（静态类型）调用派生类（动态类型）独有的成员。</p><p><strong>名字冲突与继承</strong><br>定义在内层作用域的名字将隐藏定义在外层作用域的名字。</p><p><strong>通过作用域运算符来使用隐藏的成员</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_base_mem</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Base::mem; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用域运算符将覆盖掉原有的查找规则，并指示编译器从 Base 类的作用域开始查找 men。</p><p><strong>名字查找先于类型检查</strong></p><p><strong>虚函数与作用域</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D1</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 隐藏基类的 fun1()，这个 fun1() 不是虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 一个新的虚函数</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D2</span> : <span class="hljs-keyword">public</span> D1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 非虚函数，隐藏了 D1::fun1(int)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 覆盖了 Base 的虚函数 fun1()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 覆盖了 D1 的虚函数 fun2()</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过基类调用隐藏的虚函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">D2 d2;<br>Base *p1 = &amp;d2; D1 *p2 = &amp;d2; D2 *p3 = &amp;d2;<br>p1-&gt;<span class="hljs-built_in">fun1</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 错误，Base 中没有接受一个 int 的 fun1</span><br>p2-&gt;<span class="hljs-built_in">fun1</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 静态绑定，调用 D1::fun1(int)</span><br>p3-&gt;<span class="hljs-built_in">fun1</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 静态绑定，调用 D2::fun1(int)</span><br></code></pre></td></tr></table></figure><p><strong>覆盖重载的函数</strong><br>如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。<br>一种好的解决方案是为重载的成员提供一条 using 声明语句。using 声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的 using 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了。</p><h2 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h2><h3 id="15-7-1虚析构函数"><a href="#15-7-1虚析构函数" class="headerlink" title="15.7.1虚析构函数"></a>15.7.1虚析构函数</h3><p>我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。<br>一个基类总是需要析构函数，而且它能将析构函数设定为虚函数，但是无法由此推断该基类还需要赋值运算符或拷贝构造函数。</p><p><strong>虚析构函数将阻止合成移动操作</strong><br>如果一个类定义了析构函数，即使它通过 &#x3D;default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p><h3 id="15-7-2-合成拷贝控制与继承"><a href="#15-7-2-合成拷贝控制与继承" class="headerlink" title="15.7.2 合成拷贝控制与继承"></a>15.7.2 合成拷贝控制与继承</h3><p><strong>派生类中删除的拷贝控制与基类的关系</strong></p><ul><li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的。</li><li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的。</li></ul><h3 id="15-7-3-派生类的拷贝控制成员"><a href="#15-7-3-派生类的拷贝控制成员" class="headerlink" title="15.7.3 派生类的拷贝控制成员"></a>15.7.3 派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。<br>析构函数只负责销毁派生类自己分配的资源。</p><p><strong>定义派生类的拷贝或移动构造函数</strong><br>当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-comment">/*...*/</span> &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认情况下，基类的默认构造函数初始化对象的基类部分</span><br>    <span class="hljs-comment">// 要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中显式地调用该构造函数</span><br>    <span class="hljs-built_in">D</span>(<span class="hljs-type">const</span> D&amp; d) : <span class="hljs-built_in">Base</span>(d)&#123;&#125; <span class="hljs-comment">// 拷贝基类成员</span><br>    <span class="hljs-built_in">D</span>(D&amp;&amp; d) : <span class="hljs-built_in">Base</span>(std::<span class="hljs-built_in">move</span>(d)) &#123;&#125; <span class="hljs-comment">// 移动基类成员</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>如果我们想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷或移动构造函数。</p><p><strong>派生类赋值运算符</strong><br>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">D &amp;D::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> D &amp;rhs) &#123;<br>    Base::<span class="hljs-keyword">operator</span>=(rhs); <span class="hljs-comment">// 为基类部分賦值</span><br>    <span class="hljs-comment">// 按照过去的方式为派生类的成员赋值，酌情处理自赋值及释放已有资源等情况</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在构造函数和析构函数中调用虚函数</strong><br>当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。销毁派生类对象的次序正好相反，当执行基类的析构函数时，派生类部分已经被销毁掉了。<br>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p><h3 id="15-7-4-继承的构造函数"><a href="#15-7-4-继承的构造函数" class="headerlink" title="15.7.4 继承的构造函数"></a>15.7.4 继承的构造函数</h3><p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的 using 声明语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span> : <span class="hljs-keyword">public</span> Disc_quote &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Disc_quote::Disc_quote; <span class="hljs-comment">// 继承 Disc_quote 的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。在我们的 Bulk_quote 类中，继承的构造函数等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-type">const</span> std::strings book, <span class="hljs-type">double</span> price, std::<span class="hljs-type">size_t</span> qty, <span class="hljs-type">double</span> disc):<br>    <span class="hljs-built_in">Disc_quote</span>(book, price, qty, disc) &#123; &#125;<br></code></pre></td></tr></table></figure><p><strong>继承的构造函数的特点</strong><br>一个构造函数的 using 声明不会改变该构造函数的访问级别。一个 using 声明语句不能指定 explicit 或 constexpr。如果基类的构造函数是 explicit 或者 constexpr，则继承的构造函数也拥有相同的属性。<br>当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分別省略掉一个含有默认实参的形参。<br>如果派生类定义的构造函数与基类的构造函数具有相问的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。<br>默认、拷贝和移动构造函数不会被继承。如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。</p><h2 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承</h2><p>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。</p><p><strong>在容器中放置（智能）指针而非对象</strong><br>当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针。</p><h1 id="第十六章-模板与泛型编程"><a href="#第十六章-模板与泛型编程" class="headerlink" title="第十六章 模板与泛型编程"></a>第十六章 模板与泛型编程</h1><h2 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h2><h3 id="16-1-1-函数模板"><a href="#16-1-1-函数模板" class="headerlink" title="16.1.1 函数模板"></a>16.1.1 函数模板</h3><p><strong>模板类型参数</strong><br>类型参数前必须使用关键字 class 或 typename</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U</span>&gt; <span class="hljs-built_in">calc</span> (<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> U&amp;);<br><span class="hljs-comment">// 正确：在模板参数列表中，typename 和 class 没有什么不同</span><br></code></pre></td></tr></table></figure><p><strong>非类型模板参数</strong><br>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> N, <span class="hljs-type">unsigned</span> M&gt;</span><br><span class="hljs-function">    <span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;pl)[N], <span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p2)[M])</span></span><br><span class="hljs-function">        <span class="hljs-keyword">return</span> <span class="hljs-title">strcrap</span><span class="hljs-params">(p1, p2)</span></span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当我们调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-string">&quot;mom&quot;</span>)<br></code></pre></td></tr></table></figure><p>时，编译器会使用字面常量的大小来代替 N 和 M，从而实例化模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;pl)[<span class="hljs-number">3</span>], <span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;p2)[<span class="hljs-number">4</span>])</span></span><br></code></pre></td></tr></table></figure><p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。针参数也可以用 nullptr 或一个值为 0 的常量表达式来实例化。</p><p><strong>模板编译</strong><br>编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。<br>函数模板和类模板成员函数的定义通常放在头文件中。</p><p><strong>大多数编译错误在实例化期间报告</strong><br>通常，编译器会在三个阶段报告错误：</p><ul><li>第一个阶段是编译模板本身时。在这个阶段编译器可以检查语法错误。</li><li>第二个阶段是编译器遇到模板使用时。在此阶段编译器通常会检查实参数目是否正确，它还能检查参数类型是否匹配。</li><li>第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li></ul><h3 id="16-1-2-类模板"><a href="#16-1-2-类模板" class="headerlink" title="16.1.2 类模板"></a>16.1.2 类模板</h3><p>编译器不能为类模板推断模板参数类型。</p><p><strong>实例化类模板</strong><br>一个类模板的每个实例都形成一个独立的类。类型<code>Blob&lt;string&gt;</code>与任何其他 Blob 类型都没有关联。</p><p><strong>在模板作用域中引用模板类型</strong><br>类模板的名字不是一个类型名，类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。</p><p><strong>类模板的成员函数</strong><br>定义在类模板之外的成员函数就必须以关键字 template 开始，后接类模板参数列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    ret_type class_name&lt;T&gt;::<span class="hljs-built_in">member_name</span>(parm_list)<br></code></pre></td></tr></table></figure><p><strong>类模板成员函数的实例化</strong><br>对于一个实例化了的类模板，其成员只有在使用时才被实例化。</p><p><strong>在类代码内简化模板类名的使用</strong><br>当我们使用一个类模板类型时必须提供模板实参，但是在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p><p><strong>一对一友好关系</strong><br>类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlobPtr</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blob</span> &#123;<br>    <span class="hljs-comment">//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlobPtr</span>&lt;T&gt;;<br>&#125;;<br><br>Blob&lt;<span class="hljs-type">char</span>&gt; ca; <span class="hljs-comment">// BlobPtr&lt;char&gt; 是本对象的友元</span><br></code></pre></td></tr></table></figure><p>BlobPtr<char> 的成员可以访问任何其他 Blob<char> 对象的非 public 部分，但 ca 对 Blob 的任何其他实例都没有特殊访问权限。</p><p><strong>通用和特定的模板友好关系</strong><br>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pal</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123; <span class="hljs-comment">// C 是一个普通的非模板类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pal</span>&lt;C&gt;; <span class="hljs-comment">// 用类 C 实例化的 Pal 是 C 的一个友元</span><br>    <span class="hljs-comment">// Ра12 的所有实例都是 С 的友元，这种情况无须前置声明</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pal2</span>;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span> &#123; <span class="hljs-comment">// C2 本身是一个类模板</span><br>    <span class="hljs-comment">// C2 的每个实例将相同实例化的 Pal 声明为友元</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pal</span>&lt;T&gt;; <span class="hljs-comment">// Pal 的模板声明必须在作用域之内</span><br>    <span class="hljs-comment">// Pal2 的所有实例都是 C2 的每个实例的友元，不需要前置声明</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pal2</span>;<br>    <span class="hljs-comment">// Pal3 是一个非模板类，它是 C2 所有实例的友元</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pal3</span>; <span class="hljs-comment">// 不需要 Pal3 的前置声明</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>令模板自己的类型参数成为友元</strong><br>我们可以将模板类型参数声明为友元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-keyword">friend</span> Type; <span class="hljs-comment">// 将访问权限授予用来实例化Bar的类型</span><br>    <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对于某个类型名 Name，Name 将成为 Bar<name> 的友元。</p><p><strong>模板类型别名</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> Blob&lt;string&gt; StrBlob;<br></code></pre></td></tr></table></figure><p>新标准允许我们为类模板定义一个类型别名:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> twin = pair&lt;T, T&gt;;<br>twin&lt;string&gt; authors; <span class="hljs-comment">// authors 是一个 pair&lt;string, string&gt;</span><br></code></pre></td></tr></table></figure><p>当我们定义一个模板类型别名时，可以固定一个或多个模板参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> partNo = pair&lt;T, <span class="hljs-type">unsigned</span>&gt;;<br>partNo&lt;string&gt; books; <span class="hljs-comment">// books 是一个 pair&lt;string, unsigned&gt;</span><br></code></pre></td></tr></table></figure><p><strong>类模板的 static 成员</strong><br>每个实例都有其自己的 static 成员实例。<br>模板类的每个static 数据成员必须有且仅有一个定义。但是，类模板的每个实例都有一个独有的 static 对象。因此，与定义模板的成员函数类似，我们将 static 数据成员也定义为模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">size_t</span> Foo&lt;T&gt;::ctr = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义并初始化 ctr</span><br></code></pre></td></tr></table></figure><p>为了通过类来直接访问 static 成员，我们必须引用一个特定的实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Foo&lt;<span class="hljs-type">int</span>&gt; fi; <br><span class="hljs-keyword">auto</span> ct = Foo&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">count</span>(); <span class="hljs-comment">// 实例化 Foo&lt;int&gt;::count</span><br>ct = fi.<span class="hljs-built_in">count</span>(); <span class="hljs-comment">// 使用 Foo&lt;int&gt;::count</span><br>ct = Foo::<span class="hljs-built_in">count</span>(); <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><h3 id="16-1-3-模板参数"><a href="#16-1-3-模板参数" class="headerlink" title="16.1.3 模板参数"></a>16.1.3 模板参数</h3><p>我们通常将类型参数命名为 T，但实际上我们可以使用任何名字。</p><p><strong>模板参数与作用域</strong><br>模板参数会隐藏外层作用域中声明的相同名字。但是在模板内不能重用模板参数名。</p><p><strong>模板声明</strong><br>声明中的模板参数的名字不必与定义中相同。<br>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</p><p><strong>使用类的类型成员</strong><br>假定 T 是一个模板类型参数，当编译器遇到类似 T::mem 这样的代码时，它不会知道 mem 是一个类型成员还是一个 static 数据成员，直至实例化时才会知道。<br>默认情况下，C++ 假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，通过使用关键字 typename 来实现这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">typename</span> T::value_type <span class="hljs-title">top</span> <span class="hljs-params">(<span class="hljs-type">const</span> T&amp; c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typename</span> T::<span class="hljs-built_in">value_type</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们希望通知编译器一个名字表示类型时，必须使用关键字 typename，而不能使用 class。</p><p><strong>默认模板实参</strong><br>与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时, 它才可以有默认实参。</p><p><strong>模板默认实参与类模板</strong><br>如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。</p><h3 id="16-1-4-成员模板"><a href="#16-1-4-成员模板" class="headerlink" title="16.1.4 成员模板"></a>16.1.4 成员模板</h3><p>成员模板不能是虚函数。</p><p><strong>类模板的成员模板</strong><br>当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 类的类型参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt; <span class="hljs-comment">// 构造函数的类型参數</span><br>    Blob&lt;T&gt;::<span class="hljs-built_in">Blob</span>(It b, It e) :<br>        <span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="16-1-5-控制实例化"><a href="#16-1-5-控制实例化" class="headerlink" title="16.1.5 控制实例化"></a>16.1.5 控制实例化</h3><p>在多个文件中实例化相同模板的额外开销可能非常严重，我们可以通过显式实例化来避免这种开销。<br>当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。extern 声明必须出现在任何使用此实例化版本的代码之前。<br>实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个（非extern）的定义。<br>当编译器遇到一个实例化定义时，它为其生成代码。<br>实例化定义会实例化所有成员。</p><h3 id="16-2-2-函数模板显式实参"><a href="#16-2-2-函数模板显式实参" class="headerlink" title="16.2.2 函数模板显式实参"></a>16.2.2 函数模板显式实参</h3><p><strong>指定显式模板实参</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 编译器无法推断T1，它未出现在函数参数列表中</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tl, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;<br><span class="hljs-function">T1 <span class="hljs-title">sum</span><span class="hljs-params">(T2, T3)</span></span>;<br></code></pre></td></tr></table></figure><p>没有任何函数实参的类型可用米推断 Tl 的类型。毎次调用 sum 时调用者都必须为 T1 提供一个显式模板实参:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// T1 是显式指定的，T2 和 T3 是从函数实参类型推断而来的</span><br><span class="hljs-keyword">auto</span> val3 = <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(i, lng); <span class="hljs-comment">// long long sum(int, long)</span><br></code></pre></td></tr></table></figure><p>显式模板实参按由左至右的顺序与对应的模板参数匹配，只有尾部（最右）参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 糟糕的设计：用户必须指定所有三个模板参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tl, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;<br><span class="hljs-function">T3 <span class="hljs-title">alternative_sum</span><span class="hljs-params">(T2, Tl)</span></span>;<br><span class="hljs-keyword">auto</span> val2 = <span class="hljs-built_in">alternative_sum</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>, <span class="hljs-type">long</span>&gt;(i, lng);<br></code></pre></td></tr></table></figure><p><strong>正常类型转换应用于显式指定的实参</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> lng;<br><span class="hljs-built_in">compare</span> (lng, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 错误：模板参数不匹配</span><br><span class="hljs-built_in">compare</span>&lt;<span class="hljs-type">long</span>&gt; (lng, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 正确：实例化 compare (long, long)</span><br><span class="hljs-built_in">compare</span>&lt;<span class="hljs-type">int</span>&gt; (lng, <span class="hljs-number">1024</span>); <span class="hljs-comment">// 正确：实例化 compare (int, int)</span><br></code></pre></td></tr></table></figure><h3 id="16-2-3-尾置返回类型与类型转换"><a href="#16-2-3-尾置返回类型与类型转换" class="headerlink" title="16.2.3 尾置返回类型与类型转换"></a>16.2.3 尾置返回类型与类型转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br>??? &amp;<span class="hljs-built_in">fcn</span>(It beg, It end) &#123;<br>    <span class="hljs-keyword">return</span> *beg; <span class="hljs-comment">// 返回序列中一个元素的引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在编译器遇到函数的参数列表之前，beg 都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 尾置返回允许我们在参数列表之后声明返回类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn</span> <span class="hljs-params">(It beg, It end)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *beg; <span class="hljs-comment">// 返回序列中一个元素的引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进行类型转换的标准库模板类</strong><br>为了获得元素类型，我们可以使用标准库的类型转换模板。remove_reference 模板有一个模板类型参数和一个名为 type 的 public 类型成员。如果我们用一个引用类型实例化 remove_reference，则 type 将表示被引用的类型。<br><code>decltype(*beg)</code>返回元素类型的引用类型。<code>remove_reference::type</code>脱去引用，剩下元素类型本身。<br>组合使用 remove_reference、尾置返冋及 decltype，我们就可以在函数中返回元素值的拷贝：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 为了使用模板参数的成员，必须用 typename</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">fcn2</span><span class="hljs-params">(It beg, It end)</span>-&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">typename</span> remove_reference&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(*beg)</span>&gt;::type </span>&#123;<br>        <span class="hljs-keyword">return</span> *beg; <span class="hljs-comment">// 返回序列中一个元素的拷贝</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>注意：type 是一个类的成员，而该类依赖于一个模板函数。因此我们必须在返回类型的声明中使用 typename 告知编译器，type 表示一个类型。</p><h3 id="16-2-4-函数指针和实参推断"><a href="#16-2-4-函数指针和实参推断" class="headerlink" title="16.2.4 函数指针和实参推断"></a>16.2.4 函数指针和实参推断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;, <span class="hljs-type">const</span> T&amp;)</span></span>;<br><span class="hljs-built_in">int</span> (*pfl)(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;) = compare;<br><span class="hljs-comment">// pfl 指向实例 int compare (const int&amp;, const int&amp;)</span><br></code></pre></td></tr></table></figure><p>pfl 中参数的类型决定了 T 的模板实参的类型。在本例中，T 的模板实参类型为 int。指针 pfl 指向 compare 的 int 版本实例。<br>当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型或值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// func 的重载版本，每个版本接受一个不同的函数指针类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>(*)(<span class="hljs-type">const</span> strings, <span class="hljs-type">const</span> strings))</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>(*)(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;))</span></span>;<br><span class="hljs-built_in">func</span>(compare); <span class="hljs-comment">// 错误：使用 compare 的哪个实例？</span><br><span class="hljs-built_in">func</span>(compare&lt;<span class="hljs-type">int</span>&gt;); <span class="hljs-comment">// 正确：显式指出实例化哪个 compare 版本</span><br><span class="hljs-comment">// 传递 compare (const int&amp;, const int&amp;)</span><br></code></pre></td></tr></table></figure><h3 id="16-2-5-模板实参推断和引用"><a href="#16-2-5-模板实参推断和引用" class="headerlink" title="16.2.5 模板实参推断和引用"></a>16.2.5 模板实参推断和引用</h3><p><strong>从左值引用函数参数推断类型</strong><br>当一个函数参数是模板类型参数的一个普通（左值）引用时，只能传递给它一个左值，如果实参是 const 的，则 T 将被推断为 const 类型。<br>如果一个函数参数的类型是 const T&amp;，当函数参数本身是 const 时，T 的类型推断的结果不会是一个 const 类型。</p><p><strong>引用折叠和右值引用参数</strong><br>当我们将一个左值（i）传递给函数的右值引用参数，且此右值引用指向模板类型参数（T&amp;&amp;）时，编译器推断模板类型参数为实参的左值引用类型。因此，当我们调用 f3(i) 时，编译器推断 T 的类型为 int&amp;，而非 int。<br>这好像意味着 f3 的函数参数应该是一个类型 int&amp; 的右值引用。通常，我们不能（直接）定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。<br>如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。除了右值引用的右值引用会折叠为一个右值引用，其余情况都会折叠为一个普通的左值引用类型。<br>这两个规则暗示，我们可以将任意类型的实参传递给 T&amp;&amp; 类型的函数参数。</p><h3 id="16-2-6-理解-std-move"><a href="#16-2-6-理解-std-move" class="headerlink" title="16.2.6 理解 std::move"></a>16.2.6 理解 std::move</h3><p><strong>从一个左值 static_cast 到一个右值引用是允许的</strong><br>可以用 static_cast 显式地将一个左值转换为一个右值引用。</p><h3 id="16-2-7-转发"><a href="#16-2-7-转发" class="headerlink" title="16.2.7 转发"></a>16.2.7 转发</h3><p><strong>定义能保持类型信息的函数参数</strong><br>如果一个函数参数是指向模板类型参数的右值引用（如T&amp;&amp;），它对应的实参的 const 属性和左值&#x2F;右值属性将得到保持。</p><p><strong>在调用中使用 std::forward 保持类型信息</strong><br>forward 返回该显式实参类型的右值引用即，forward<T> 的返回类型是 T&amp;&amp;。通过其返回类型上的引用折叠，forward 可以保持给定实参的左值&#x2F;右值属性。<br>当用于一个指向模板参数类型的右值引用函数参数（T&amp;&amp;）时，forward 会保持实参类型的所有细节。</p><h2 id="16-4-可变参数模板"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板</h2><p>可变数量的参数被称为参数包，我们用一个省略号来指出一个模板参数或函数参数表示一个包。<br>在一个模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表。一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Args 是一个模板参数包，rest 是一个函数参数包</span><br><span class="hljs-comment">// Args 表示零个或多个模板类型参数</span><br><span class="hljs-comment">// rest 表示零个或多个函数参数</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span> <span class="hljs-params">(<span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp; ... rest)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>sizeof… 运算符</strong><br>当我们需要知道包中有多少元素时，可以使用 sizeof… 运算符。sizeof…返回一个常量表达式，而且不会对其实参求值。</p><h3 id="16-4-1-编写可变参数函数模板"><a href="#16-4-1-编写可变参数函数模板" class="headerlink" title="16.4.1 编写可变参数函数模板"></a>16.4.1 编写可变参数函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp;... rest)</span> </span>&#123;<br>    os « t « <span class="hljs-string">&quot;, &quot;</span>；<span class="hljs-comment">// 打印第一个实参</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span> (os, rest...);<span class="hljs-comment">// 递归调用，打印其他实参</span><br>)<br></code></pre></td></tr></table></figure><p>rest 中的第一个实参被绑定到 t，剩余实参形成下一个 print 调用的参数包。</p><h3 id="16-4-2-包扩展"><a href="#16-4-2-包扩展" class="headerlink" title="16.4.2 包扩展"></a>16.4.2 包扩展</h3><p>当扩展一个包时，我们还要提供用于每个扩展元素的模式。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边放一个省略号来触发扩展操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp;... rest)</span> </span>&#123; <span class="hljs-comment">// 扩展 Args</span><br>    os « t &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, rest...);<span class="hljs-comment">// 扩展 rest</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对 Args 的扩展中，编译器将模式 const Arg&amp; 应用到模板参数包 Args 中的每个元素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如 const type&amp;。<br>第二个扩展发生在对 print 的调用中。在此情况下，模式是函数参数包的名字（即 rest)。此模式扩展出一个由包中元素组成的、逗号分隔的列表。因此，这个调用等价于：</p><p><strong>理解包扩展</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, <span class="hljs-built_in">debug_rep</span>(rest)...);<br></code></pre></td></tr></table></figure><p>这个 print 调用使用了模式 debug_reg(rest)。此模式表示我们希望对函数参数包 rest 中的每个元素调用 debug_rep。扩展结果将是一个逗号分隔的 debug_rep 调用列表。即，下面调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">errorMsg</span>(cerr, fcnName, code.<span class="hljs-built_in">num</span>(), otherData, <span class="hljs-string">&quot;other&quot;</span>, item);<br></code></pre></td></tr></table></figure><p>就好像我们这样编写代码一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">print</span> (cerr, <span class="hljs-built_in">debug_rep</span>(fcnName), <span class="hljs-built_in">debug_rep</span>(code.<span class="hljs-built_in">num</span>()),<br>    <span class="hljs-built_in">debug_rep</span>(otherData), <span class="hljs-built_in">debug_rep</span>(<span class="hljs-string">&quot;otherData&quot;</span>), <span class="hljs-built_in">debug_rep</span>(item));<br></code></pre></td></tr></table></figure><h2 id="16-5-模板特例化"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化</h2><p>一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。</p><p><strong>定义函数模板特例化</strong><br>当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字 template 后跟一个空尖括号对，指出我们将为原模板的所有模板参数提供实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// compare 的特殊版本，处理字符数组的指针</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;pl, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp;p2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(pi, p2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数重载与模板特例化</strong><br>当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。一个特例化版本本质上是一个实例，而非函数名的一个重载版本。<br>特例化不影响函数匹配。<br>为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模扳实例的代码之前，特例化版本的声明也必须在作用域中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>光栅化软渲 Simple Renderer</title>
    <link href="/2021/11/08/SimpleRenderer/"/>
    <url>/2021/11/08/SimpleRenderer/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>一个用 C++ 编写的简单的光栅化软渲染器，没想好起什么名字，不如就叫 Simple Renderer 吧。主要还是为了巩固一下图形学相关的基础知识，毕竟有很多问题不实际上手是不会遇到的。</p><p>基础库的选择：我不想将注意力放在渲染管线以外的部分上，所以数学和显示的部分直接使用了 Eigen 和 EasyX。<strong>Eigen</strong> 是一个非常优秀的线性代数库，<strong>EasyX</strong> 是一个足够轻便又不至于太过底层的图形库。当然我只允许自己使用其中的 putpixel() 函数。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>Bresenham 画线法</li><li>扫描线算法光栅化三角形</li><li>重心坐标插值</li><li>透视矫正插值</li><li>mvp、viewport 投影矩阵</li><li>深度测试</li><li>背面剔除</li><li>Blinn-Phong 光照模型</li><li>Diffuse 贴图</li><li>高光贴图</li><li>法线贴图</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>顶点数据封装在 Vertex 类中。投影变换在 VertexShader 类中实现。光栅化与片元着色器耦合在 Rasterizer。</p><h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/SimpleRenderer/1.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/2.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/3.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/5.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/SimpleRenderer/7.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/8.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/9.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/10.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/SimpleRenderer/11.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/12.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/13.png"></div><div class="group-image-wrap"><img src="/img/SimpleRenderer/14.png"></div></div></div><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p><a href="https://github.com/Hinageshi01/simpleRenderer">GitHub</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/ssloy/tinyrenderer">tinyrenderer</a><br><a href="http://games-cn.org/forums/topic/%e4%bd%9c%e4%b8%9a3%e6%9b%b4%e6%ad%a3%e5%85%ac%e5%91%8a/">GAMES101 Assignment3</a></p><h2 id="透视矫正插值"><a href="#透视矫正插值" class="headerlink" title="透视矫正插值"></a>透视矫正插值</h2><p>具体的推导在 <a href="https://blog.csdn.net/n5/article/details/100148540">CSDN</a> 和 <a href="https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf">lowk_persp_interp_techrep</a> 里已经讲的很清楚了。<br>重要的结论是：</p><ul><li>在投影面上对属性 $I$ 插值时，先对 $\frac{I}{Z}$ 插值，然后将结果除以对 $\frac{1}{Z}$ 插值的结果。这样就得到了透视正确的属性插值。</li></ul><p>这里是 OpenGL 和我的渲染器里的实现：<br><a href="https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation">StackOverflow</a><br>首先，ClipSpace 中的 w 分量等于 ViewSpace 中的 z 分量（符号由左右手坐标系决定，这将影响到后续的深度测试）。<br>然后将 ClipSpace 的 1&#x2F;w 分量保存起来，避免多次的除法运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Eigen::Vector4f p = mvp * vertex[i].pos;<br>p[<span class="hljs-number">3</span>] = <span class="hljs-number">1.f</span> / p[<span class="hljs-number">3</span>];<br>p[<span class="hljs-number">0</span>] *= p[<span class="hljs-number">3</span>];<br>p[<span class="hljs-number">1</span>] *= p[<span class="hljs-number">3</span>];<br>p[<span class="hljs-number">2</span>] *= p[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>然后将重心坐标 (a, b, c) 调整为：<br>$(a,b,c)&#x3D;\frac{(a&#x2F;pos[0].w, b&#x2F;pos[1].w, c&#x2F;pos[2].w)}{a&#x2F;pos[0].w+b&#x2F;pos[1].w+c&#x2F;pos[2].w}$<br>这里的 w 就是 ViewSpace 的 z ，这个很长的分母就是所谓对 $\frac{1}{Z}$ 插值的结果，三个分子就是将 $I$ 提出后剩余的部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在投影平面上求得透视不正确的重心坐标。</span><br>Eigen::Vector3f tmpBC = <span class="hljs-built_in">BarycentricCoor</span>(x + <span class="hljs-number">0.5f</span>, y + <span class="hljs-number">0.5f</span>, v);<br><span class="hljs-comment">// pos[3] 存储的是 ViewSpace 中的 1/z。</span><br><span class="hljs-type">float</span> a = tmpBC[<span class="hljs-number">0</span>] * v[<span class="hljs-number">0</span>].pos[<span class="hljs-number">3</span>];<br><span class="hljs-type">float</span> b = tmpBC[<span class="hljs-number">1</span>] * v[<span class="hljs-number">1</span>].pos[<span class="hljs-number">3</span>];<br><span class="hljs-type">float</span> c = tmpBC[<span class="hljs-number">2</span>] * v[<span class="hljs-number">2</span>].pos[<span class="hljs-number">3</span>];<br><span class="hljs-type">float</span> div = <span class="hljs-number">1.f</span> / (a + b + c);<br>a *= div;<br>b *= div;<br>c *= div;<br><span class="hljs-comment">// 重心坐标插值。</span><br><span class="hljs-type">float</span> z = <span class="hljs-built_in">Interpolate</span>(a, b, c, v[<span class="hljs-number">0</span>].pos[<span class="hljs-number">2</span>], v[<span class="hljs-number">1</span>].pos[<span class="hljs-number">2</span>], v[<span class="hljs-number">2</span>].pos[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><h2 id="切线空间与法线贴图"><a href="#切线空间与法线贴图" class="headerlink" title="切线空间与法线贴图"></a>切线空间与法线贴图</h2><p>推导：<a href="https://blog.csdn.net/weixin_46525412/article/details/120278159">CSDN</a>、<a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/04%20Normal%20Mapping/">LearnOpenGL</a>、<a href="http://www.thetenthplanet.de/archives/1180">ShaderX</a><br>记录一点自己的理解，矩阵乘法可以看做坐标系的转换，例如 M * a 便是将定义在 M 坐标系下的 a 向量转换至 <strong>定义了 M 坐标系的坐标系</strong> 下。<br>在这个问题中，M 便是当前片元所在的切线空间在世界坐标系下的表示（就是 TBN 矩阵），a 便是法线贴图中的向量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Eigen::Vector2f dUV1 = v[<span class="hljs-number">1</span>].uv - v[<span class="hljs-number">0</span>].uv;<br>Eigen::Vector2f dUV2 = v[<span class="hljs-number">2</span>].uv - v[<span class="hljs-number">0</span>].uv;<br><span class="hljs-type">float</span> inverse = <span class="hljs-number">1.f</span> / (dUV1[<span class="hljs-number">0</span>] * dUV2[<span class="hljs-number">1</span>] - dUV2[<span class="hljs-number">0</span>] * dUV1[<span class="hljs-number">1</span>]);<br><br>Eigen::Vector3f e1 = v[<span class="hljs-number">1</span>].viewPos - v[<span class="hljs-number">0</span>].viewPos;<br>Eigen::Vector3f e2 = v[<span class="hljs-number">2</span>].viewPos - v[<span class="hljs-number">0</span>].viewPos;<br><br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">T</span><span class="hljs-params">(dUV2[<span class="hljs-number">1</span>] * e1[<span class="hljs-number">0</span>] - dUV1[<span class="hljs-number">1</span>] * e2[<span class="hljs-number">0</span>],</span></span><br><span class="hljs-params"><span class="hljs-function">    dUV2[<span class="hljs-number">1</span>] * e1[<span class="hljs-number">1</span>] - dUV1[<span class="hljs-number">1</span>] * e2[<span class="hljs-number">1</span>],</span></span><br><span class="hljs-params"><span class="hljs-function">    dUV2[<span class="hljs-number">1</span>] * e1[<span class="hljs-number">2</span>] - dUV1[<span class="hljs-number">1</span>] * e2[<span class="hljs-number">2</span>])</span></span>;<br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">B</span><span class="hljs-params">(dUV1[<span class="hljs-number">0</span>] * e2[<span class="hljs-number">0</span>] - dUV2[<span class="hljs-number">0</span>] * e1[<span class="hljs-number">0</span>],</span></span><br><span class="hljs-params"><span class="hljs-function">    dUV1[<span class="hljs-number">0</span>] * e2[<span class="hljs-number">1</span>] - dUV2[<span class="hljs-number">0</span>] * e1[<span class="hljs-number">1</span>],</span></span><br><span class="hljs-params"><span class="hljs-function">    dUV1[<span class="hljs-number">0</span>] * e2[<span class="hljs-number">2</span>] - dUV2[<span class="hljs-number">0</span>] * e1[<span class="hljs-number">2</span>])</span></span>;<br>B *= inverse;<br>T *= inverse;<br>T.<span class="hljs-built_in">normalize</span>();<br>B.<span class="hljs-built_in">normalize</span>();<br><br>Eigen::Matrix3f TBN;<br>TBN &lt;&lt; T[<span class="hljs-number">0</span>], B[<span class="hljs-number">0</span>], normal[<span class="hljs-number">0</span>],<br>    T[<span class="hljs-number">1</span>], B[<span class="hljs-number">1</span>], normal[<span class="hljs-number">1</span>],<br>    T[<span class="hljs-number">2</span>], B[<span class="hljs-number">2</span>], normal[<span class="hljs-number">2</span>];<br>normal = (TBN * model-&gt;<span class="hljs-built_in">normalMap</span>(uv)).<span class="hljs-built_in">normalized</span>();<br></code></pre></td></tr></table></figure><h2 id="法向量修复"><a href="#法向量修复" class="headerlink" title="法向量修复"></a>法向量修复</h2><p><a href="https://learnopengl-cn.github.io/02%20Lighting/02%20Basic%20Lighting/#_6">LearnOpenGL 评论区</a><br>法向量乘以 model 矩阵左上角 3x3 矩阵的逆的转置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CPP</tag>
      
      <tag>Rendering</tag>
      
      <tag>Rasterization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Archive】GAMES202</title>
    <link href="/2021/09/22/GAMES202/"/>
    <url>/2021/09/22/GAMES202/</url>
    
    <content type="html"><![CDATA[<h1 id="百分比近似软阴影"><a href="#百分比近似软阴影" class="headerlink" title="百分比近似软阴影"></a>百分比近似软阴影</h1><p>&emsp;&emsp;若要判断当前着色点是否处于阴影之中，我们需要知到该点与光源之间的遮挡关系。一种常见的做法是 Shadow Mapping，假设从光源看向场景，就像做深度测试一样，保存一张从光源处获得的 DepthBuffer，然后比较着色点与光源之间的距离与 DepthBuffer 中对应点的深度，前者更大则代表场景中有另一物体比当前着色点更接近光源，即该着色点被遮挡。</p><h2 id="Two-Pass-Shadow-Map-硬阴影"><a href="#Two-Pass-Shadow-Map-硬阴影" class="headerlink" title="Two Pass Shadow Map 硬阴影"></a>Two Pass Shadow Map 硬阴影</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> useShadowMap(<span class="hljs-type">sampler2D</span> shadowMap, <span class="hljs-type">vec4</span> coord) &#123;<br>    <span class="hljs-type">vec4</span> closestDepthVec = <span class="hljs-built_in">texture2D</span>(shadowMap, coord.xy);<br>    <span class="hljs-type">float</span> closestDepth = unpack(closestDepthVec);<br><br>    <span class="hljs-keyword">return</span> coord.z &lt; closestDepth + <span class="hljs-number">0.011</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>) &#123;<br>    <span class="hljs-comment">// 转换至 NDC 空间</span><br>    <span class="hljs-type">vec3</span> shadowCoord = vPositionFromLight.xyz / vPositionFromLight.w;<br>    shadowCoord = shadowCoord * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;<br><br>    <span class="hljs-comment">// 省略布林冯光照模型的实现</span><br>    <span class="hljs-type">vec3</span> phongColor = blinnPhong();<br>    <span class="hljs-comment">// 这里将可见度作为一个单独的项拆分出来</span><br>    <span class="hljs-type">float</span> visibility = <span class="hljs-number">1.0</span>;<br><br>    visibility = useShadowMap(uShadowMap, <span class="hljs-type">vec4</span>(shadowCoord, <span class="hljs-number">1.0</span>));<br>    <span class="hljs-comment">//visibility = PCF(uShadowMap, vec4(shadowCoord, 1.0));</span><br>    <span class="hljs-comment">//visibility = PCSS(uShadowMap, vec4(shadowCoord, 1.0));</span><br>    <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(phongColor * visibility, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="coord-z-closestDepth-1-0-0-0-的问题"><a href="#coord-z-closestDepth-1-0-0-0-的问题" class="headerlink" title="coord.z &lt; closestDepth ? 1.0 : 0.0 的问题"></a>coord.z &lt; closestDepth ? 1.0 : 0.0 的问题</h3><p>这个问题源自于 Shadow Map 对场景走样&#x2F;失真的理解。光源对场景的离散化认为 Shadow Map 内每一个纹素对应的表面属于同一个深度，此时对于侧对光源的表面，单个纹素内无法表示表面深度剧烈的变化，Shadow Map 便会将平面理解为一个…搓衣板。<br><img src="/img/GAMES202/s.png" alt="光源与地板几乎位于同一平面上"><br><strong>解决方法</strong>：为判断条件添加一个容忍度。<br><code>return coord.z &lt; (closestDepth + 0.01) ? 1.0 : 0.0;</code><br><img src="/img/GAMES202/H.png"><br><strong>新的问题</strong>：当这个容忍度较大时阴影的根部会与模型发生分离，这个问题是目前难以解决的。</p><h2 id="Percentage-Closer-Filter"><a href="#Percentage-Closer-Filter" class="headerlink" title="Percentage Closer Filter"></a>Percentage Closer Filter</h2><p>不再仅仅查询 DepthBuffer 中对应点的深度，而是计算一定范围内深度大于着色点深度的比例，认为深度小于着色点深度的物体会遮挡着色点。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> PCF(<span class="hljs-type">sampler2D</span> shadowMap, <span class="hljs-type">vec4</span> coord) &#123;<br>    poissonDiskSamples(coord.xy);<br><br>    <span class="hljs-type">int</span> unShadowCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_SAMPLES; i ++) &#123;<br>        <span class="hljs-type">vec2</span> sampleCoord = poissonDisk[i] * FILTER_DIAMETER + coord.xy;<br>        <span class="hljs-type">vec4</span> closestDepthVec = <span class="hljs-built_in">texture2D</span>(shadowMap, sampleCoord); <br>        <span class="hljs-type">float</span> closestDepth = unpack(closestDepthVec);<br>        <span class="hljs-keyword">if</span>(coord.z &lt; closestDepth + <span class="hljs-number">0.011</span>) &#123;<br>            unShadowCount += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">float</span>(unShadowCount) / <span class="hljs-type">float</span>(NUM_SAMPLES);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/GAMES202/PCF.png"></p><h2 id="Percentage-Closer-Soft-Shadow"><a href="#Percentage-Closer-Soft-Shadow" class="headerlink" title="Percentage Closer Soft Shadow"></a>Percentage Closer Soft Shadow</h2><p><strong>PCF 的问题</strong>：整体的阴影都会获得一个模糊，而现实情况是阴影的根部往往是最“扎实”的，远端的阴影才会渐渐变得模糊。<br><strong>解决方法</strong>：已知阴影模糊的程度取决于 Filter 的大小，如果能让 Filter 的大小随阴影着色点与遮挡物的距离增加而增加，便能实现较为真实的软阴影。<br>PCSS 分为三步：</p><ol><li>avgblocker depth</li><li>calculate penumbra size</li><li>filtering (PCF)</li></ol><h3 id="avgblocker-depth"><a href="#avgblocker-depth" class="headerlink" title="avgblocker depth"></a>avgblocker depth</h3><p>在一定范围内查找能够遮挡着色点的物体的深度平均值。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> findBlocker(<span class="hljs-type">sampler2D</span> shadowMap, <span class="hljs-type">vec2</span> uv, <span class="hljs-type">float</span> zReceiver) &#123;<br>    poissonDiskSamples(uv);<br><br>    <span class="hljs-type">int</span> shadowCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">float</span> blockDepthSum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_SAMPLES; i++) &#123;<br>        <span class="hljs-type">vec2</span> sampleCoord = poissonDisk[i] * FILTER_DIAMETER + uv;<br>        <span class="hljs-type">vec4</span> closestDepthVec = <span class="hljs-built_in">texture2D</span>(shadowMap, sampleCoord);<br>        <span class="hljs-type">float</span> closestDepth = unpack(closestDepthVec);<br>        <span class="hljs-keyword">if</span>(zReceiver &gt; closestDepth + <span class="hljs-number">0.011</span>) &#123;<br>            blockDepthSum += closestDepth;<br>            shadowCount += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> blockDepthSum / <span class="hljs-type">float</span>(shadowCount);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="calculate-penumbra-size"><a href="#calculate-penumbra-size" class="headerlink" title="calculate penumbra size"></a>calculate penumbra size</h3><p>根据第一步得到的遮挡物深度计算阴影的模糊程度。<br><img src="/img/GAMES202/3.png" alt="相似三角形原理，wPenumbra 便代表了阴影的模糊程度"></p><ul><li>$W_{Penumbra}&#x3D;(d_{Receiver}-d_{Blocker})*W_{Light}&#x2F;d_{Blocker}$</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> PCSS(<span class="hljs-type">sampler2D</span> shadowMap, <span class="hljs-type">vec4</span> coord) &#123;<br>    <span class="hljs-type">float</span> zReceiver = coord.z;<br><br>    <span class="hljs-comment">// STEP 1: avgblocker depth</span><br>    <span class="hljs-type">float</span> zBlocker = findBlocker(shadowMap, coord.xy, zReceiver);<br>    <span class="hljs-keyword">if</span>(zBlocker &lt;= EPS) <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">if</span>(zBlocker &gt;= <span class="hljs-number">1.0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-comment">// STEP 2: penumbra size</span><br>    <span class="hljs-type">float</span> wPenumbra = W_LIGHT * (zReceiver - zBlocker) / zBlocker;<br><br>    <span class="hljs-comment">// STEP 3: filtering</span><br>    <span class="hljs-type">int</span> unShadowCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_SAMPLES; i ++) &#123;<br>        <span class="hljs-type">vec2</span> sampleCoord = poissonDisk[i] * FILTER_DIAMETER * wPenumbra + coord.xy;<br>        <span class="hljs-type">vec4</span> closestDepthVec = <span class="hljs-built_in">texture2D</span>(shadowMap, sampleCoord); <br>        <span class="hljs-type">float</span> closestDepth = unpack(closestDepthVec);<br>        <span class="hljs-keyword">if</span>(zReceiver &lt; closestDepth + <span class="hljs-number">0.011</span>) &#123;<br>            unShadowCount += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">float</span>(unShadowCount) / <span class="hljs-type">float</span>(NUM_SAMPLES);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/img/GAMES202/PCSS.png"></p><h1 id="预计算辐射传递"><a href="#预计算辐射传递" class="headerlink" title="预计算辐射传递"></a>预计算辐射传递</h1><p>&emsp;&emsp;如何计算环境光照可以近似为一个 ManyLight 的问题，在这种情况下，如果想要得知某一着色点获得的光照，需要对该点的上半球进行采样，这会是一个非常大的性能开销。使用 PRT 的做法可以使用预计算的数据，在实时的条件下实现环境光照。未实现：球谐函数的快速旋转。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="Product-Integral"><a href="#Product-Integral" class="headerlink" title="Product Integral"></a>Product Integral</h3><ul><li>$\int _\Omega f(x)g(x)dx$&emsp;两函数乘积的积分可以视为滤波，结果的频率由其中更低频的函数决定。</li></ul><h3 id="基函数"><a href="#基函数" class="headerlink" title="基函数"></a>基函数</h3><ul><li>$f(x)&#x3D;\sum c_i\cdot B_i(x)$&emsp;对于任一函数，我们可以用一系列基函数的线性组合来近似出原函数。</li></ul><h3 id="球谐函数"><a href="#球谐函数" class="headerlink" title="球谐函数"></a>球谐函数</h3><p><img src="/img/GAMES202/SH.png"><br><strong>定义</strong>：$\frac{1}{\sin \theta}\frac{\partial}{\partial \theta}(\sin \theta \frac{\partial Y}{\partial \theta})+\frac{1}{\sin ^2\theta}\frac{\partial ^2Y}{\partial \varphi ^2}+l(l+1)Y&#x3D;0$<br>球谐函数是一系列定义在球面上的基函数，这里不深入理解函数的定义，而是重点关注该函数的几个性质：</p><ul><li>$c_i&#x3D;\int _\Omega f(\omega)B_i(\omega){\rm d}x$</li><li>正交性，任意两分量相乘结果为零。</li><li>旋转不变性，旋转的结果可由同阶基函数的线性组合得到。</li><li>只用三阶的球谐函数便可以很好地恢复出渲染方程中的 BRDF 项。 <img src="/img/GAMES202/BRDF.png"></li><li>所以对于 Diffuse 材质，同样用三阶的球谐函数表示 Lighting 项，误差不会超过 %3。 <img src="/img/GAMES202/L.png"></li></ul><h2 id="Precomputed-Radiance-Transfer"><a href="#Precomputed-Radiance-Transfer" class="headerlink" title="Precomputed Radiance Transfer"></a>Precomputed Radiance Transfer</h2><p>先写出实时渲染中渲染方程的形式：</p><ul><li>$L(o)&#x3D;\int _\Omega L(i)V(i)\rho (i, o)max(0, n\cdot i)di$</li></ul><p>积分中 L(i) 当作 Lighting 项，其余为 LightTransport 项。假设场景中的物体不变（即每个点的 LightTransport 就像该点的一个性质一样不变），光源可以旋转。</p><h3 id="Diffuse-的情况"><a href="#Diffuse-的情况" class="headerlink" title="Diffuse 的情况"></a>Diffuse 的情况</h3><p>BRDF 项为一个常值，可以直接提到积分外。</p><ul><li>$L(o)&#x3D;\rho \int _\Omega L(i)V(i)max(0, n\cdot i)di$</li></ul><p>由&nbsp;$L(i)\approx \sum l_iB_i(i)$&nbsp;得</p><ul><li>$L(o)\approx \rho \sum l_i\int _\Omega B_i(i)V(i)max(0, n\cdot i)di$（不考虑交换积分与求和顺序的条件）</li></ul><p>由&nbsp;$c_i&#x3D;\int _\Omega f(\omega)B_i(\omega){\rm d}x$&nbsp;得</p><ul><li>$L(o)\approx \rho \sum l_iT_i$</li></ul><h2 id="Precompute-部分"><a href="#Precompute-部分" class="headerlink" title="Precompute 部分"></a>Precompute 部分</h2><ul><li>$c_i&#x3D;\int _\Omega f(\omega)B_i(\omega){\rm d}x$&emsp;</li></ul><p>使用黎曼积分的方式计算。</p><ul><li>$c_i&#x3D;\sum _if(\omega)B_i(\omega)\Delta \omega$</li></ul><p><code>std::vector&lt;Eigen::Array3f&gt; PrecomputeCubemapSH(const std::vector&lt;std::unique_ptr&lt;float[]&gt;&gt; &amp;images,                                                     const int &amp;width, const int &amp;height,                                                     const int &amp;channel)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br><span class="hljs-comment">// 遍历天空盒每个面的每个像素</span><br><br>            <span class="hljs-comment">// 像素对应的方向</span><br>            Eigen::Vector3f dir = cubemapDirs[i * width * height + y * width + x];<br>            <span class="hljs-type">int</span> index = (y * width + x) * channel;<br>            <span class="hljs-comment">// 像素对应的光照</span><br>            <span class="hljs-function">Eigen::Array3f <span class="hljs-title">Le</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">images[i][index],</span></span><br><span class="hljs-params"><span class="hljs-function">images[i][index + <span class="hljs-number">1</span>],</span></span><br><span class="hljs-params"><span class="hljs-function">images[i][index + <span class="hljs-number">2</span>])</span></span>;<br>            <span class="hljs-comment">// 像素在单位球上对应的面积</span><br>            <span class="hljs-type">float</span> w = <span class="hljs-built_in">CalcArea</span>(x, y, width, height);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt;= SHOrder; l++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = -l; m &lt;= l; m++) &#123;<br>                    <span class="hljs-type">int</span> k = sh::<span class="hljs-built_in">GetIndex</span>(l, m);<br><span class="hljs-comment">// 投影于基函数上</span><br>                    <span class="hljs-type">double</span> basisFunc =<br>sh::<span class="hljs-built_in">EvalSH</span>(l, m, dir.<span class="hljs-built_in">cast</span>&lt;<span class="hljs-type">double</span>&gt;().<span class="hljs-built_in">normalized</span>());<br>                    SHCoeffiecents[k] += Le * basisFunc * w;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>void preprocess(const Scene *scene)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mesh-&gt;<span class="hljs-built_in">getVertexCount</span>(); i++) <br><span class="hljs-comment">// 获取当前 mesh 的坐标和法线&#123;</span><br><span class="hljs-type">const</span> Point3f &amp;v = mesh-&gt;<span class="hljs-built_in">getVertexPositions</span>().<span class="hljs-built_in">col</span>(i);<br><span class="hljs-type">const</span> Normal3f &amp;n = mesh-&gt;<span class="hljs-built_in">getVertexNormals</span>().<span class="hljs-built_in">col</span>(i);<br><span class="hljs-keyword">auto</span> shFunc = [&amp;](<span class="hljs-type">double</span> phi, <span class="hljs-type">double</span> theta) -&gt; <span class="hljs-type">double</span> &#123;<br>Eigen::Array3d d = sh::<span class="hljs-built_in">ToVector</span>(phi, theta);<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> wi = <span class="hljs-built_in">Vector3f</span>(d.<span class="hljs-built_in">x</span>(), d.<span class="hljs-built_in">y</span>(), d.<span class="hljs-built_in">z</span>());<br><span class="hljs-type">double</span> H = wi.<span class="hljs-built_in">dot</span>(n);<br><span class="hljs-keyword">if</span> (m_Type == Type::Unshadowed) &#123;<br><span class="hljs-keyword">if</span> (H &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> H;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>Ray3f <span class="hljs-built_in">ray</span>(v, wi.<span class="hljs-built_in">normalized</span>());<br><span class="hljs-comment">// 没有hit到其他地方的射线就对最终光照信息有贡献</span><br><span class="hljs-keyword">if</span> (H &gt; <span class="hljs-number">0</span> &amp;&amp; !scene-&gt;<span class="hljs-built_in">rayIntersect</span>(ray)) &#123;<br><span class="hljs-keyword">return</span> H;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 投影</span><br><span class="hljs-keyword">auto</span> shCoeff = sh::<span class="hljs-built_in">ProjectFunction</span>(SHOrder, shFunc, m_SampleCount);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; shCoeff-&gt;<span class="hljs-built_in">size</span>(); j++) &#123;<br>m_TransportSHCoeffs.<span class="hljs-built_in">col</span>(i).<span class="hljs-built_in">coeffRef</span>(j) = (*shCoeff)[j];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果保存在 light.txt 与 transport.txt 中。</p><h2 id="Real-Time-部分"><a href="#Real-Time-部分" class="headerlink" title="Real Time 部分"></a>Real Time 部分</h2><p>材质</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DiffuseMaterial</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Material</span> &#123;<br><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">vertexShader, fragmentShader</span>) &#123;<br><span class="hljs-keyword">let</span> precomputeL_mat = <span class="hljs-title function_">getMat3ValueFromRGB</span>(precomputeL[guiParams.<span class="hljs-property">envmapId</span>]);<br><br><span class="hljs-variable language_">super</span>(&#123;<br><span class="hljs-string">&#x27;aPrecomputeLR&#x27;</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;matrix3fv&#x27;</span>, <span class="hljs-attr">value</span>: precomputeL_mat[<span class="hljs-number">0</span>]&#125;,<br><span class="hljs-string">&#x27;aPrecomputeLG&#x27;</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;matrix3fv&#x27;</span>, <span class="hljs-attr">value</span>: precomputeL_mat[<span class="hljs-number">1</span>]&#125;,<br><span class="hljs-string">&#x27;aPrecomputeLB&#x27;</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;matrix3fv&#x27;</span>, <span class="hljs-attr">value</span>: precomputeL_mat[<span class="hljs-number">2</span>]&#125;<br>&#125;, [<span class="hljs-string">&#x27;aPrecomputeLT&#x27;</span>], vertexShader, fragmentShader, <span class="hljs-literal">null</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">mapid</span> = guiParams.<span class="hljs-property">envmapId</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildDiffuseMaterial</span>(<span class="hljs-params">vertexPath, fragmentPath</span>) &#123;<br><span class="hljs-keyword">let</span> vertexShader = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getShaderString</span>(vertexPath);<br><span class="hljs-keyword">let</span> fragmentShader = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getShaderString</span>(fragmentPath);<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiffuseMaterial</span>(vertexShader, fragmentShader);<br>&#125;<br></code></pre></td></tr></table></figure><p>VertexShader</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat3</span> aPrecomputeLR;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat3</span> aPrecomputeLG;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat3</span> aPrecomputeLB;<br><span class="hljs-keyword">attribute</span> <span class="hljs-type">mat3</span> aPrecomputeLT;<br><br><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec3</span> aVertexPosition;<br><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec3</span> aNormalPosition;<br><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec2</span> aTextureCoord;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> uModelMatrix;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> uViewMatrix;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> uProjectionMatrix;<br><br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec2</span> vTextureCoord;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vFragPos;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vNormal;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vColor;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> kd = <span class="hljs-number">2.0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>) &#123;<br>  vFragPos = (uModelMatrix * <span class="hljs-type">vec4</span>(aVertexPosition, <span class="hljs-number">1.0</span>)).xyz;<br>  vNormal = (uModelMatrix * <span class="hljs-type">vec4</span>(aNormalPosition, <span class="hljs-number">0.0</span>)).xyz;<br><br>  <span class="hljs-type">vec3</span> iden = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);<br>  vColor = <span class="hljs-type">vec3</span>(<br>      <span class="hljs-built_in">dot</span>(<span class="hljs-built_in">matrixCompMult</span>(aPrecomputeLR, aPrecomputeLT) * iden, iden),<br>      <span class="hljs-built_in">dot</span>(<span class="hljs-built_in">matrixCompMult</span>(aPrecomputeLG, aPrecomputeLT) * iden, iden),<br>      <span class="hljs-built_in">dot</span>(<span class="hljs-built_in">matrixCompMult</span>(aPrecomputeLB, aPrecomputeLT) * iden, iden)<br>  ) * kd / pi;<br><br>  <span class="hljs-built_in">gl_Position</span> =<br>  uProjectionMatrix * uViewMatrix * uModelMatrix * <span class="hljs-type">vec4</span>(aVertexPosition, <span class="hljs-number">1.0</span>);<br>  vTextureCoord = aTextureCoord;<br>&#125;<br></code></pre></td></tr></table></figure><p>FragmentShader</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#ifdef GL_ES</span><br><span class="hljs-keyword">precision</span> <span class="hljs-keyword">mediump</span> <span class="hljs-type">float</span>;<br><span class="hljs-meta">#endif</span><br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uSampler;<br><br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec2</span> vTextureCoord;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vFragPos;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vNormal;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vColor;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>) &#123;<br>  <span class="hljs-type">vec3</span> color = <span class="hljs-built_in">texture2D</span>(uSampler, vTextureCoord).rgb;<br>  color = <span class="hljs-built_in">pow</span>(color, <span class="hljs-type">vec3</span>(<span class="hljs-number">2.2</span>));<br><br>  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(vColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES202/1.png"></div><div class="group-image-wrap"><img src="/img/GAMES202/2.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES202/33.png"></div><div class="group-image-wrap"><img src="/img/GAMES202/4.png"></div></div></div><h1 id="屏幕空间反射"><a href="#屏幕空间反射" class="headerlink" title="屏幕空间反射"></a>屏幕空间反射</h1><p>&emsp;&emsp;离线渲染的条件下，光线追踪可以处理光线在空间内的多次弹射，带来高质量的间接光照结果，那么如何在实时的条件下得到令人满意的全局光照效果呢。其中的一种做法是在做 RayTracing 时使用 DepthBuffer 判断射线与平面的相交问题，认为能被 DepthBuffer 看见得世界坐标是“位于物体外部”的坐标，看不见则在物体内部，那么一条步进的 Ray 从可见转为不可见时的位置便是某一表面所在的坐标，这样相交的计算就转变为二维空间下的步进与查表。</p><h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><h3 id="Diffuse"><a href="#Diffuse" class="headerlink" title="Diffuse"></a>Diffuse</h3><p>EvalDiffuse(wi, wo, uv) 的返回值为 BSDF 的值。参数 wi 和 wo 为世界坐标系中的值，分别代表入射方向和出射方向，这两个方向的起点都是着色点，uv 为着色点在屏幕空间中的坐标。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> EvalDiffuse(<span class="hljs-type">vec3</span> wi, <span class="hljs-type">vec3</span> wo, <span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">vec3</span> Ld = GetGBufferDiffuse(uv);<br>  <span class="hljs-type">vec3</span> n = GetGBufferNormalWorld(uv);<br>  <span class="hljs-type">float</span> nDotL = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.0</span>, <span class="hljs-built_in">dot</span>(n, wi));<br><br>  <span class="hljs-keyword">return</span> Ld * nDotL * INV_PI;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DirectionalLight"><a href="#DirectionalLight" class="headerlink" title="DirectionalLight"></a>DirectionalLight</h3><p>EvalDirectionalLight(uv) 的返回值为，着色点位于 uv 处得到的光源的辐射度，并且需要考虑遮挡关系，可以使用 GetGBufferuShadow(uv) 函数得到。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> EvalDirectionalLight(<span class="hljs-type">vec2</span> uv) &#123;<br>    <span class="hljs-type">vec3</span> woeldPos = GetGBufferPosWorld(uv);<br>    <span class="hljs-type">vec3</span> wi = <span class="hljs-built_in">normalize</span>(uLightDir);<br>    <span class="hljs-type">vec3</span> wo = <span class="hljs-built_in">normalize</span>(uCameraPos - woeldPos);<br>    <span class="hljs-type">vec3</span> bsdf = EvalDiffuse(wi, wo, uv);<br><br>    <span class="hljs-keyword">return</span> uLightRadiance * bsdf * GetGBufferuShadow(uv);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RayMarch"><a href="#RayMarch" class="headerlink" title="RayMarch"></a>RayMarch</h3><p>RayMarch(vec3 ori, vec3 dir, vec3 hitPos) 的返回值为是否相交，相交时将参数 hitPos 设置为交点。参数 ori 和 dir 为世界坐标系，分别代表光线的起点和方向。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#define EPS 1e-3</span><br><span class="hljs-type">bool</span> OutOfScreen(<span class="hljs-type">vec3</span> pos) &#123;<br>    <span class="hljs-type">vec2</span> uv = GetScreenCoordinate(pos);<br>    <span class="hljs-keyword">return</span> uv.x &lt; <span class="hljs-number">0.0</span> || uv.y &lt; <span class="hljs-number">0.0</span> || uv.x &gt; <span class="hljs-number">1.0</span> || uv.y &gt; <span class="hljs-number">1.0</span>;<br>&#125;<br><span class="hljs-type">bool</span> Visible(<span class="hljs-type">vec3</span> pos) &#123;<br>    <span class="hljs-keyword">return</span> GetDepth(pos) &lt; GetGBufferDepth(GetScreenCoordinate(pos));<br>&#125;<br><br><span class="hljs-type">bool</span> RayMarch(<span class="hljs-type">vec3</span> ori, <span class="hljs-type">vec3</span> dir, <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> hitPos) &#123;<br>    <span class="hljs-type">bool</span> isHit = <span class="hljs-literal">false</span>, intersected = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">float</span> stepLenth = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">vec3</span> crtPos = ori;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1280</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(OutOfScreen(crtPos)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Visible(crtPos + dir * stepLenth)) &#123;<br>            <span class="hljs-comment">// 无交点则步长不变继续步进</span><br>            crtPos += dir * stepLenth;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            intersected = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(stepLenth &lt; EPS) &#123;<br>            <span class="hljs-comment">// 当精度高到一定程度时结束循环</span><br>            isHit = <span class="hljs-literal">true</span>;<br>            hitPos = crtPos;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(intersected) &#123;<br>            <span class="hljs-comment">// 一旦发现前方为交点则不断提高精度</span><br>            stepLenth *= <span class="hljs-number">0.5</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isHit;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IndirectLight"><a href="#IndirectLight" class="headerlink" title="IndirectLight"></a>IndirectLight</h3><p>使用蒙特卡洛的方式对半球进行积分，直接光照着色点 q 对间接光照作色点 p 的贡献为</p><ul><li>$L_{indir}&#x3D;\frac{EvalDiffuse(q)}{pdf}*EvalDiffuse(p)*EvalDirectionalLight(p)$</li></ul><p>SampleHemisphereCos(seed, pdf) 会返回一个局部坐标系的随机位置。LocalBasis(n, b1, b2) 通过传入的世界坐标系的法线 n，建立局部坐标系，返回两个切线向量。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#define SAMPLE_NUM 2</span><br><span class="hljs-type">vec3</span> EvalIndirectLight(<span class="hljs-type">float</span> seed, <span class="hljs-type">vec3</span> pos) &#123;<br>    <span class="hljs-type">float</span> pdf;<br>    <span class="hljs-type">vec3</span> Lid = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>), hitPos;<br>    <span class="hljs-type">vec2</span> screenPos = GetScreenCoordinate(pos);<br><br>    <span class="hljs-comment">// 局部转换至世界坐标</span><br>    <span class="hljs-type">vec3</span> normal = GetGBufferNormalWorld(screenPos), b1, b2;<br>    LocalBasis(normal, b1, b2);<br>    <span class="hljs-type">mat3</span> TBN = <span class="hljs-type">mat3</span>(b1, b2, normal);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SAMPLE_NUM; i++) &#123;<br>        <span class="hljs-type">vec3</span> sampleDir = <span class="hljs-built_in">normalize</span>(TBN * SampleHemisphereCos(seed, pdf));<br>        <span class="hljs-comment">// SampleHemisphereUniform(seed, pdf);</span><br>        <span class="hljs-keyword">if</span>(RayMarch(pos, sampleDir, hitPos)) &#123;<br>            <span class="hljs-type">vec3</span> wi = <span class="hljs-built_in">normalize</span>(uLightDir);<br>            <span class="hljs-type">vec3</span> wo = <span class="hljs-built_in">normalize</span>(uCameraPos - pos);<br>            <span class="hljs-type">vec2</span> screenHitPos = GetScreenCoordinate(hitPos);<br><br>            <span class="hljs-type">vec3</span> L = EvalDiffuse(sampleDir, wo, screenPos) / pdf *<br>        EvalDiffuse(wi, -sampleDir, screenHitPos) * EvalDirectionalLight(screenHitPos);<br>            <br>            Lid += L;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Lid / <span class="hljs-type">float</span>(SAMPLE_NUM);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整的-FragmentSHader"><a href="#完整的-FragmentSHader" class="headerlink" title="完整的 FragmentSHader"></a>完整的 FragmentSHader</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#ifdef GL_ES</span><br><span class="hljs-keyword">precision</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">float</span>;<br><span class="hljs-meta">#endif</span><br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uLightDir;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uCameraPos;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uLightRadiance;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uGDiffuse;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uGDepth;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uGNormalWorld;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uGShadow;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uGPosWorld;<br><br><span class="hljs-keyword">varying</span> <span class="hljs-type">mat4</span> vWorldToScreen;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec4</span> vPosWorld;<br><br><span class="hljs-meta">#define M_PI 3.1415926535897932384626433832795</span><br><span class="hljs-meta">#define TWO_PI 6.283185307</span><br><span class="hljs-meta">#define INV_PI 0.31830988618</span><br><span class="hljs-meta">#define INV_TWO_PI 0.15915494309</span><br><br><span class="hljs-type">float</span> Rand1(<span class="hljs-keyword">inout</span> <span class="hljs-type">float</span> p) &#123;<br>  p = <span class="hljs-built_in">fract</span>(p * <span class="hljs-number">.1031</span>);<br>  p *= p + <span class="hljs-number">33.33</span>;<br>  p *= p + p;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">fract</span>(p);<br>&#125;<br><br><span class="hljs-type">vec2</span> Rand2(<span class="hljs-keyword">inout</span> <span class="hljs-type">float</span> p) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">vec2</span>(Rand1(p), Rand1(p));<br>&#125;<br><br><span class="hljs-type">float</span> InitRand(<span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">vec3</span> p3 = <span class="hljs-built_in">fract</span>(<span class="hljs-type">vec3</span>(uv.xyx) * <span class="hljs-number">.1031</span>);<br>  p3 += <span class="hljs-built_in">dot</span>(p3, p3.yzx + <span class="hljs-number">33.33</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">fract</span>((p3.x + p3.y) * p3.z);<br>&#125;<br><br><span class="hljs-type">vec3</span> SampleHemisphereUniform(<span class="hljs-keyword">inout</span> <span class="hljs-type">float</span> s, <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> pdf) &#123;<br>  <span class="hljs-type">vec2</span> uv = Rand2(s);<br>  <span class="hljs-type">float</span> z = uv.x;<br>  <span class="hljs-type">float</span> phi = uv.y * TWO_PI;<br>  <span class="hljs-type">float</span> sinTheta = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - z*z);<br>  <span class="hljs-type">vec3</span> dir = <span class="hljs-type">vec3</span>(sinTheta * <span class="hljs-built_in">cos</span>(phi), sinTheta * <span class="hljs-built_in">sin</span>(phi), z);<br>  pdf = INV_TWO_PI;<br>  <span class="hljs-keyword">return</span> dir;<br>&#125;<br><br><span class="hljs-type">vec3</span> SampleHemisphereCos(<span class="hljs-keyword">inout</span> <span class="hljs-type">float</span> s, <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> pdf) &#123;<br>  <span class="hljs-type">vec2</span> uv = Rand2(s);<br>  <span class="hljs-type">float</span> z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - uv.x);<br>  <span class="hljs-type">float</span> phi = uv.y * TWO_PI;<br>  <span class="hljs-type">float</span> sinTheta = <span class="hljs-built_in">sqrt</span>(uv.x);<br>  <span class="hljs-type">vec3</span> dir = <span class="hljs-type">vec3</span>(sinTheta * <span class="hljs-built_in">cos</span>(phi), sinTheta * <span class="hljs-built_in">sin</span>(phi), z);<br>  pdf = z * INV_PI;<br>  <span class="hljs-keyword">return</span> dir;<br>&#125;<br><br><span class="hljs-type">void</span> LocalBasis(<span class="hljs-type">vec3</span> n, <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> b1, <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> b2) &#123;<br>  <span class="hljs-type">float</span> sign_ = <span class="hljs-built_in">sign</span>(n.z);<br>  <span class="hljs-keyword">if</span> (n.z == <span class="hljs-number">0.0</span>) &#123;<br>    sign_ = <span class="hljs-number">1.0</span>;<br>  &#125;<br>  <span class="hljs-type">float</span> a = <span class="hljs-number">-1.0</span> / (sign_ + n.z);<br>  <span class="hljs-type">float</span> b = n.x * n.y * a;<br>  b1 = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span> + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);<br>  b2 = <span class="hljs-type">vec3</span>(b, sign_ + n.y * n.y * a, -n.y);<br>&#125;<br><br><span class="hljs-type">vec4</span> Project(<span class="hljs-type">vec4</span> a) &#123;<br>  <span class="hljs-keyword">return</span> a / a.w;<br>&#125;<br><br><span class="hljs-type">float</span> GetDepth(<span class="hljs-type">vec3</span> posWorld) &#123;<br>  <span class="hljs-type">float</span> depth = (vWorldToScreen * <span class="hljs-type">vec4</span>(posWorld, <span class="hljs-number">1.0</span>)).w;<br>  <span class="hljs-keyword">return</span> depth;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Transform point from world space to screen space([0, 1] x [0, 1])</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">vec2</span> GetScreenCoordinate(<span class="hljs-type">vec3</span> posWorld) &#123;<br>  <span class="hljs-type">vec2</span> uv = Project(vWorldToScreen * <span class="hljs-type">vec4</span>(posWorld, <span class="hljs-number">1.0</span>)).xy * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;<br>  <span class="hljs-keyword">return</span> uv;<br>&#125;<br><br><span class="hljs-type">float</span> GetGBufferDepth(<span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">float</span> depth = <span class="hljs-built_in">texture2D</span>(uGDepth, uv).x;<br>  <span class="hljs-keyword">if</span> (depth &lt; <span class="hljs-number">1e-2</span>) &#123;<br>    depth = <span class="hljs-number">1000.0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> depth;<br>&#125;<br><br><span class="hljs-type">vec3</span> GetGBufferNormalWorld(<span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">vec3</span> normal = <span class="hljs-built_in">texture2D</span>(uGNormalWorld, uv).xyz;<br>  <span class="hljs-keyword">return</span> normal;<br>&#125;<br><br><span class="hljs-type">vec3</span> GetGBufferPosWorld(<span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">vec3</span> posWorld = <span class="hljs-built_in">texture2D</span>(uGPosWorld, uv).xyz;<br>  <span class="hljs-keyword">return</span> posWorld;<br>&#125;<br><br><span class="hljs-type">float</span> GetGBufferuShadow(<span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">float</span> visibility = <span class="hljs-built_in">texture2D</span>(uGShadow, uv).x;<br>  <span class="hljs-keyword">return</span> visibility;<br>&#125;<br><br><span class="hljs-type">vec3</span> GetGBufferDiffuse(<span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">vec3</span> diffuse = <span class="hljs-built_in">texture2D</span>(uGDiffuse, uv).xyz;<br>  diffuse = <span class="hljs-built_in">pow</span>(diffuse, <span class="hljs-type">vec3</span>(<span class="hljs-number">2.2</span>));<br>  <span class="hljs-keyword">return</span> diffuse;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Evaluate diffuse bsdf value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * wi, wo are all in world space.</span><br><span class="hljs-comment"> * uv is in screen space, [0, 1] x [0, 1].</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">vec3</span> EvalDiffuse(<span class="hljs-type">vec3</span> wi, <span class="hljs-type">vec3</span> wo, <span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">vec3</span> Ld = GetGBufferDiffuse(uv);<br>  <span class="hljs-type">vec3</span> n = GetGBufferNormalWorld(uv);<br>  <span class="hljs-type">float</span> nDotL = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.0</span>, <span class="hljs-built_in">dot</span>(n, wi));<br>  <span class="hljs-keyword">return</span> Ld * nDotL * INV_PI;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Evaluate directional light with shadow map</span><br><span class="hljs-comment"> * uv is in screen space, [0, 1] x [0, 1].</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">vec3</span> EvalDirectionalLight(<span class="hljs-type">vec2</span> uv) &#123;<br>  <span class="hljs-type">vec3</span> woeldPos = GetGBufferPosWorld(uv);<br>  <span class="hljs-type">vec3</span> wi = <span class="hljs-built_in">normalize</span>(uLightDir);<br>  <span class="hljs-type">vec3</span> wo = <span class="hljs-built_in">normalize</span>(uCameraPos - woeldPos);<br>  <span class="hljs-type">vec3</span> bsdf = EvalDiffuse(wi, wo, uv);<br>  <span class="hljs-keyword">return</span> uLightRadiance * bsdf * GetGBufferuShadow(uv);<br>&#125;<br><br><span class="hljs-meta">#define EPS 1e-3</span><br><span class="hljs-type">bool</span> OutOfScreen(<span class="hljs-type">vec3</span> pos) &#123;<br>  <span class="hljs-type">vec2</span> uv = GetScreenCoordinate(pos);<br>  <span class="hljs-keyword">return</span> uv.x &lt; <span class="hljs-number">0.0</span> || uv.y &lt; <span class="hljs-number">0.0</span> || uv.x &gt; <span class="hljs-number">1.0</span> || uv.y &gt; <span class="hljs-number">1.0</span>;<br>&#125;<br><span class="hljs-type">bool</span> Visible(<span class="hljs-type">vec3</span> pos) &#123;<br>  <span class="hljs-keyword">return</span> GetDepth(pos) &lt; GetGBufferDepth(GetScreenCoordinate(pos));<br>&#125;<br><span class="hljs-type">bool</span> RayMarch(<span class="hljs-type">vec3</span> ori, <span class="hljs-type">vec3</span> dir, <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> hitPos) &#123;<br>  <span class="hljs-type">bool</span> isHit = <span class="hljs-literal">false</span>, intersected = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">float</span> stepLenth = <span class="hljs-number">0.1</span>;<br>  <span class="hljs-type">vec3</span> crtPos = ori;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1280</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(OutOfScreen(crtPos)) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(Visible(crtPos + dir * stepLenth)) &#123;<br>      <span class="hljs-comment">// 无交点则步长不变继续步进</span><br>      crtPos += dir * stepLenth;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      intersected = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(stepLenth &lt; EPS) &#123;<br>      <span class="hljs-comment">// 当精度高到一定程度时结束循环</span><br>      isHit = <span class="hljs-literal">true</span>;<br>      hitPos = crtPos;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(intersected) &#123;<br>      <span class="hljs-comment">// 一旦发现前方为交点则不断提高精度</span><br>      stepLenth *= <span class="hljs-number">0.5</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isHit;<br>&#125;<br><br><span class="hljs-meta">#define SAMPLE_NUM 2</span><br><span class="hljs-type">vec3</span> EvalIndirectLight(<span class="hljs-type">float</span> seed, <span class="hljs-type">vec3</span> pos) &#123;<br>  <span class="hljs-type">float</span> pdf;<br>  <span class="hljs-type">vec3</span> Lid = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>), hitPos;<br>  <span class="hljs-type">vec2</span> screenPos = GetScreenCoordinate(pos);<br><br>  <span class="hljs-type">vec3</span> normal = GetGBufferNormalWorld(screenPos), b1, b2;<br>  LocalBasis(normal, b1, b2);<br>  <span class="hljs-type">mat3</span> TBN = <span class="hljs-type">mat3</span>(b1, b2, normal);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SAMPLE_NUM; i++) &#123;<br>    <span class="hljs-comment">// SampleHemisphere</span><br>    <span class="hljs-type">vec3</span> sampleDir = <span class="hljs-built_in">normalize</span>(TBN * SampleHemisphereCos(seed, pdf));<br>    <span class="hljs-keyword">if</span>(RayMarch(pos, sampleDir, hitPos)) &#123;<br>      <span class="hljs-type">vec3</span> wi = <span class="hljs-built_in">normalize</span>(uLightDir);<br>      <span class="hljs-type">vec3</span> wo = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>);<br>      <span class="hljs-type">vec2</span> screenHitPos = GetScreenCoordinate(hitPos);<br><br>      <span class="hljs-type">vec3</span> L = EvalDiffuse(sampleDir, wo, screenPos) / pdf *<br>        EvalDiffuse(wi, wo, screenHitPos) * EvalDirectionalLight(screenHitPos);<br>        <br>      Lid += L;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> Lid / <span class="hljs-type">float</span>(SAMPLE_NUM) * <span class="hljs-number">100.0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;<br>  <span class="hljs-type">float</span> s = InitRand(<span class="hljs-built_in">gl_FragCoord</span>.xy);<br><br>  <span class="hljs-type">vec3</span> L = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);<br>  <span class="hljs-comment">// L += GetGBufferDiffuse(GetScreenCoordinate(vPosWorld.xyz));</span><br>  L += EvalDirectionalLight(GetScreenCoordinate(vPosWorld.xyz));<br><br>  <span class="hljs-comment">// vec3 test_dir = vec3(0.0);</span><br>  <span class="hljs-comment">// vec3 wo = normalize(uCameraPos - vPosWorld.xyz);</span><br>  <span class="hljs-comment">// vec3 normal = GetGBufferNormalWorld(GetScreenCoordinate(vPosWorld.xyz));</span><br>  <span class="hljs-comment">// test_dir = reflect(-wo,normal);</span><br>  <span class="hljs-comment">// vec3 test_hit;</span><br>  <span class="hljs-comment">// if(RayMarch(vPosWorld.xyz, test_dir, test_hit)) &#123;</span><br>  <span class="hljs-comment">//   L = GetGBufferDiffuse(GetScreenCoordinate(test_hit));</span><br>  <span class="hljs-comment">// &#125;</span><br><br>  L += EvalIndirectLight(s, vPosWorld.xyz);<br><br>  <span class="hljs-type">vec3</span> color = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">clamp</span>(L, <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>)), <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span> / <span class="hljs-number">2.2</span>));<br>  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-type">vec3</span>(color.rgb), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES202/df.png" alt="Diffuse Albedo"></div><div class="group-image-wrap"><img src="/img/GAMES202/ssr.png" alt="SSR"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES202/di.png" alt="Direct Light"></div><div class="group-image-wrap"><img src="/img/GAMES202/dis.png" alt="结合"></div></div></div><h1 id="Kulla-Conty-微表面模型能量补偿"><a href="#Kulla-Conty-微表面模型能量补偿" class="headerlink" title="Kulla-Conty 微表面模型能量补偿"></a>Kulla-Conty 微表面模型能量补偿</h1><p>&emsp;&emsp;微表面模型的 BRDF(Microfacet BRDF) 存在一个根本问题，就是其中的 G 项认为被微表面遮挡的反射光会直接消失，从而忽略了微表面间的多次弹射，这就导致了能量的损失。并且当材质的粗糙度越高时，能量的损失会越严重。Kulla-Conty 近似模型通过引入一个微表面 BRDF 的补偿项，来补偿光线的多次弹射，使得材质的渲染结果可以近似保持能量守恒。</p><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><ul><li>$f_r(i,o)&#x3D;\frac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)}$</li></ul><p><strong>F 项，选用 Schlick 近似：</strong></p><ul><li>$F&#x3D;R_0+(1-R_0)(1-\cos \theta)^5$</li></ul><p><strong>D 项，选用 GGX 分布：</strong></p><ul><li>$D_{GGX}(h)&#x3D;\frac{\alpha ^2}{\pi ((n\cdot h)^2(\alpha ^2-1)+1)^2}$</li></ul><p><strong>G 项，选用 Smith 模型：</strong></p><ul><li>$G_{Smith}(i,o,h)&#x3D;G_{Schlick}(l,h)G_{Schlick}(v,h)$</li><li>$G_{Schlick}(v,n)+\frac{n\cdot v}{n\cdot v(1-k)+k}$</li><li>$k&#x3D;\frac{(roughness+1)^2}{8}$</li></ul><h2 id="Precompute-部分-1"><a href="#Precompute-部分-1" class="headerlink" title="Precompute 部分"></a>Precompute 部分</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>Kulla-Conty 模型假设 Li 为 1，并试图积分出在给定 BRDF 下一着色点辐射出的所有能量 E，那么在考虑光线只发生一次弹射的情况下，所损失的、需要补充的能量自然就是 (1 - E) 了。<br>接下来我们希望能得到一个 BRDF，并且该公式在半球上的积分值为 (1 - E)，在实时计算时将该 BRDF 补充至原 BRDF 上便能得到正确的结果。</p><h3 id="GGX-E"><a href="#GGX-E" class="headerlink" title="GGX_E"></a>GGX_E</h3><ul><li>$E(\mu _o)&#x3D;\int _0^{2\pi}\int _0 ^1f_r(\mu _o,\mu _i,\phi)\mu _id\mu _id\phi$</li></ul><p>注：$\mu &#x3D;\sin \theta$，该公式本质上仍然是渲染方程的一种变形，将该积分换元便可得到一个在半球上对 $\omega$ 积分的公式。</p><h4 id="预计算实现"><a href="#预计算实现" class="headerlink" title="预计算实现"></a>预计算实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vec.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image_write.h&quot;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> resolution = <span class="hljs-number">128</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">samplePoints</span> &#123;<br>    std::vector&lt;Vec3f&gt; directions;<br>    std::vector&lt;<span class="hljs-type">float</span>&gt; PDFs;<br>&#125;samplePoints;<br><br><span class="hljs-comment">// 返回半球上 sample_count 个采样点</span><br><span class="hljs-function">samplePoints <span class="hljs-title">squareToCosineHemisphere</span><span class="hljs-params">(<span class="hljs-type">int</span> sample_count)</span></span>&#123;<br>    samplePoints samlpeList;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sample_side = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">sqrt</span>(sample_count)));<br><br>    std::random_device rd;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>;<br>    std::uniform_real_distribution&lt;&gt; <span class="hljs-built_in">rng</span>(<span class="hljs-number">0.f</span>, <span class="hljs-number">1.f</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; sample_side; t++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; p &lt; sample_side; p++) &#123;<br>            <span class="hljs-type">double</span> samplex = (t + <span class="hljs-built_in">rng</span>(gen)) / sample_side;<br>            <span class="hljs-type">double</span> sampley = (p + <span class="hljs-built_in">rng</span>(gen)) / sample_side;<br>            <br>            <span class="hljs-type">double</span> theta = <span class="hljs-number">0.5f</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">1</span> - <span class="hljs-number">2</span> * samplex);<br>            <span class="hljs-type">double</span> phi =  <span class="hljs-number">2</span> * PI * sampley;<br>            Vec3f wi = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-built_in">sin</span>(theta) * <span class="hljs-built_in">cos</span>(phi), <span class="hljs-built_in">sin</span>(theta) * <span class="hljs-built_in">sin</span>(phi), <span class="hljs-built_in">cos</span>(theta));<br>            <span class="hljs-type">float</span> pdf = wi.z / PI;<br>            <br>            samlpeList.directions.<span class="hljs-built_in">push_back</span>(wi);<br>            samlpeList.PDFs.<span class="hljs-built_in">push_back</span>(pdf);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> samlpeList;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">FresnelSchlick</span><span class="hljs-params">(<span class="hljs-type">float</span> HdotV, <span class="hljs-type">float</span> R0)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> R0 + (<span class="hljs-number">1.f</span> - R0) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.f</span> - HdotV, <span class="hljs-number">5.f</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">DistributionGGX</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotH, <span class="hljs-type">float</span> roughness)</span> </span>&#123;<br>    <span class="hljs-type">float</span> a = roughness*roughness;<br>    <span class="hljs-type">float</span> a2 = a*a;<br>    <span class="hljs-type">float</span> NdotH2 = NdotH*NdotH;<br><br>    <span class="hljs-type">float</span> nom   = a2;<br>    <span class="hljs-type">float</span> denom = (NdotH2 * (a2 - <span class="hljs-number">1.f</span>) + <span class="hljs-number">1.f</span>);<br>    denom = PI * denom * denom;<br><br>    <span class="hljs-keyword">return</span> nom / denom;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GeometrySchlickGGX</span><span class="hljs-params">(<span class="hljs-type">float</span> cosTerm, <span class="hljs-type">float</span> roughness)</span> </span>&#123;<br>    <span class="hljs-type">float</span> a = roughness;<br>    <span class="hljs-type">float</span> k = (a * a) / <span class="hljs-number">2.f</span>;<br><br>    <span class="hljs-type">float</span> nom = cosTerm;<br>    <span class="hljs-type">float</span> denom = cosTerm * (<span class="hljs-number">1.f</span> - k) + k;<br><br>    <span class="hljs-keyword">return</span> nom / denom;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GeometrySmith</span><span class="hljs-params">(<span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> NdotL)</span> </span>&#123;<br>    <span class="hljs-type">float</span> ggx2 = <span class="hljs-built_in">GeometrySchlickGGX</span>(NdotV, roughness);<br>    <span class="hljs-type">float</span> ggx1 = <span class="hljs-built_in">GeometrySchlickGGX</span>(NdotL, roughness);<br><br>    <span class="hljs-keyword">return</span> ggx1 * ggx2;<br>&#125;<br><br><span class="hljs-function">Vec3f <span class="hljs-title">IntegrateBRDF</span><span class="hljs-params">(<span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> NdotV)</span> </span>&#123;<br>    <span class="hljs-type">float</span> A = <span class="hljs-number">0.f</span>, B = <span class="hljs-number">0.f</span>, C = <span class="hljs-number">0.f</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sample_count = <span class="hljs-number">1024</span>;<br><br>    Vec3f N = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">0.f</span>, <span class="hljs-number">0.f</span>, <span class="hljs-number">1.f</span>);<br>    Vec3f V = <span class="hljs-built_in">Vec3f</span>(std::<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.f</span> - NdotV * NdotV), <span class="hljs-number">0.f</span>, NdotV);<br>    <br>    samplePoints sampleList = <span class="hljs-built_in">squareToCosineHemisphere</span>(sample_count);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sample_count; i++) &#123;<br>        Vec3f L = <span class="hljs-built_in">normalize</span>(sampleList.directions[i]);<br>        Vec3f H = <span class="hljs-built_in">normalize</span>(V + L);<br><br>        <span class="hljs-type">float</span> HdotV = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(H, V), <span class="hljs-number">0.f</span>);<br>        <span class="hljs-type">float</span> NdotL = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0.f</span>);<br>        <span class="hljs-type">float</span> NdotH = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, H), <span class="hljs-number">0.f</span>);<br><br>        <span class="hljs-type">float</span> R0 = <span class="hljs-number">1.f</span>;<br>        <span class="hljs-type">float</span> F = <span class="hljs-built_in">FresnelSchlick</span>(HdotV, R0);<br>        <span class="hljs-type">float</span> G = <span class="hljs-built_in">GeometrySmith</span>(roughness, NdotV, NdotL);<br>        <span class="hljs-type">float</span> D = <span class="hljs-built_in">DistributionGGX</span>(NdotH, roughness);<br><br>        <span class="hljs-type">float</span> numerator = F * G * D;<br>        <span class="hljs-type">float</span> denominator = <span class="hljs-number">4.f</span> * NdotV * NdotL;<br>        <span class="hljs-type">float</span> micro = numerator / std::<span class="hljs-built_in">max</span>(denominator, <span class="hljs-number">1e-10f</span>);<br><br>        <span class="hljs-type">float</span> pdf = sampleList.PDFs[i];<br>        A += micro * NdotL / pdf;<br>    &#125;<br>    C = B = A;<br><br>    <span class="hljs-keyword">return</span> &#123;A / sample_count, B / sample_count, C / sample_count&#125;;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> data[resolution * resolution * <span class="hljs-number">3</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">float</span> step = <span class="hljs-number">1.f</span> / resolution;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; resolution; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; resolution; j++) &#123;<br>            <span class="hljs-type">float</span> roughness = step * (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(i) + <span class="hljs-number">0.5f</span>);<br>            <span class="hljs-type">float</span> NdotV = step * (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(j) + <span class="hljs-number">0.5f</span>);<br><br>            Vec3f irr = <span class="hljs-built_in">IntegrateBRDF</span>(roughness, NdotV);<br><br>            data[(i * resolution + j) * <span class="hljs-number">3</span> + <span class="hljs-number">0</span>] = <span class="hljs-built_in">uint8_t</span>(irr.x * <span class="hljs-number">255.0</span>);<br>            data[(i * resolution + j) * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>] = <span class="hljs-built_in">uint8_t</span>(irr.y * <span class="hljs-number">255.0</span>);<br>            data[(i * resolution + j) * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>] = <span class="hljs-built_in">uint8_t</span>(irr.z * <span class="hljs-number">255.0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">stbi_flip_vertically_on_write</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">stbi_write_png</span>(<span class="hljs-string">&quot;GGX_E_MC_LUT.png&quot;</span>, resolution, resolution, <span class="hljs-number">3</span>, data, resolution * <span class="hljs-number">3</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Finished precomputed!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><p><img src="/img/GAMES202/GGX_E_LUT.png" alt="GGX_E_LUT 其中纵轴为粗糙度，横轴为观察角度"></p><p><strong>随机采样的问题</strong>：粗糙度从下向上增加，可以看到粗糙度较低时结果有很多噪声，这是因为低粗糙度的微表面材质接近镜面反射材质，该点接收到的光线只会被反射向一个很小的立体角。而均匀随机采样的蒙特卡洛积分很难处理这种高频信息，因此积分值的方差就会很大。<br><strong>解决方法</strong>：重要性采样。</p><h3 id="GGX-E-IS"><a href="#GGX-E-IS" class="headerlink" title="GGX_E_IS"></a>GGX_E_IS</h3><p>对于给定出射方向 o 的情况，目的是重要性采样生成入射方向 i，那么有两个核心问题需要解决：如何采样和对应的概率 pdf 是什么。</p><h4 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h4><p>我们首先根据选用的 NDF 模型，重要性采样微表面法向 m（也就是 i, o 的半程向量 h），随后利用反射关系来计算入射方向 i。</p><ul><li>$i&#x3D;2(m\cdot o)m-o$</li></ul><p>同时对于任意 NDF 下，采样 m 对应的概率密度 $pdf_m(m)$，有</p><ul><li>$pdf_m(m)&#x3D;D(m)(m\cdot n)$</li></ul><p>GGX NDF 对应的采样点应该为</p><ul><li>$\theta &#x3D;\arctan (\frac{\alpha \sqrt{\xi_ 1}}{\sqrt{1-\xi _1}})$</li><li>$\phi &#x3D;2\pi \xi _2$</li></ul><p>其中 $\xi _1$ 与 $\xi _2$ 由 Hammersley 采样得到。</p><h4 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h4><p>因为最后生成的采样方向是入射方向 i, 所以最后结果的权重应该是：</p><ul><li>$weight(i)&#x3D;\frac{f_r(i,o,h)(i,n)}{pdf_i(i)}$</li></ul><p>将之前采样微表面法线的概率密度 $pdf_m(m)$ 转换成采样入射的概率密度 $pdf_i(i)$，两者之间的转换只需要乘上一个 Jacobian 项：</p><ul><li>$pdf_i(i)&#x3D;pdf_m(m)|\frac{\partial \omega _m}{\partial \omega _i}|$</li></ul><p>对于反射有：</p><ul><li>$|\frac{\partial \omega _m}{\partial \omega _i}|&#x3D;\frac{1}{4(i\cdot m)}$</li></ul><p>所以：</p><ul><li>$weight(i)&#x3D;\frac{(o\cdot m)G(i,o,h)}{(o\cdot n)(m\cdot n)}$</li></ul><h4 id="预计算实现-1"><a href="#预计算实现-1" class="headerlink" title="预计算实现"></a>预计算实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 省略一些重复的代码</span><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">FresnelSchlick</span><span class="hljs-params">(<span class="hljs-type">float</span> HdotV, <span class="hljs-type">float</span> R0)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GeometrySchlickGGX</span><span class="hljs-params">(<span class="hljs-type">float</span> cosTerm, <span class="hljs-type">float</span> roughness)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GeometrySmith</span><span class="hljs-params">(<span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> NoV, <span class="hljs-type">float</span> NoL)</span></span>;<br><br><span class="hljs-comment">// 球面上的均匀分布</span><br><span class="hljs-function">Vec2f <span class="hljs-title">Hammersley</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> i, <span class="hljs-type">uint32_t</span> N)</span> </span>&#123; <span class="hljs-comment">// 0-1</span><br>    <span class="hljs-type">uint32_t</span> bits = (i &lt;&lt; <span class="hljs-number">16u</span>) | (i &gt;&gt; <span class="hljs-number">16u</span>);<br>    bits = ((bits &amp; <span class="hljs-number">0x55555555u</span>) &lt;&lt; <span class="hljs-number">1u</span>) | ((bits &amp; <span class="hljs-number">0xAAAAAAAAu</span>) &gt;&gt; <span class="hljs-number">1u</span>);<br>    bits = ((bits &amp; <span class="hljs-number">0x33333333u</span>) &lt;&lt; <span class="hljs-number">2u</span>) | ((bits &amp; <span class="hljs-number">0xCCCCCCCCu</span>) &gt;&gt; <span class="hljs-number">2u</span>);<br>    bits = ((bits &amp; <span class="hljs-number">0x0F0F0F0Fu</span>) &lt;&lt; <span class="hljs-number">4u</span>) | ((bits &amp; <span class="hljs-number">0xF0F0F0F0u</span>) &gt;&gt; <span class="hljs-number">4u</span>);<br>    bits = ((bits &amp; <span class="hljs-number">0x00FF00FFu</span>) &lt;&lt; <span class="hljs-number">8u</span>) | ((bits &amp; <span class="hljs-number">0xFF00FF00u</span>) &gt;&gt; <span class="hljs-number">8u</span>);<br>    <span class="hljs-type">float</span> rdi = <span class="hljs-built_in">float</span>(bits) * <span class="hljs-number">2.3283064365386963e-10</span>;<br><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">float</span>(i) / <span class="hljs-built_in">float</span>(N), rdi&#125;;<br>&#125;<br><br><span class="hljs-comment">// 重要性采样法线方向，即 H</span><br><span class="hljs-function">Vec3f <span class="hljs-title">ImportanceSampleGGX</span><span class="hljs-params">(Vec2f Xi, Vec3f N, <span class="hljs-type">float</span> roughness)</span> </span>&#123;<br>    <span class="hljs-type">float</span> a = roughness * roughness;<br><br>    <span class="hljs-comment">// 定义球面坐标系</span><br>    <span class="hljs-type">float</span> sinTheta = a * <span class="hljs-built_in">sqrt</span>(Xi.x);<br>    <span class="hljs-type">float</span> cosTheta = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.f</span> - Xi.x);<br>    <span class="hljs-type">float</span> phi = <span class="hljs-number">2</span> * PI * Xi.y;<br><br>    <span class="hljs-comment">// 球面坐标系转换为笛卡尔坐标系，单位球上半径为 1</span><br>    <span class="hljs-type">float</span> carX = sinTheta * <span class="hljs-built_in">cos</span>(phi);<br>    <span class="hljs-type">float</span> carY = sinTheta * <span class="hljs-built_in">sin</span>(phi);<br>    <span class="hljs-type">float</span> carZ = cosTheta;<br><br>    Vec3f result = <span class="hljs-built_in">Vec3f</span>(carX, carY, carZ);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">normalize</span>(result);<br>&#125;<br><br><span class="hljs-function">Vec3f <span class="hljs-title">IntegrateBRDF</span><span class="hljs-params">(<span class="hljs-type">float</span> roughness, <span class="hljs-type">float</span> NoV)</span> </span>&#123;<br>    <span class="hljs-type">float</span> A = <span class="hljs-number">0.f</span>, B = <span class="hljs-number">0.f</span>, C = <span class="hljs-number">0.f</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> sample_count = <span class="hljs-number">1024</span>;<br><br>    Vec3f N = <span class="hljs-built_in">Vec3f</span>(<span class="hljs-number">0.f</span>, <span class="hljs-number">0.f</span>, <span class="hljs-number">1.f</span>);<br>    Vec3f V = <span class="hljs-built_in">Vec3f</span>(std::<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.f</span> - NoV * NoV), <span class="hljs-number">0.f</span>, NoV);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sample_count; i++) &#123;<br>        Vec2f Xi = <span class="hljs-built_in">Hammersley</span>(i, sample_count);<br>        Vec3f H = <span class="hljs-built_in">ImportanceSampleGGX</span>(Xi, N, roughness);<br>        Vec3f L = <span class="hljs-built_in">normalize</span>(H * <span class="hljs-number">2.f</span> * <span class="hljs-built_in">dot</span>(H, V) - V);<br><br>        <span class="hljs-type">float</span> NoL = std::<span class="hljs-built_in">max</span>(L.z, <span class="hljs-number">0.f</span>);<br>        <span class="hljs-type">float</span> NoH = std::<span class="hljs-built_in">max</span>(H.z, <span class="hljs-number">0.f</span>);<br>        <span class="hljs-type">float</span> VoH = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(V, H), <span class="hljs-number">0.f</span>);<br>        <br>        <span class="hljs-type">float</span> R0 = <span class="hljs-number">1.f</span>;<br>        <span class="hljs-type">float</span> F = <span class="hljs-built_in">FresnelSchlick</span>(VoH, R0);<br>        <span class="hljs-type">float</span> G = <span class="hljs-built_in">GeometrySmith</span>(roughness, NoV, NoL);<br><br>        A += F * G * VoH / (NoV * NoH);<br>    &#125;<br>    C = B = A;<br><br>    <span class="hljs-keyword">return</span> &#123;A / sample_count, B / sample_count, C / sample_count&#125;;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> data[resolution * resolution * <span class="hljs-number">3</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">float</span> step = <span class="hljs-number">1.f</span> / resolution;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; resolution; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; resolution; j++) &#123;<br>            <span class="hljs-type">float</span> roughness = step * (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(i) + <span class="hljs-number">0.5f</span>);<br>            <span class="hljs-type">float</span> NdotV = step * (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(j) + <span class="hljs-number">0.5f</span>);<br><br>            Vec3f irr = <span class="hljs-built_in">IntegrateBRDF</span>(roughness, NdotV);<br>            <span class="hljs-comment">//Vec3f irr = Vec3f(1.f) - IntegrateBRDF(roughness, NdotV);</span><br><br>            data[(i * resolution + j) * <span class="hljs-number">3</span> + <span class="hljs-number">0</span>] = <span class="hljs-built_in">uint8_t</span>(irr.x * <span class="hljs-number">255.0</span>);<br>            data[(i * resolution + j) * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>] = <span class="hljs-built_in">uint8_t</span>(irr.y * <span class="hljs-number">255.0</span>);<br>            data[(i * resolution + j) * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>] = <span class="hljs-built_in">uint8_t</span>(irr.z * <span class="hljs-number">255.0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">stbi_flip_vertically_on_write</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">stbi_write_png</span>(<span class="hljs-string">&quot;GGX_E_LUT_IS.png&quot;</span>, resolution, resolution, <span class="hljs-number">3</span>, data, resolution * <span class="hljs-number">3</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Finished precomputed!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><p>既然已经得到了一着色点在各种条件下的出射能量 E（左图），那么需要补偿的能量便是 (1 - E)（右图）。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES202/GGX_E_LUT_IS.png" alt="GGX_E_LUT_IS"></div><div class="group-image-wrap"><img src="/img/GAMES202/GGX_E_LUT_IS_ANTI.png" alt="GGX_E_LUT_IS_ANTI"></div></div></div><h3 id="GGX-Eavg"><a href="#GGX-Eavg" class="headerlink" title="GGX_Eavg"></a>GGX_Eavg</h3><p>上面说到我们希望能得到一个 BRDF，并且该公式在半球上的积分值为 (1 - E)，即：</p><ul><li>$\int f_{ms}(\mu _o,\mu _i)&#x3D;\int \frac{(1-E(\mu _o))(1-E(\mu <em>i))}{\pi (1-E</em>{avg})}&#x3D;1-E(\mu _o)$</li></ul><p>其中：</p><ul><li>$E_{avg}(\mu _o)&#x3D;2\int _o^1E(\mu _i)\mu _id\mu _i$</li></ul><p>推导：</p><ul><li>$E_{ms}(\mu _o)&#x3D;\int _0^{2\pi}\int <em>0^1f</em>{ms}(\mu _o,\mu _1,\phi)$</li><li>&emsp;&emsp;&emsp;&emsp;&nbsp;$&#x3D;2\pi \int _0^1\frac{(1-E(\mu _o))(1-E(\mu <em>i))}{\pi (1-E</em>{avg})}\mu _id\mu _i$</li><li>&emsp;&emsp;&emsp;&emsp;&nbsp;$&#x3D;2\frac{1-E(\mu <em>o)}{1-E</em>{avg}}\int _0^1(1-E(\mu _i))\mu _id\mu _i$</li><li>&emsp;&emsp;&emsp;&emsp;&nbsp;$&#x3D;\frac{1-E(\mu <em>o)}{1-E</em>{avg}}(1-E_{avg})$</li><li>&emsp;&emsp;&emsp;&emsp;&nbsp;$&#x3D;(1-E_{avg})$</li></ul><p>也就是说只要再给$E_{avg}$打一张表，就可以实时地查询预计算的信息得到$f_{ms}$了。</p><h4 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h4><p>使用重要性采样（左图），使用均匀采样（右图）</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES202/GGX_Eavg_LUT_IS.png" alt="GGX_Eavg_LUT_IS"></div><div class="group-image-wrap"><img src="/img/GAMES202/GGX_Eavg_LUT.png" alt="GGX_Eavg_LUT"></div></div></div><p>这是一张一维的表，纵轴为粗糙度从下向上增加，而同一行上的存储值是相同的。</p><h2 id="Real-Time-部分-1"><a href="#Real-Time-部分-1" class="headerlink" title="Real Time 部分"></a>Real Time 部分</h2><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>当材质拥有颜色时，颜色的性质会自然地、正确地带来能量的损失。那么在实现无色的 $f_{ms}$ 的基础上，将一考虑颜色带来的能量损失的颜色项 $f_{add}$（三通道）与$f_{ms}$ 相乘便能得到最终需要补充的 BRDF。<br>先引入一个概念：平均菲涅尔项 $F_{avg}$（三通道）<br><a href="https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf">Favg 的实现</a><br>那么一次反射后出射的能量为：$F_{avg}E_{avg}$<br>两次反射后出射的能量为：$F_{avg}(1-E_{avg})F_{avg}E_{avg}$<br>K 次反射后出射的能量为：$F_{avg}^k(1-E_{avg})^kF_{avg}E_{avg}$<br>上述能量全部叠加即可得到颜色项：</p><ul><li>$f_{add}&#x3D;\frac{F_{avg}E_{avg}}{1-F_{avg}(1-E_{avg})}$</li></ul><h3 id="最终的-BRDF"><a href="#最终的-BRDF" class="headerlink" title="最终的 BRDF"></a>最终的 BRDF</h3><p>之前我们得到了补偿的 BRDF 项：</p><ul><li>$f_{ms}(\mu _o,\mu _i)&#x3D;\frac{(1-E(\mu _o))(1-E(\mu <em>i))}{\pi (1-E</em>{avg})}$</li></ul><p>最终的 BRDF 便是：</p><ul><li>$f_r&#x3D;f_{micro}+f_{add}f_{ms}$</li></ul><h3 id="KullaContyFragmentShader"><a href="#KullaContyFragmentShader" class="headerlink" title="KullaContyFragmentShader"></a>KullaContyFragmentShader</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#ifdef GL_ES</span><br><span class="hljs-keyword">precision</span> <span class="hljs-keyword">mediump</span> <span class="hljs-type">float</span>;<br><span class="hljs-meta">#endif</span><br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uLightPos;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uCameraPos;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uLightRadiance;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uLightDir;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uAlbedoMap;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> uMetallic;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> uRoughness;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uBRDFLut;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uEavgLut;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">samplerCube</span> uCubeTexture;<br><br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec2</span> vTextureCoord;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vFragPos;<br><span class="hljs-keyword">varying</span> <span class="hljs-keyword">highp</span> <span class="hljs-type">vec3</span> vNormal;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> PI = <span class="hljs-number">3.14159265359</span>;<br><br><span class="hljs-type">float</span> DistributionGGX(<span class="hljs-type">vec3</span> N, <span class="hljs-type">vec3</span> H, <span class="hljs-type">float</span> roughness) &#123;<br>    <span class="hljs-type">float</span> a = roughness * roughness;<br>    <span class="hljs-type">float</span> a2 = a * a;<br>    <span class="hljs-type">float</span> NdotH = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, H), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-type">float</span> NdotH2 = NdotH * NdotH;<br><br>    <span class="hljs-type">float</span> nom = a2;<br>    <span class="hljs-type">float</span> denom = (NdotH2 * (a2 - <span class="hljs-number">1.0</span>) + <span class="hljs-number">1.0</span>);<br>    denom = PI * denom * denom;<br><br>    <span class="hljs-keyword">return</span> nom / denom;<br>&#125;<br><br><span class="hljs-type">float</span> GeometrySchlickGGX(<span class="hljs-type">float</span> cosTerm, <span class="hljs-type">float</span> roughness) &#123;<br>    <span class="hljs-type">float</span> a = roughness;<br>    <span class="hljs-type">float</span> k = (a * a) / <span class="hljs-number">2.0</span>;<br><br>    <span class="hljs-type">float</span> nom = cosTerm;<br>    <span class="hljs-type">float</span> denom = cosTerm * (<span class="hljs-number">1.0</span> - k) + k;<br><br>    <span class="hljs-keyword">return</span> nom / denom;<br>&#125;<br><br><span class="hljs-type">float</span> GeometrySmith(<span class="hljs-type">vec3</span> N, <span class="hljs-type">vec3</span> V, <span class="hljs-type">vec3</span> L, <span class="hljs-type">float</span> roughness) &#123;<br>    <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,L), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-type">float</span> NdotV = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N,V), <span class="hljs-number">0.0</span>);<br><br>    <span class="hljs-type">float</span> ggx2 = GeometrySchlickGGX(NdotV, roughness);<br>    <span class="hljs-type">float</span> ggx1 = GeometrySchlickGGX(NdotL, roughness);<br><br>    <span class="hljs-keyword">return</span> ggx1 * ggx2;<br>&#125;<br><br><span class="hljs-type">vec3</span> fresnelSchlick(<span class="hljs-type">vec3</span> F0, <span class="hljs-type">vec3</span> V, <span class="hljs-type">vec3</span> H) &#123;<br>    <span class="hljs-type">float</span> HdotV = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(H, V), <span class="hljs-number">0.0</span>);<br><br>    <span class="hljs-keyword">return</span> F0 + (<span class="hljs-number">1.0</span> - F0) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.0</span> - HdotV, <span class="hljs-number">5.0</span>);<br>&#125;<br><br><br><span class="hljs-comment">/* https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/</span><br><span class="hljs-comment">   s2017_pbs_imageworks_slides_v2.pdf */</span><br><span class="hljs-type">vec3</span> AverageFresnel(<span class="hljs-type">vec3</span> r, <span class="hljs-type">vec3</span> g) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(<span class="hljs-number">0.087237</span>) + <span class="hljs-number">0.0230685</span>*g - <span class="hljs-number">0.0864902</span>*g*g + <span class="hljs-number">0.0774594</span>*g*g*g<br>           + <span class="hljs-number">0.782654</span>*r - <span class="hljs-number">0.136432</span>*r*r + <span class="hljs-number">0.278708</span>*r*r*r<br>           + <span class="hljs-number">0.19744</span>*g*r + <span class="hljs-number">0.0360605</span>*g*g*r - <span class="hljs-number">0.2586</span>*g*r*r;<br>&#125;<br><br><span class="hljs-type">vec3</span> MultiScatterBRDF(<span class="hljs-type">float</span> NdotL, <span class="hljs-type">float</span> NdotV) &#123;<br>  <span class="hljs-type">vec3</span> albedo = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">texture2D</span>(uAlbedoMap, vTextureCoord).rgb, <span class="hljs-type">vec3</span>(<span class="hljs-number">2.2</span>));<br><br>  <span class="hljs-type">vec3</span> E_o = <span class="hljs-built_in">texture2D</span>(uBRDFLut, <span class="hljs-type">vec2</span>(NdotL, uRoughness)).xyz;<br>  <span class="hljs-type">vec3</span> E_i = <span class="hljs-built_in">texture2D</span>(uBRDFLut, <span class="hljs-type">vec2</span>(NdotV, uRoughness)).xyz;<br><br>  <span class="hljs-type">vec3</span> E_avg = <span class="hljs-built_in">texture2D</span>(uEavgLut, <span class="hljs-type">vec2</span>(<span class="hljs-number">0</span>, uRoughness)).xyz;<br>  <span class="hljs-comment">// copper</span><br>  <span class="hljs-type">vec3</span> edgetint = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.827</span>, <span class="hljs-number">0.792</span>, <span class="hljs-number">0.678</span>);<br>  <span class="hljs-type">vec3</span> F_avg = AverageFresnel(albedo, edgetint);<br>  <br>  <span class="hljs-type">vec3</span> fms = (<span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) - E_o) * (<span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) - E_i) / (PI * (<span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) - E_avg));<br>  <span class="hljs-type">vec3</span> F_add = F_avg * E_avg / (<span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) - F_avg * (<span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) - E_avg));<br><br>  <span class="hljs-keyword">return</span> F_add*fms;<br>&#125;<br><br><span class="hljs-type">void</span> main(<span class="hljs-type">void</span>) &#123;<br>  <span class="hljs-type">vec3</span> albedo = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">texture2D</span>(uAlbedoMap, vTextureCoord).rgb, <span class="hljs-type">vec3</span>(<span class="hljs-number">2.2</span>));<br><br>  <span class="hljs-type">vec3</span> N = <span class="hljs-built_in">normalize</span>(vNormal);<br>  <span class="hljs-type">vec3</span> V = <span class="hljs-built_in">normalize</span>(uCameraPos - vFragPos);<br>  <span class="hljs-type">float</span> NdotV = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, V), <span class="hljs-number">0.0</span>);<br><br>  <span class="hljs-type">vec3</span> F0 = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.04</span>); <br>  F0 = <span class="hljs-built_in">mix</span>(F0, albedo, uMetallic);<br><br>  <span class="hljs-type">vec3</span> Lo = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);<br><br>  <span class="hljs-comment">// calculate per-light radiance</span><br>  <span class="hljs-type">vec3</span> L = <span class="hljs-built_in">normalize</span>(uLightDir);<br>  <span class="hljs-type">vec3</span> H = <span class="hljs-built_in">normalize</span>(V + L);<br>  <span class="hljs-type">float</span> <span class="hljs-built_in">distance</span> = <span class="hljs-built_in">length</span>(uLightPos - vFragPos);<br>  <span class="hljs-type">float</span> attenuation = <span class="hljs-number">1.0</span> / (<span class="hljs-built_in">distance</span> * <span class="hljs-built_in">distance</span>);<br>  <span class="hljs-type">vec3</span> radiance = uLightRadiance;<br><br>  <span class="hljs-type">float</span> NDF = DistributionGGX(N, H, uRoughness);   <br>  <span class="hljs-type">float</span> G   = GeometrySmith(N, V, L, uRoughness);<br>  <span class="hljs-type">vec3</span> F = fresnelSchlick(F0, V, H);<br>      <br>  <span class="hljs-type">vec3</span> numerator    = NDF * G * F; <br>  <span class="hljs-type">float</span> denominator = <span class="hljs-number">4.0</span> * <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, V), <span class="hljs-number">0.0</span>) * <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0.0</span>);<br>  <span class="hljs-type">vec3</span> Fmicro = numerator / <span class="hljs-built_in">max</span>(denominator, <span class="hljs-number">0.001</span>); <br>  <br>  <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0.0</span>);        <br><br>  <span class="hljs-type">vec3</span> Fms = MultiScatterBRDF(NdotL, NdotV);<br>  <span class="hljs-type">vec3</span> BRDF = Fmicro + Fms;<br>  <br>  Lo += BRDF * radiance * NdotL;<br>  <span class="hljs-type">vec3</span> color = Lo;<br>  <br>  color = color / (color + <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>));<br>  color = <span class="hljs-built_in">pow</span>(color, <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>/<span class="hljs-number">2.2</span>)); <br>  <br>  <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(color, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-6"><a href="#结果-6" class="headerlink" title="结果"></a>结果</h2><p><img src="/img/GAMES202/01.png"><br>粗糙度从右至左依次增加，上排是正确实现了 Kulla-Conty 近似的结果，下排是微表面模型不使用 Kulla-Conty 近似时造成的能量损失。</p><h1 id="实时光线追踪"><a href="#实时光线追踪" class="headerlink" title="实时光线追踪"></a>实时光线追踪</h1><p>&emsp;&emsp;如果认为，以路径追踪的方式，计算一次<strong>一着色点的直接光照和一次弹射的间接光照</strong>为 1 sample per pixel (1 SPP)。那么对于一帧，即使是 RTX 系列的 GPU 也只能做到 1 SPP，此时的噪声会非常夸张。但是路径追踪依旧为我们提供了非常宝贵的间接光照信息，那么接下来工作的重心就在如何降噪上了。降噪分为两个部分，单帧降噪与像素在时间上的复用。</p><h2 id="单帧降噪"><a href="#单帧降噪" class="headerlink" title="单帧降噪"></a>单帧降噪</h2><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>与其他滤波方式类似，双边滤波也使用周围像素的加权平均值代替中心像素值。重要的是双边滤波的权重不仅考虑了像素的欧氏距离（比如高斯滤波只考虑距离对权值的影响），还考虑了滤波范围域中的辐射差异。<br>假设 (i, j) 为中心像素 (k, l) 为周围一像素，如果我们希望两像素之间的差异（距离，颜色）越大贡献越小：</p><ul><li>$w(i,j,k,l)&#x3D;exp(-\frac{(i-k)^2+(j-l)^2}{2\sigma _d^2}-\frac{|I(i,j)-I(k,l)|^2}{2\sigma _r^2})$</li></ul><h3 id="联合双边滤波"><a href="#联合双边滤波" class="headerlink" title="联合双边滤波"></a>联合双边滤波</h3><p>既然现在是在图形学中进行滤波，那么我们可以很轻易地从渲染管线中扒拉出更多有参考价值的信息，比如说任意像素的深度信息、世界坐标、法线方向等，甚至为不同的物体进行编号，只要将这些信息存在一张 Buffer 中即可。<br>联合双边滤波便是将这些属性的差异也考虑进权重的计算内，滤波核以任何一种会向 0 衰减的函数描述即可。<br>假设 i 为中心像素 j 为周围一像素，这次用到的滤波核：</p><ul><li>$J(i,j)&#x3D;exp(-\frac{|i-j|^2}{2\sigma _p^2}-\frac{|\widetilde{C}[i]-\widetilde{C}[j]|^2}{2\sigma <em>c^2}-\frac{D</em>{normal}(i,j)^2}{2\sigma <em>n^2}-\frac{D</em>{plane}(i,j)^2}{2\sigma _d^2})$</li></ul><p>其中：</p><ul><li>$\widetilde{C}$：有噪声的输入图像。</li><li>$D_{normal}(i,j)&#x3D;arccos(Normal[i]\cdot Normal[j])$：<br>某一夹角左右两平面上的像素不应当有太多贡献。</li><li>$D_{plane}(i,j)&#x3D;Normal[i]\cdot \frac{Position[i]-Position[i]}{|Position[j]-Position[i]}$：<br>法线相似但是有高低差的两平面上的像素不应当有太多贡献。</li></ul><h3 id="a-trous-wavelet-transform"><a href="#a-trous-wavelet-transform" class="headerlink" title="a-trous wavelet transform"></a>a-trous wavelet transform</h3><p>假如要遍历完 NxN 个像素会是一个较大的性能开销，这里使用 a-trous wavelet transform 的方式加速采样滤波核内的像素。每一趟固定采样 5x5 个像素，第 i 趟时采样点之间的距离为 $2^{i-1}$。<br>时间复杂度从$o(n^2)$降低为$o(log _2n)$。<br><img src="/img/GAMES202/at.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">DistanceDifPow</span><span class="hljs-params">(<span class="hljs-type">int</span> i_x, <span class="hljs-type">int</span> i_y, <span class="hljs-type">int</span> j_x, <span class="hljs-type">int</span> j_y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(<span class="hljs-built_in">pow</span>((i_x - j_x), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>((i_y - j_y), <span class="hljs-number">2</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">CloorDifPow</span><span class="hljs-params">(Float3 color_i, Float3 color_j)</span> </span>&#123;<br>    Float3 dif = color_i - color_j;<br>    <span class="hljs-keyword">return</span> dif.x * dif.x + dif.y * dif.y + dif.z * dif.z;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">DnormalPow</span><span class="hljs-params">(Float3 normal_i, Float3 normal_j)</span> </span>&#123;<br>    <span class="hljs-type">float</span> cosTerm = std::<span class="hljs-built_in">clamp</span>(<span class="hljs-built_in">Dot</span>(normal_i, normal_j), <span class="hljs-number">0.f</span>, <span class="hljs-number">1.f</span>);<br>    <span class="hljs-type">float</span> acos = std::<span class="hljs-built_in">acos</span>(cosTerm);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(acos, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">DplanePow</span><span class="hljs-params">(Float3 normal_i, Float3 position_i, Float3 position_j)</span> </span>&#123;<br>    Float3 nor = <span class="hljs-built_in">Normalize</span>(position_j - position_i);<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">clamp</span>((<span class="hljs-type">float</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-built_in">Dot</span>(normal_i, nor), <span class="hljs-number">2</span>), <span class="hljs-number">1e-5f</span>, <span class="hljs-number">1.f</span>);<br>&#125;<br><br><span class="hljs-comment">// 联合双边滤波核</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">JointBilateralFilteringKernel</span><span class="hljs-params">(<span class="hljs-type">float</span> distanceDifPow, <span class="hljs-type">float</span> colorDifPow,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">float</span> normalDifPow, <span class="hljs-type">float</span> positionDifPow,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">float</span> sigma_p, <span class="hljs-type">float</span> sigma_c,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">float</span> sigma_n, <span class="hljs-type">float</span> sigma_d)</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-(distanceDifPow / (<span class="hljs-number">2</span> * <span class="hljs-built_in">pow</span>(sigma_p, <span class="hljs-number">2</span>))) -<br>            (colorDifPow / (<span class="hljs-number">2</span> * <span class="hljs-built_in">pow</span>(sigma_c, <span class="hljs-number">2</span>))) -<br>            (normalDifPow / (<span class="hljs-number">2</span> * <span class="hljs-built_in">pow</span>(sigma_n, <span class="hljs-number">2</span>))) -<br>            (positionDifPow / (<span class="hljs-number">2</span> * <span class="hljs-built_in">pow</span>(sigma_d, <span class="hljs-number">2</span>))));<br>&#125;<br><br><span class="hljs-function">Buffer2D&lt;Float3&gt; <span class="hljs-title">Denoiser::Filter</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo &amp;frameInfo)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = frameInfo.m_beauty.m_height;<br>    <span class="hljs-type">int</span> width = frameInfo.m_beauty.m_width;<br>    <span class="hljs-type">int</span> kernelRadius = <span class="hljs-number">16</span>;<br><br>    Buffer2D&lt;Float3&gt; filteredImage = <span class="hljs-built_in">CreateBuffer2D</span>&lt;Float3&gt;(width, height);<br>    Buffer2D&lt;Float3&gt; imageBuffer = <span class="hljs-built_in">CreateBuffer2D</span>&lt;Float3&gt;(width, height);<br>    Buffer2D&lt;Float3&gt; normalBuffer = <span class="hljs-built_in">CreateBuffer2D</span>&lt;Float3&gt;(width, height);<br>    Buffer2D&lt;Float3&gt; positionBuffer = <span class="hljs-built_in">CreateBuffer2D</span>&lt;Float3&gt;(width, height);<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-built_in">filteredImage</span>(x, y) = frameInfo.<span class="hljs-built_in">m_beauty</span>(x, y);<br>            <span class="hljs-built_in">imageBuffer</span>(x, y) = frameInfo.<span class="hljs-built_in">m_beauty</span>(x, y);<br>            <span class="hljs-built_in">normalBuffer</span>(x, y) = frameInfo.<span class="hljs-built_in">m_normal</span>(x, y);<br>            <span class="hljs-built_in">positionBuffer</span>(x, y) = frameInfo.<span class="hljs-built_in">m_position</span>(x, y);<br><br>            <span class="hljs-comment">// 权重</span><br>            <span class="hljs-type">float</span> weight = <span class="hljs-number">0.f</span>;<br>            <span class="hljs-comment">// a-trous wavelet 的步长</span><br>            <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;<br><br>            <span class="hljs-type">bool</span> useA_trou = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (useA_trou) &#123;<br>                <span class="hljs-comment">// 第一个循环确定 filter 大小，第二第三个循环的内容固定地循环 25 次。</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-number">2</span> * step &lt;= kernelRadius; num++) &#123;<br>                    step = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j_y = y - <span class="hljs-number">2</span> * step; j_y &lt;= y + <span class="hljs-number">2</span> * step; j_y += step) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j_x = x - <span class="hljs-number">2</span> * step; j_x &lt;= x + <span class="hljs-number">2</span> * step; j_x += step) &#123;<br><br>                            <span class="hljs-keyword">if</span> (j_y &lt; <span class="hljs-number">0</span> || j_y &gt;= height || j_x &lt; <span class="hljs-number">0</span> || j_x &gt;= width) &#123;<br>                                <span class="hljs-comment">// 超出图像范围时返回</span><br>                                <span class="hljs-keyword">continue</span>;<br>                            &#125;<br><br>                            <span class="hljs-built_in">imageBuffer</span>(j_x, j_y) = frameInfo.<span class="hljs-built_in">m_beauty</span>(j_x, j_y);<br>                            <span class="hljs-built_in">normalBuffer</span>(j_x, j_y) = frameInfo.<span class="hljs-built_in">m_normal</span>(j_x, j_y);<br>                            <span class="hljs-built_in">positionBuffer</span>(j_x, j_y) = frameInfo.<span class="hljs-built_in">m_position</span>(j_x, j_y);<br><br>                            <span class="hljs-type">float</span> distanceTerm = <span class="hljs-built_in">DistanceDifPow</span>(x, y, j_x, j_y);<br>                            <span class="hljs-type">float</span> colorTerm =<br>                                <span class="hljs-built_in">CloorDifPow</span>(<span class="hljs-built_in">imageBuffer</span>(x, y), <span class="hljs-built_in">imageBuffer</span>(j_x, j_y));<br>                            <span class="hljs-type">float</span> normalTerm =<br>                                <span class="hljs-built_in">DnormalPow</span>(<span class="hljs-built_in">normalBuffer</span>(x, y), <span class="hljs-built_in">normalBuffer</span>(j_x, j_y));<br>                            <span class="hljs-type">float</span> planeTerm =<br>                                <span class="hljs-built_in">DplanePow</span>(<span class="hljs-built_in">normalBuffer</span>(x, y),<br>                                    <span class="hljs-built_in">positionBuffer</span>(x, y), <span class="hljs-built_in">positionBuffer</span>(j_x, j_y));<br><br>                            <span class="hljs-keyword">if</span> (width &gt;= <span class="hljs-number">1280</span>) &#123;<br>                                <span class="hljs-comment">// pink-room</span><br>                                m_sigmaColor = <span class="hljs-number">20</span>;<br>                            &#125;<br><br>                            <span class="hljs-type">float</span> exp = <span class="hljs-built_in">JointBilateralFilteringKernel</span>(<br>                                distanceTerm, colorTerm, normalTerm, planeTerm,<br>                                m_sigmaCoord, m_sigmaColor, m_sigmaNormal, m_sigmaPlane);<br><br>                            <span class="hljs-built_in">filteredImage</span>(x, y) += <span class="hljs-built_in">imageBuffer</span>(j_x, j_y) * exp;<br>                            weight += exp;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// useA_trou == false</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j_y = y - kernelRadius; j_y &lt;= y + kernelRadius; ++j_y) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j_x = x - kernelRadius; j_x &lt;= x + kernelRadius; ++j_x) &#123;<br>                        <span class="hljs-keyword">if</span> (j_y &lt; <span class="hljs-number">0</span> || j_y &gt;= height || j_x &lt; <span class="hljs-number">0</span> || j_x &gt;= width) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-built_in">imageBuffer</span>(j_x, j_y) = frameInfo.<span class="hljs-built_in">m_beauty</span>(j_x, j_y);<br>                        <span class="hljs-built_in">normalBuffer</span>(j_x, j_y) = frameInfo.<span class="hljs-built_in">m_normal</span>(j_x, j_y);<br>                        <span class="hljs-built_in">positionBuffer</span>(j_x, j_y) = frameInfo.<span class="hljs-built_in">m_position</span>(j_x, j_y);<br>                        <span class="hljs-type">float</span> distanceTerm = <span class="hljs-built_in">DistanceDifPow</span>(x, y, j_x, j_y);<br>                        <span class="hljs-type">float</span> colorTerm =<br>                            <span class="hljs-built_in">CloorDifPow</span>(<span class="hljs-built_in">imageBuffer</span>(x, y), <span class="hljs-built_in">imageBuffer</span>(j_x, j_y));<br>                        <span class="hljs-type">float</span> normalTerm =<br>                            <span class="hljs-built_in">DnormalPow</span>(<span class="hljs-built_in">normalBuffer</span>(x, y), <span class="hljs-built_in">normalBuffer</span>(j_x, j_y));<br>                        <span class="hljs-type">float</span> planeTerm =<br>                            <span class="hljs-built_in">DplanePow</span>(<span class="hljs-built_in">normalBuffer</span>(x, y),<br>                                <span class="hljs-built_in">positionBuffer</span>(x, y), <span class="hljs-built_in">positionBuffer</span>(j_x, j_y));<br>                        <span class="hljs-keyword">if</span> (width &gt;= <span class="hljs-number">1280</span>) &#123; <span class="hljs-comment">// for pink-room</span><br>                            m_sigmaColor = <span class="hljs-number">30</span>;<br>                        &#125;<br>                        <span class="hljs-type">float</span> exp = <span class="hljs-built_in">JointBilateralFilteringKernel</span>(<br>                            distanceTerm, colorTerm, normalTerm, planeTerm,<br>                            m_sigmaCoord, m_sigmaColor, m_sigmaNormal, m_sigmaPlane);<br>                        <span class="hljs-built_in">filteredImage</span>(x, y) += <span class="hljs-built_in">imageBuffer</span>(j_x, j_y) * exp;<br>                        weight += exp;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (weight &gt; <span class="hljs-number">0.f</span>) &#123;<br>                <span class="hljs-built_in">filteredImage</span>(x, y) /= weight;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">filteredImage</span>(x, y) = <span class="hljs-number">0.f</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> filteredImage;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果-7"><a href="#结果-7" class="headerlink" title="结果"></a>结果</h3><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES202/n.gif" alt="1 SPP"></div><div class="group-image-wrap"><img src="/img/GAMES202/f.gif" alt="单帧降噪"></div></div></div><div class="note note-secondary">            <p><strong>滤波之后亮度提高的原因</strong>：事实上第二张图的亮度并没有提高，第一张图的辐射期望也是正确的。第一张图的亮度看起来偏暗是由于路径追踪的方差过大，以至于有大量超过 RGB 色域显示范围的 Irradiance 被直接 Clamp 至 255，产生了能量损失。在第二张图中进行滤波便是将无法显示的数值分配给了周围的像素，使得这部分数值可以正常地被显示出来。</p>          </div><h2 id="时间上的累积"><a href="#时间上的累积" class="headerlink" title="时间上的累积"></a>时间上的累积</h2><p>先将当前帧做单帧滤波，然后把一像素点在上一帧所在位置的像素值按一定权值混合入当前帧。如果说每一帧都能做 1 SPP，那么便几乎相当于一秒内将 30 SPP 的采样结果累积了下来。</p><h3 id="投影到上一帧"><a href="#投影到上一帧" class="headerlink" title="投影到上一帧"></a>投影到上一帧</h3><p>第一个问题，如何找到一像素点在上一帧所对应的位置，准确来说是：一像素点对应世界坐标变换回上一帧的世界坐标，然后变换至上一帧的屏幕空间的坐标。<br>公式如下： </p><ul><li>$Screen_{i-1}&#x3D;P_{i-1}V_{i-1}M_{i-1}M_i^{-1}World_i$</li></ul><p>其中：</p><ul><li>下角标的 i 代表第 i 帧</li><li>M 代表物体坐标系到世界坐标系的矩阵</li><li>V 代表世界坐标系到摄像机坐标系的矩阵</li><li>P 代表摄像机坐标系到屏幕坐标系的矩阵</li></ul><p>得到上一帧的屏幕空间坐标后需要检查：</p><ol><li>上一帧是否在屏幕内。（该点第一次出现于屏幕内，没有时间上的信息）</li><li>上一帧和当前帧的物体的标号。（该点上一帧被另一物体遮挡，不应当使用时间上的信息）</li></ol><p>若坐标非法便不使用上一帧的数据，100% 使用当前帧的数据。投影坐标的合法性保存在 m_valid 中供下一步参考。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser::Reprojection</span><span class="hljs-params">(<span class="hljs-type">const</span> FrameInfo&amp; frameInfo)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = m_accColor.m_height;<br>    <span class="hljs-type">int</span> width = m_accColor.m_width;<br>    Matrix4x4 preWorldToScreen =<br>        m_preFrameInfo.m_matrix[m_preFrameInfo.m_matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br><br>            <span class="hljs-type">int</span> id = (<span class="hljs-type">int</span>)frameInfo.<span class="hljs-built_in">m_id</span>(x, y);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> != id) &#123;<br>                Matrix4x4 invModel = <span class="hljs-built_in">Inverse</span>(frameInfo.m_matrix[id]);<br>                Matrix4x4 preModel = m_preFrameInfo.m_matrix[id];<br>                Matrix4x4 PVMM_1 = preWorldToScreen * preModel * invModel;<br>                Float3 projPos = <span class="hljs-built_in">PVMM_1</span>(frameInfo.<span class="hljs-built_in">m_position</span>(x, y), Float3::Point);<br><br>                <span class="hljs-comment">//Float3 invPos = invModel(frameInfo.m_position(x, y), Float3::Point);</span><br>                <span class="hljs-comment">//Float3 prePos = preModel(invPos, Float3::Point);</span><br>                <span class="hljs-comment">//Float3 projPos = preWorldToScreen(prePos, Float3::Point);</span><br><br>                <span class="hljs-type">int</span> pre_x = (<span class="hljs-type">int</span>)projPos.x;<br>                <span class="hljs-type">int</span> pre_y = (<span class="hljs-type">int</span>)projPos.y;<br>                <span class="hljs-keyword">if</span> (pre_x &lt; <span class="hljs-number">0</span> || pre_x &gt;= width || pre_y &lt; <span class="hljs-number">0</span> || pre_y &gt;= height) &#123;<br>                    <span class="hljs-built_in">m_valid</span>(x, y) = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 在 pre_x 或 pre_y 超出屏幕时 m_id(pre_x, pre_y) 属于违法操作。</span><br>                <span class="hljs-type">int</span> pre_id = (<span class="hljs-type">int</span>)m_preFrameInfo.<span class="hljs-built_in">m_id</span>(pre_x, pre_y);<br>                <span class="hljs-keyword">if</span> (pre_id != id) &#123;<br>                    <span class="hljs-built_in">m_valid</span>(x, y) = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-built_in">m_misc</span>(x, y) = <span class="hljs-built_in">m_accColor</span>(pre_x, pre_y);<br>                <span class="hljs-built_in">m_valid</span>(x, y) = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//m_valid(x, y) = false;</span><br>            <span class="hljs-comment">//m_misc(x, y) = Float3(0.f);</span><br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(m_misc, m_accColor);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="混合入当前帧"><a href="#混合入当前帧" class="headerlink" title="混合入当前帧"></a>混合入当前帧</h3><p>将已降噪的当前帧$\overline{C}<em>i$与上一帧的结果$\overline{C}</em>{i-1}$进行融合，公式如下：</p><ul><li>$\overline{C}_i&#x3D;\alpha \overline{C}<em>i+(1-\alpha)Clamp(\overline{C}</em>{i-1})$</li></ul><p>如果上一帧的坐标非法，$\alpha$ 便为 1。</p><h4 id="Clamp"><a href="#Clamp" class="headerlink" title="Clamp"></a>Clamp</h4><p>计算 $\overline{C}_i$ 在 5x5 领域内的均值 $\mu$ 与方差 $\sigma$，然后将上一帧的颜色值 Clapm 进 $(\mu -k\sigma,\mu +k\sigma)$ 内。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Denoiser::TemporalAccumulation</span><span class="hljs-params">(<span class="hljs-type">const</span> Buffer2D&lt;Float3&gt; &amp;curFilteredColor)</span> </span>&#123;<br>    <span class="hljs-type">int</span> height = m_accColor.m_height;<br>    <span class="hljs-type">int</span> width = m_accColor.m_width;<br>    <span class="hljs-type">int</span> range = <span class="hljs-number">2</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; height; y++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; width; x++) &#123;<br>            <span class="hljs-comment">/* TemporalAccumulation 在 Reprojection 之后被调用，</span><br><span class="hljs-comment">            所以这里的 m_accColor 是上一帧的结果。*/</span><br>            Float3 preColor = <span class="hljs-built_in">m_accColor</span>(x, y);<br><br>            <span class="hljs-function">Float3 <span class="hljs-title">mu</span><span class="hljs-params">(<span class="hljs-number">0.f</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x - range; i &lt;= x + range; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y - range; j &lt;= y + range; j++) &#123;<br>                    mu += <span class="hljs-built_in">curFilteredColor</span>(i, j);<br>                &#125;<br>            &#125;<br>            mu /= (<span class="hljs-type">float</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">2.f</span> * range + <span class="hljs-number">1.f</span>, <span class="hljs-number">2</span>);<br><br>            <span class="hljs-function">Float3 <span class="hljs-title">sigma</span><span class="hljs-params">(<span class="hljs-number">0.f</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x - range; i &lt;= x + range; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y - range; j &lt;= y + range; j++) &#123;<br>                    sigma += <span class="hljs-built_in">Sqr</span>(<span class="hljs-built_in">curFilteredColor</span>(i, j) - mu);<br>                &#125;<br>            &#125;<br>            sigma /= (<span class="hljs-type">float</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">2.f</span> * range + <span class="hljs-number">1.f</span>, <span class="hljs-number">2</span>);<br><br>            <span class="hljs-keyword">if</span> (width &gt;= <span class="hljs-number">1280</span>) &#123;<br>                <span class="hljs-comment">// pink-room</span><br>                m_colorBoxK = <span class="hljs-number">0.1f</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 将上一帧对应的像素的值拉近当前帧像素</span><br>            preColor = <span class="hljs-built_in">Clamp</span>(preColor,<br>                mu - sigma * m_colorBoxK, mu + sigma * m_colorBoxK);<br><br>            <span class="hljs-type">float</span> alpha = <span class="hljs-number">1.0f</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">m_valid</span>(x, y)) &#123;<br>                alpha = m_alpha;<br>            &#125;<br>            <span class="hljs-built_in">m_misc</span>(x, y) = <span class="hljs-built_in">Lerp</span>(preColor, <span class="hljs-built_in">curFilteredColor</span>(x, y), alpha);<br>            <span class="hljs-comment">//m_misc(x, y) = Lerp(preColor, curFilteredColor(x, y), 1.0f);</span><br>        &#125;<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(m_misc, m_accColor);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果-8"><a href="#结果-8" class="headerlink" title="结果"></a>结果</h4><p><img src="/img/GAMES202/t.gif"></p>]]></content>
    
    
    
    <tags>
      
      <tag>GlobalIllumination</tag>
      
      <tag>Math</tag>
      
      <tag>Rendering</tag>
      
      <tag>RayTracing</tag>
      
      <tag>GLSL</tag>
      
      <tag>JavaScript</tag>
      
      <tag>Reflection</tag>
      
      <tag>Shadow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>辐射度量学基础</title>
    <link href="/2021/09/14/Radiometry/"/>
    <url>/2021/09/14/Radiometry/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>&emsp;&emsp;路径追踪的前置知识。</p><h2 id="物理量一览"><a href="#物理量一览" class="headerlink" title="物理量一览"></a>物理量一览</h2><table><thead><tr><th align="center">符号</th><th align="left">名称</th><th align="center">单位</th><th align="left">光度学名称</th><th align="center">光度学单位</th></tr></thead><tbody><tr><td align="center">Q</td><td align="left">Radiant Energy</td><td align="center">J</td><td align="left">Luminous Energy</td><td align="center">lm.s</td></tr><tr><td align="center">$\phi$</td><td align="left">Radiant Flux</td><td align="center">$\frac{J}{s}$ &#x2F; Watt(W)</td><td align="left">Luminous Flux</td><td align="center">Lumen(lm)</td></tr><tr><td align="center">I</td><td align="left">Radiant Intensity</td><td align="center">$\frac{W}{sr}$</td><td align="left">Luminous Intensity</td><td align="center">Candela(cd)</td></tr><tr><td align="center">E</td><td align="left">Irradiance</td><td align="center">$\frac{W}{m^2}$</td><td align="left">Illuminance</td><td align="center">Lux(lx)</td></tr><tr><td align="center">L</td><td align="left">Radiance</td><td align="center">$\frac{W}{m^2\cdot sr}$</td><td align="left">Luminance</td><td align="center">Nit(nt)</td></tr></tbody></table><h2 id="Radiant-Energy"><a href="#Radiant-Energy" class="headerlink" title="Radiant Energy"></a>Radiant Energy</h2><ul><li>Q (J)</li></ul><p>辐射能量。</p><h2 id="Radiant-Flux"><a href="#Radiant-Flux" class="headerlink" title="Radiant Flux"></a>Radiant Flux</h2><ul><li>$\phi &#x3D;\frac{dQ}{dt}$ (W)</li></ul><p>辐射通量，单位时间上的能量。</p><h2 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h2><ul><li>$I(\omega)&#x3D;\frac{d\phi}{d\omega}$ ($\frac{W}{sr}$)</li></ul><p>辐射强度，功率每立体角。</p><h3 id="立体角"><a href="#立体角" class="headerlink" title="立体角"></a>立体角</h3><p><img src="/img/Radi/sa.png"><br>立体角：$\Omega &#x3D;\frac{A}{r^2}$ (sr)、单位立体角：$d\omega &#x3D;\sin \theta d\theta d\varphi$<br>一个完整球面的立体角是 $4\pi$。</p><h2 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h2><ul><li>$E(x)&#x3D;\frac{d\phi (x)}{dA}$ ($\frac{W}{m^2}$)</li></ul><p>辐射照度，功率每垂直面积。</p><h2 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h2><ul><li>$L(p,\omega)&#x3D;\frac{d^2\phi (p,\omega)}{d\omega dA\cos\theta}$ ($\frac{W}{sr\cdot m^2}$)<br>辐射亮度，功率每立体角，每垂直面积。可以理解为单位面积对单位立体角辐射或接受的功率。</li></ul><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>由定义可得 Radiance 即 Intensity 每垂直面积，或者 Irradiance 每立体角。<br>它们之间的转换为：</p><ul><li>$dE(p)&#x3D;L(p,\omega)*\cos \theta d\omega$</li><li>$dI(p,\omega)&#x3D;L(p,\omega)*\cos \theta dA$</li></ul><p>进一步推导：<strong>一单位面积的 Irradiance 为其接受的 Radiance 在单位半球上的积分</strong>。</p><ul><li>$E(p)&#x3D;\int_{H^2}L_i(p,\omega)\cos \theta d\omega$</li></ul><h2 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数 BRDF"></a>双向反射分布函数 BRDF</h2><p>该函数定义了某一单位面积从某一单位立体角接收到的 Radiance 转化为其 Irradiance 然后再辐射出去的 Radiance 是如何分配到各个立体角上的，即：<br>出射 <code>Radiance</code> &#x2F; 入射 <code>Irradiance</code></p><ul><li>$f_r(\omega_i\rightarrow \omega_r)&#x3D;\frac{dL_r{\omega_r}}{dE_i{\omega_i}}&#x3D;\frac{dL_r(\omega_r)}{L_i(p,\omega_i)\cos \theta_id\omega_i}$ ($\frac{1}{sr}$)</li></ul><h2 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h2><p>由 Radiance 与 BRDF 的定义可得：<strong>单位面积向任一单位立体角辐射出的 Radiance 可由其接受的 Radiance 与其 BRDF 的乘积在单位半球上积分求得</strong>。</p><ul><li>$L_r(p,\omega_r)&#x3D;\int_{H^2}f_r(p,\omega_i\rightarrow \omega_r)L_i(p,\omega_i)\cos \theta_i{\rm d}\omega_i$</li></ul><h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>在反射方程中加上自发光项，用于描述光源物体。</p><ul><li>$L_o(p,\omega_o)&#x3D;L_e(p,\omega_o)+\int_{H^2}f_r(p,\omega_i,\omega_o)L_i(p,\omega_i)(n\cdot \omega_i){\rm d}\omega_i$</li></ul><p>$H^2$ 和 $\Omega^+$ 0都表示单位半球面，我们默认下半球面不会产生任何贡献，这样就不用写什么 $max(0, \cos\theta)$ 了。</p><div class="note note-secondary">            <p>所有向量由该点发出，方向向外。</p>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>PBR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Archive】GAMES101</title>
    <link href="/2021/09/03/GAMES101/"/>
    <url>/2021/09/03/GAMES101/</url>
    
    <content type="html"><![CDATA[<h1 id="渲染管线中的变换矩阵"><a href="#渲染管线中的变换矩阵" class="headerlink" title="渲染管线中的变换矩阵"></a>渲染管线中的变换矩阵</h1><p>&emsp;&emsp;在渲染管线的前期，光栅化之前，需要对顶点和相机的坐标进行标准化变换，然后进行视口变换进入屏幕坐标空间。</p><h2 id="相机的定义"><a href="#相机的定义" class="headerlink" title="相机的定义"></a>相机的定义</h2><p>位置：$\vec{e}$;&emsp;看向：$\vec{g}$;&emsp;上方：$\vec{t}$;</p><p>我们规定相机位于 (0, 0, 0) ，看向 -Z，上方为 Y。<br>对相机和顶点应用同一个变换矩阵，他们的相对位置则不变。</p><h2 id="视锥体的定义"><a href="#视锥体的定义" class="headerlink" title="视锥体的定义"></a>视锥体的定义</h2><p><img src="/img/GAMES101/fru.png"><br>已知fovY和aspect可得</p><ul><li>$tan\frac{fovY}{2} &#x3D; \frac{t}{|n|}$</li><li>$aspect &#x3D; \frac{r}{t}$</li></ul><h2 id="像素空间"><a href="#像素空间" class="headerlink" title="像素空间"></a>像素空间</h2><p>像素块编号 (0, 0) -&gt; (width - 1, height - 1)<br>像素中心 (x + 0.5, y + 0.5)<br>覆盖于 (0, 0) -&gt; (width, height)</p><h2 id="Viewing"><a href="#Viewing" class="headerlink" title="Viewing"></a>Viewing</h2><h3 id="Model-View"><a href="#Model-View" class="headerlink" title="Model-View"></a>Model-View</h3><p>$M_{view}&#x3D;R_{view}T_{view}$<br>​<br>将相机移动至原点。<br>$T_{view}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  1 &amp; 0 &amp; 0 &amp; -x_e \<br>  0 &amp; 1 &amp; 0 &amp; -y_e \<br>  0 &amp; 0 &amp; 1 &amp; -z_e \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$<br>​<br>然后将 g 旋转至 -Z，t 旋转至 Y，（g x t）旋转至 X。<br>但是这样的矩阵不好求，故先考虑求其简单的逆矩阵 $R_{view}^{-1}$：</p><ul><li>将 X（1，0，0）旋转至（g x t），将 Y（0，1，0）旋转至 t，将 Z（0，0，1）旋转至 -g。<br>​同时，旋转矩阵是正交矩阵，故其逆矩阵等于其转置矩阵。</li></ul><p>由 $R_{view}^{-1}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  x_{g \times t} &amp; x_t &amp; x_{-g} &amp; 0 \<br>  y_{g \times t} &amp; y_t &amp; y_{-g} &amp; 0 \<br>  z_{g \times t} &amp; z_t &amp; z_{-g} &amp; 0 \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$<br>得 $R_{view}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  x_{g \times t} &amp; y_{g \times t} &amp; z_{g \times t} &amp; 0 \<br>  x_t &amp; y_t &amp; z_t &amp; 0 \<br>  x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$</p><h3 id="Projection"><a href="#Projection" class="headerlink" title="Projection"></a>Projection</h3><h4 id="Persprctive-to-Orthographic"><a href="#Persprctive-to-Orthographic" class="headerlink" title="Persprctive to Orthographic"></a>Persprctive to Orthographic</h4><h2 id="得-y-frac-n-z-y-emsp-x-frac-n-z-x-故-一点-x-y-z-1-T-乘-M-p2o-之后会被变换至：-begin-pmatrix-frac-nx-z-frac-ny-z-1-end-pmatrix-即：-begin-pmatrix-nx-ny-z-end-pmatrix-所以：-M-p2o-begin-pmatrix-n-0-0-0-0-n-0-0-0-0-1-0-end-pmatrix"><a href="#得-y-frac-n-z-y-emsp-x-frac-n-z-x-故-一点-x-y-z-1-T-乘-M-p2o-之后会被变换至：-begin-pmatrix-frac-nx-z-frac-ny-z-1-end-pmatrix-即：-begin-pmatrix-nx-ny-z-end-pmatrix-所以：-M-p2o-begin-pmatrix-n-0-0-0-0-n-0-0-0-0-1-0-end-pmatrix" class="headerlink" title="得 $y^, &#x3D; \frac{n}{z}y$;&emsp;$x^, &#x3D; \frac{n}{z}x$;故 一点 $(x,y,z,1)^T$ 乘 $M_{p2o}$ 之后会被变换至：$$  \begin{pmatrix}  \frac{nx}{z} \  \frac{ny}{z} \  ? \  1 \  \end{pmatrix}$$即：$$  \begin{pmatrix}  nx \  ny \  ? \  z \  \end{pmatrix}$$所以：$M_{p2o} &#x3D;$$$  \begin{pmatrix}  n &amp; 0 &amp; 0 &amp; 0 \  0 &amp; n &amp; 0 &amp; 0 \  ? &amp; ? &amp; ? &amp; ? \  0 &amp; 0 &amp; 1 &amp; 0 \  \end{pmatrix}$$"></a><img src="/img/GAMES101/p2o.png"><br>得 $y^, &#x3D; \frac{n}{z}y$;&emsp;$x^, &#x3D; \frac{n}{z}x$;<br><div class="note note-secondary">            <p>在齐次坐标系下，对一个坐标的所有元素乘以或除以同一个数仍然代表原本的坐标。</p>          </div><br>故 一点 $(x,y,z,1)^T$ 乘 $M_{p2o}$ 之后会被变换至：<br>$$<br>  \begin{pmatrix}<br>  \frac{nx}{z} \<br>  \frac{ny}{z} \<br>  ? \<br>  1 \<br>  \end{pmatrix}<br>$$<br>即：<br>$$<br>  \begin{pmatrix}<br>  nx \<br>  ny \<br>  ? \<br>  z \<br>  \end{pmatrix}<br>$$<br>所以：<br>$M_{p2o} &#x3D;$<br>$$<br>  \begin{pmatrix}<br>  n &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; n &amp; 0 &amp; 0 \<br>  ? &amp; ? &amp; ? &amp; ? \<br>  0 &amp; 0 &amp; 1 &amp; 0 \<br>  \end{pmatrix}<br>$$</h2><p>又因为 f、n 平面在变换后 z 轴不变，<br>即近平面上一点 $(x,y,n,1)^T$ 乘 $(?,?,?,?)$ 得 n，或者说，得 $n^2$。<br>得：</p><ul><li>$(?,?,?,?)&#x3D;(0,0,A,B)$ 且 $An+B&#x3D;n^2$</li></ul><p>且远平面上中心点 $(0,0,f,1)^T$ 乘 $(0,0,A,B)$ 得 f，或者说，得 $f^2$。<br>得：</p><ul><li>$Af+B&#x3D;f^2$</li></ul><p>联立得：</p><ul><li>$(0,0,A,B)&#x3D;(0,0,n+f,-nf)$</li></ul><hr><p>综上所述，$M_{p2o}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  n &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; n &amp; 0 &amp; 0 \<br>  0 &amp; 0 &amp; n+f &amp; -nf \<br>  0 &amp; 0 &amp; 1 &amp; 0 \<br>  \end{pmatrix}<br>$$</p><h4 id="Orthographic"><a href="#Orthographic" class="headerlink" title="Orthographic"></a>Orthographic</h4><p>将裁剪空间转化为标准化设备坐标，中心为 (0, 0, 0)，大小为 1x1x1 的立方体。<br><img src="/img/GAMES101/cj.png"></p><div class="note note-secondary">            <p>注意这里 l&lt;r&emsp;b&lt;t&emsp;f&gt;n。</p>          </div><p>$M_{ortho}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  \frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \<br>  0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{2} \<br>  0 &amp; 0 &amp; \frac{2}{n-f} &amp; -\frac{n+f}{2} \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$</p><h4 id="Projection-1"><a href="#Projection-1" class="headerlink" title="Projection"></a>Projection</h4><p>$M_{Projection}&#x3D;M_{Orthographic}M_{PersprctiveToOrthographic}$</p><h2 id="Viewport"><a href="#Viewport" class="headerlink" title="Viewport"></a>Viewport</h2><p>先将标准化设备坐标拉伸至与屏幕同等大小，再将其中心(0, 0)移至屏幕中心。保留z轴不变用于之后做深度检测。<br>$M_{viewport}&#x3D;$<br>$$<br>  \begin{pmatrix}<br>  \frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \<br>  0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \<br>  0 &amp; 0 &amp; 1 &amp; 0 \<br>  0 &amp; 0 &amp; 0 &amp; 1 \<br>  \end{pmatrix}<br>$$</p><h1 id="Super-Sample-Anti-Aliasing"><a href="#Super-Sample-Anti-Aliasing" class="headerlink" title="Super Sample Anti-Aliasing"></a>Super Sample Anti-Aliasing</h1><p>&emsp;&emsp;SSAA 作为一种暴力的超采样手段带来的性能开销是难以接受的，但作为反走样的入门仍然有学习一下的必要。</p><h2 id="insideTriangle"><a href="#insideTriangle" class="headerlink" title="insideTriangle"></a>insideTriangle</h2><p><strong>判断两向量的左右关系</strong></p><p>假设两向量 $\vec{a}$、$\vec{b}$ 在同一 z 轴为 0 的平面上，根据右手螺旋定则，若 $\vec{a} \times \vec{b}$ 的 z 轴大于 0 则 $\vec{b}$ 在 $\vec{a}$ 的左侧，反之亦然。</p><p>那么对于三角形三点形成的顺\逆时针三条向量来说，若有一点同时位于三向量的同一侧，则该点位于三角形内部。</p><p>假设三角形三点 a、b、c 与点 p 在同一平面上。<br>三角形三点按顺序形成三条向量 $\vec{ab}$、$\vec{bc}$、$\vec{ca}$，与 p 点形成三向条量 $\vec{ap}$、$\vec{bp}$、$\vec{cp}$。<br>将他们分别叉乘，判断结果是否同号即可判断三角形是否包围点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">insideTriangle</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">const</span> Vector3f* _v)</span> </span>&#123;<br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">p</span><span class="hljs-params">(x, y, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">a</span><span class="hljs-params">(_v[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], _v[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">b</span><span class="hljs-params">(_v[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], _v[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">c</span><span class="hljs-params">(_v[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], _v[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>], <span class="hljs-number">0</span>)</span></span>;<br><br>Eigen::Vector3f ab = b - a;<br>Eigen::Vector3f bc = c - b;<br>Eigen::Vector3f ca = a - c;<br><br>Eigen::Vector3f ap = p - a;<br>Eigen::Vector3f bp = p - b;<br>Eigen::Vector3f cp = p - c;<br><br>Eigen::Vector3f crs1 = ab.<span class="hljs-built_in">cross</span>(ap);<br>Eigen::Vector3f crs2 = bc.<span class="hljs-built_in">cross</span>(bp);<br>Eigen::Vector3f crs3 = ca.<span class="hljs-built_in">cross</span>(cp);<br><br><span class="hljs-keyword">return</span> ((crs1[<span class="hljs-number">2</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; crs2[<span class="hljs-number">2</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; crs3[<span class="hljs-number">2</span>] &gt;= <span class="hljs-number">0</span>) ||<br>(crs1[<span class="hljs-number">2</span>] &lt;= <span class="hljs-number">0</span> &amp;&amp; crs2[<span class="hljs-number">2</span>] &lt;= <span class="hljs-number">0</span> &amp;&amp; crs3[<span class="hljs-number">2</span>] &lt;= <span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SSAA-zBuffer"><a href="#SSAA-zBuffer" class="headerlink" title="SSAA &amp; zBuffer"></a>SSAA &amp; zBuffer</h2><p>遍历包围盒内的像素，对于每个像素遍历每个超采样点，确定三角形覆盖像素的比例，通过重心坐标计算对应的深度值，与深度缓存做比较并写入帧缓存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> rst::rasterizer::<span class="hljs-built_in">rasterize_triangle</span>(<span class="hljs-type">const</span> Triangle&amp; t) &#123;<br><span class="hljs-keyword">auto</span> v = t.<span class="hljs-built_in">toVector4</span>();<br><br><span class="hljs-comment">// 包围盒大小</span><br><span class="hljs-type">int</span> minX = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">floor</span>(std::<span class="hljs-built_in">min</span>(v[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], std::<span class="hljs-built_in">min</span>(v[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], v[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])));<br><span class="hljs-type">int</span> maxX = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">ceil</span>(std::<span class="hljs-built_in">max</span>(v[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], std::<span class="hljs-built_in">max</span>(v[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], v[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])));<br><span class="hljs-type">int</span> minY = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">floor</span>(std::<span class="hljs-built_in">min</span>(v[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], std::<span class="hljs-built_in">min</span>(v[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], v[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>])));<br><span class="hljs-type">int</span> maxY = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">ceil</span>(std::<span class="hljs-built_in">max</span>(v[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], std::<span class="hljs-built_in">max</span>(v[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], v[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>])));<br><br><span class="hljs-comment">// 四个超采样点的相对坐标</span><br>std::vector&lt;Eigen::Vector2f&gt; super&#123;<br>&#123;<span class="hljs-number">0.25f</span>,<span class="hljs-number">0.25f</span>&#125;,<br>&#123;<span class="hljs-number">0.75f</span>,<span class="hljs-number">0.25f</span>&#125;,<br>&#123;<span class="hljs-number">0.25f</span>,<span class="hljs-number">0.75f</span>&#125;,<br>&#123;<span class="hljs-number">0.75f</span>,<span class="hljs-number">0.75f</span>&#125;,<br>&#125;;<br><br><span class="hljs-comment">// 遍历包围盒内所有像素点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = minX; x &lt;= maxX; x++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = minY; y &lt;= maxY; y++) &#123;<br><span class="hljs-type">int</span> insideCount = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> sumDepth = <span class="hljs-number">0.f</span>;<br><br><span class="hljs-comment">// 遍历像素点内所有超采样点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">insideTriangle</span>((<span class="hljs-type">float</span>)x + super[i][<span class="hljs-number">0</span>],<br>(<span class="hljs-type">float</span>)y + super[i][<span class="hljs-number">1</span>], t.v)) &#123;<br>insideCount++;<br><br><span class="hljs-comment">// 计算重心坐标</span><br><span class="hljs-keyword">auto</span> tup = <span class="hljs-built_in">computeBarycentric2D</span>(<br>(<span class="hljs-type">float</span>)x + super[i][<span class="hljs-number">0</span>], (<span class="hljs-type">float</span>)y + super[i][<span class="hljs-number">1</span>], t.v);<br><br><span class="hljs-type">float</span> alpha, beta, gamma;<br>std::<span class="hljs-built_in">tie</span>(alpha, beta, gamma) = tup;<br><br><span class="hljs-comment">// 利用重心坐标计算深度插值</span><br><span class="hljs-type">float</span> w_reciprocal = <span class="hljs-number">1.f</span> /<br>(alpha / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() + beta / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>());<br><span class="hljs-type">float</span> z_interpolated = alpha * v[<span class="hljs-number">0</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">0</span>].<span class="hljs-built_in">w</span>() +<br>beta * v[<span class="hljs-number">1</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">1</span>].<span class="hljs-built_in">w</span>() + gamma * v[<span class="hljs-number">2</span>].<span class="hljs-built_in">z</span>() / v[<span class="hljs-number">2</span>].<span class="hljs-built_in">w</span>();<br><br>z_interpolated *= w_reciprocal;<br>sumDepth += z_interpolated;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (insideCount &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">float</span> avgDepth = sumDepth / <span class="hljs-number">4.f</span>;<br><span class="hljs-keyword">if</span> (avgDepth &lt; depth_buf[<span class="hljs-built_in">get_index</span>(x, y)]) &#123;<br>depth_buf[<span class="hljs-built_in">get_index</span>(x, y)] = avgDepth;<br><br><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">point</span><span class="hljs-params">((<span class="hljs-type">float</span>)x, (<span class="hljs-type">float</span>)y, avgDepth)</span></span>;<br>Eigen::Vector3f color = t.<span class="hljs-built_in">getColor</span>() * insideCount / <span class="hljs-number">4.f</span>;<br><span class="hljs-built_in">set_pixel</span>(point, color);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101/null.png" alt="不使用反走样"></div><div class="group-image-wrap"><img src="/img/GAMES101/ssaa.png" alt="SSAAx4"></div></div></div><h1 id="Blinn-Phong-光照模型"><a href="#Blinn-Phong-光照模型" class="headerlink" title="Blinn-Phong 光照模型"></a>Blinn-Phong 光照模型</h1><p>&emsp;&emsp;该模型将任一点的光照分为三部分：1.由光源方向与法线方向决定的漫反射、2.由光源方向法线方向与观察方向决定的高光、3.恒定的环境光。</p><h2 id="getColorBilinear"><a href="#getColorBilinear" class="headerlink" title="getColorBilinear"></a>getColorBilinear</h2><p><img src="/img/GAMES101/bi.png"><br>对贴图采样时采用双线性插值的方法以获得柔和的过度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">getColorBilinear</span><span class="hljs-params">(<span class="hljs-type">float</span> u, <span class="hljs-type">float</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u &gt; <span class="hljs-number">1</span>) u = u - (<span class="hljs-type">int</span>)u;<br><span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) u = u - (<span class="hljs-type">int</span>)u + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (v &gt; <span class="hljs-number">1</span>) v = v - (<span class="hljs-type">int</span>)v;<br><span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>) v = v - (<span class="hljs-type">int</span>)v + <span class="hljs-number">1</span>;<br><br><span class="hljs-type">float</span> u_img = u * width;<br><span class="hljs-type">float</span> v_img = (<span class="hljs-number">1</span> - v) * height;<br><br><span class="hljs-type">int</span> u_min = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">floor</span>(u_img);<br><span class="hljs-type">int</span> u_max = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">min</span>((<span class="hljs-type">float</span>)width, std::<span class="hljs-built_in">ceil</span>(u_img));<br><span class="hljs-type">int</span> v_min = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">floor</span>(v_img);<br><span class="hljs-type">int</span> v_max = (<span class="hljs-type">int</span>)std::<span class="hljs-built_in">min</span>((<span class="hljs-type">float</span>)height, std::<span class="hljs-built_in">ceil</span>(v_img));<br><br><span class="hljs-keyword">auto</span> u00 = image_data.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(v_min, u_min);<br><span class="hljs-keyword">auto</span> u01 = image_data.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(v_max, u_min);<br><span class="hljs-keyword">auto</span> u10 = image_data.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(v_min, u_max);<br><span class="hljs-keyword">auto</span> u11 = image_data.<span class="hljs-built_in">at</span>&lt;cv::Vec3b&gt;(v_max, u_max);<br><br><span class="hljs-type">float</span> s = (u_img - u_min) / (u_max - u_min);<br><span class="hljs-type">float</span> t = (v_img - v_min) / (v_max - v_min);<br><br><span class="hljs-keyword">auto</span> u0 = (<span class="hljs-number">1</span> - s) * u00 + s * u10;<br><span class="hljs-keyword">auto</span> u1 = (<span class="hljs-number">1</span> - s) * u01 + s * u11;<br><span class="hljs-keyword">auto</span> p = (<span class="hljs-number">1</span> - t) * u0 + t * u1;<br><br><span class="hljs-keyword">return</span> Eigen::<span class="hljs-built_in">Vector3f</span>(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>], p[<span class="hljs-number">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="布林-冯"><a href="#布林-冯" class="headerlink" title="布林-冯"></a>布林-冯</h2><p><img src="/img/Phong/phong.png"><br>公式中的 k 代表材质对光的反射强度，当分别处理 k 中 RBG 三通道时即可表示不同颜色，当将读取到的贴图颜色应用于 k 时即可显示贴图。<br>高光公式中的 p 代表高光的集中程度，由于 cos 函数趋向 0 的速度过慢，因此使用 cos 的 p 次方使高光更加集中。p 的值也可以存在一张贴图中。<br>I &#x2F; r2 用于模拟光线的衰减。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Eigen::Vector3f <span class="hljs-title">texture_fragment_shader</span><span class="hljs-params">(<span class="hljs-type">const</span> fragment_shader_payload&amp; payload)</span> </span>&#123;<br>Eigen::Vector3f texture_color = Eigen::Vector3f::<span class="hljs-built_in">Identity</span>();<br><span class="hljs-type">bool</span> isBilinear = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (payload.texture) &#123;<br><span class="hljs-keyword">if</span> (isBilinear) &#123;<br>texture_color = payload.texture-&gt;<span class="hljs-built_in">getColorBilinear</span>(<br>payload.tex_coords.<span class="hljs-built_in">x</span>(), payload.tex_coords.<span class="hljs-built_in">y</span>());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>texture_color = payload.texture-&gt;<span class="hljs-built_in">getColor</span>(<br>payload.tex_coords.<span class="hljs-built_in">x</span>(), payload.tex_coords.<span class="hljs-built_in">y</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 反射系数</span><br>Eigen::Vector3f kd = texture_color / <span class="hljs-number">255.f</span>;<br>Eigen::Vector3f ks = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.7937f</span>, <span class="hljs-number">0.7937f</span>, <span class="hljs-number">0.7937f</span>);<br>Eigen::Vector3f ka = Eigen::<span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>, <span class="hljs-number">0.01f</span>);<br><br><span class="hljs-comment">// 光源</span><br><span class="hljs-keyword">auto</span> l1 = light&#123; &#123;<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125; &#125;;<br><span class="hljs-keyword">auto</span> l2 = light&#123; &#123;<span class="hljs-number">-20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>&#125; &#125;;<br><br><span class="hljs-type">float</span> p = <span class="hljs-number">200.0f</span>;<span class="hljs-comment">// 幂系数</span><br>std::vector&lt;light&gt; lights = &#123; l1, l2 &#125;;<span class="hljs-comment">// 打包光源</span><br>Eigen::Vector3f amb_light_intensity&#123; <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span> &#125;;<span class="hljs-comment">// 环境光强度</span><br>Eigen::Vector3f eye_pos&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span> &#125;;<span class="hljs-comment">// 相机位置</span><br><br><span class="hljs-comment">// 用于计算的向量</span><br>Eigen::Vector3f point = payload.view_pos;<br>Eigen::Vector3f normal = payload.normal;<br>Eigen::Vector3f viewVector = eye_pos - point;<br><br>Eigen::Vector3f result_color = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; light : lights) &#123;<br>Eigen::Vector3f lightVector = light.position - point;<br><span class="hljs-type">float</span> r2 = lightVector.<span class="hljs-built_in">dot</span>(lightVector);<br><br><span class="hljs-comment">// 漫反射</span><br>Eigen::Vector3f ld = kd.<span class="hljs-built_in">cwiseProduct</span>(light.intensity) / r2 *<br>std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, normal.<span class="hljs-built_in">dot</span>(lightVector.<span class="hljs-built_in">normalized</span>()));<br>result_color += ld;<br><br><span class="hljs-comment">// 高光</span><br>Eigen::Vector3f vpl = viewVector.<span class="hljs-built_in">normalized</span>() + lightVector.<span class="hljs-built_in">normalized</span>();<br>Eigen::Vector3f h = vpl / vpl.<span class="hljs-built_in">norm</span>();<span class="hljs-comment">//半程向量</span><br>Eigen::Vector3f ls = ks.<span class="hljs-built_in">cwiseProduct</span>(light.intensity) / r2 *<br><span class="hljs-built_in">pow</span>(std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0.f</span>, normal.<span class="hljs-built_in">dot</span>(h)), p);<br>result_color += ls;<br>&#125;<br><span class="hljs-comment">// 环境光</span><br>Eigen::Vector3f la = ka.<span class="hljs-built_in">cwiseProduct</span>(amb_light_intensity);<br>result_color += la;<br><br><span class="hljs-keyword">return</span> result_color * <span class="hljs-number">255.f</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><img src="/img/GAMES101/01.png"></p><h1 id="Whitted-Style-光线追踪"><a href="#Whitted-Style-光线追踪" class="headerlink" title="Whitted-Style 光线追踪"></a>Whitted-Style 光线追踪</h1><p>&emsp;&emsp;Whitted_Style 光线追踪的部分实现，包括射线与由重心坐标表式的三角形相交、射线与轴对齐包围盒的相交、包围盒的树形加速结构。</p><h2 id="Moller-Trumbore-射线与平面（重心坐标）"><a href="#Moller-Trumbore-射线与平面（重心坐标）" class="headerlink" title="Möller-Trumbore 射线与平面（重心坐标）"></a>Möller-Trumbore 射线与平面（重心坐标）</h2><p>光线的定义：</p><ul><li>$\vec{O}+t\vec{D}$</li></ul><p>平面的定义：</p><ul><li>$(1-b_1-b_2)\vec{P}_0+b_1\vec{P}_1+b_2\vec{P}_2$</li></ul><p>求射线与平面的交点即联立两表达式求解，已知 xyz 三分量上的三对表达式，求未知量：t、$b_1$、$b_2$。<br><img src="/img/GAMES101/moller.png"></p><div class="note note-secondary">            <p>对于用重心坐标表示的三角形，三值之和为 1 即可表示当前平面上的任一点，若同时三值均大于 1 则表示该三角形内部的一点。</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">rayTriangleIntersect</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector3f&amp; v0, <span class="hljs-type">const</span> Vector3f&amp; v1, <span class="hljs-type">const</span> Vector3f&amp; v2,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> Vector3f&amp; orig, <span class="hljs-type">const</span> Vector3f&amp; dir)</span> </span>&#123;<br><br>Vector3f e1 = v1 - v0;<br>Vector3f e2 = v2 - v0;<br>Vector3f s = orig - v0;<br>Vector3f s1 = <span class="hljs-built_in">crossProduct</span>(dir, e2);<br>Vector3f s2 = <span class="hljs-built_in">crossProduct</span>(s, e1);<br><br><span class="hljs-type">float</span> factor = <span class="hljs-built_in">dotProduct</span>(s1, e1);<br><span class="hljs-type">float</span> t = <span class="hljs-built_in">dotProduct</span>(s2, e2) / factor;<br><span class="hljs-type">float</span> b1 = <span class="hljs-built_in">dotProduct</span>(s1, s) / factor;<br><span class="hljs-type">float</span> b2 = <span class="hljs-built_in">dotProduct</span>(s2, dir) / factor;<br><br><span class="hljs-keyword">if</span> (t &gt;= <span class="hljs-number">0</span> &amp;&amp; b1 &gt;= <span class="hljs-number">0</span> &amp;&amp; b2 &gt;= <span class="hljs-number">0</span> &amp;&amp; (<span class="hljs-number">1</span> - b1 - b2) &gt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="射线与平面（点法式）"><a href="#射线与平面（点法式）" class="headerlink" title="射线与平面（点法式）"></a>射线与平面（点法式）</h2><p>平面的定义：</p><ul><li>$(\vec{P}-\vec{P^,})\cdot \vec{N}$</li></ul><p>点 $P^,$ 与法向量 N 组成一平面，P 为面上任一点。<br>将射线代入 P 得</p><ul><li>$t&#x3D;\frac{(\vec{P^,}-\vec{O})\cdot \vec{N}}{\vec{D}\cdot \vec{N}}$</li></ul><h2 id="射线与轴对齐包围盒"><a href="#射线与轴对齐包围盒" class="headerlink" title="射线与轴对齐包围盒"></a>射线与轴对齐包围盒</h2><p>包围盒的定义：pMax 与 pMin 两个点所代表的三对面。<br>射线与轴对齐平面的相交（例如x轴）：</p><ul><li>$t&#x3D;\frac{\vec{P^,_x}-\vec{O_x}}{\vec{D_x}}$</li></ul><p>对于每一对平面，射线存在一对与他们相交的 $t_{min}$ 与 $t_{max}$<br>射线进入包围盒：射线进入所有三对面；射线离开包围盒：射线离开任一面。</p><ul><li>$t_{enter}&#x3D;max(t_{min})$、$t_{exit}&#x3D;min(t_{max})$</li></ul><p>射线与包围盒有一段相交：$t_{enter}&lt;t_{exit}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">Bounds3::IntersectP</span><span class="hljs-params">(<span class="hljs-type">const</span> Ray&amp; ray, <span class="hljs-type">const</span> Vector3f&amp; invDir,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> std::array&lt;<span class="hljs-type">bool</span>, <span class="hljs-number">3</span>&gt;&amp; dirIsNeg)</span> <span class="hljs-type">const</span> </span>&#123;<br><br><span class="hljs-comment">/* invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z),</span><br><span class="hljs-comment">   use this because Multiply is faster that Division */</span><br><span class="hljs-comment">/* dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)],</span><br><span class="hljs-comment">   use this to simplify your logic */</span><br><br><span class="hljs-type">float</span> tEnter = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">lowest</span>();<br><span class="hljs-type">float</span> tExit = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-type">float</span> tMin = (pMin[i] - ray.origin[i]) * invDir[i];<br><span class="hljs-type">float</span> tMax = (pMax[i] - ray.origin[i]) * invDir[i];<br><span class="hljs-comment">/* 如果光线沿负方向传播，光线会先撞上pMax的对应的维度得到tMax，</span><br><span class="hljs-comment">   而此t应是光线进入包围盒时的tMin。出包围盒时同理。*/</span><br><span class="hljs-keyword">if</span> (dirIsNeg[i]) &#123;<br>std::<span class="hljs-built_in">swap</span>(tMin, tMax);<br>&#125;<br><span class="hljs-keyword">if</span> (tMin &gt; tEnter) &#123;<br>tEnter = tMin;<br>&#125;<br><span class="hljs-keyword">if</span> (tMax &lt; tExit) &#123;<br>tExit = tMax;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (tEnter &lt; tExit &amp;&amp; tExit &gt;= <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BVH-的创建"><a href="#BVH-的创建" class="headerlink" title="BVH 的创建"></a>BVH 的创建</h2><p>轴对齐包围盒的加速结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BVHBuildNode* <span class="hljs-title">BVHAccel::recursiveBuild</span><span class="hljs-params">(std::vector&lt;Object*&gt; objects)</span> </span>&#123;<br>BVHBuildNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BVHBuildNode</span>();<br><br>Bounds3 bounds;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.<span class="hljs-built_in">size</span>(); ++i)<br>bounds = <span class="hljs-built_in">Union</span>(bounds, objects[i]-&gt;<span class="hljs-built_in">getBounds</span>());<br><span class="hljs-keyword">if</span> (objects.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 创建叶节点</span><br>node-&gt;bounds = objects[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">getBounds</span>();<br>node-&gt;object = objects[<span class="hljs-number">0</span>];<br>node-&gt;left = <span class="hljs-literal">nullptr</span>;<br>node-&gt;right = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (objects.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>node-&gt;left = <span class="hljs-built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="hljs-number">0</span>]&#125;);<br>node-&gt;right = <span class="hljs-built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="hljs-number">1</span>]&#125;);<br><br>node-&gt;bounds = <span class="hljs-built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);<br><span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>Bounds3 centroidBounds;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.<span class="hljs-built_in">size</span>(); ++i)<br>centroidBounds = <span class="hljs-built_in">Union</span>(centroidBounds, objects[i]-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>());<br><span class="hljs-comment">// 返回包围盒大致的形状以决定接下来以哪个轴分割包围盒</span><br><span class="hljs-type">int</span> dim = centroidBounds.<span class="hljs-built_in">maxExtent</span>();<br><span class="hljs-keyword">switch</span> (dim) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>std::<span class="hljs-built_in">sort</span>(objects.<span class="hljs-built_in">begin</span>(), objects.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> f1, <span class="hljs-keyword">auto</span> f2) &#123;<br><span class="hljs-keyword">return</span> f1-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>().x &lt;<br>f2-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>().x;<br>&#125;);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>std::<span class="hljs-built_in">sort</span>(objects.<span class="hljs-built_in">begin</span>(), objects.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> f1, <span class="hljs-keyword">auto</span> f2) &#123;<br><span class="hljs-keyword">return</span> f1-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>().y &lt;<br>f2-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>().y;<br>&#125;);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>std::<span class="hljs-built_in">sort</span>(objects.<span class="hljs-built_in">begin</span>(), objects.<span class="hljs-built_in">end</span>(), [](<span class="hljs-keyword">auto</span> f1, <span class="hljs-keyword">auto</span> f2) &#123;<br><span class="hljs-keyword">return</span> f1-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>().z &lt;<br>f2-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>().z;<br>&#125;);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">auto</span> beginning = objects.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> middling = objects.<span class="hljs-built_in">begin</span>() + (objects.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>);<br><span class="hljs-keyword">auto</span> ending = objects.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-keyword">auto</span> leftshapes = std::<span class="hljs-built_in">vector</span>&lt;Object*&gt;(beginning, middling);<br><span class="hljs-keyword">auto</span> rightshapes = std::<span class="hljs-built_in">vector</span>&lt;Object*&gt;(middling, ending);<br><br><span class="hljs-built_in">assert</span>(objects.<span class="hljs-built_in">size</span>() == (leftshapes.<span class="hljs-built_in">size</span>() + rightshapes.<span class="hljs-built_in">size</span>()));<br><br>node-&gt;left = <span class="hljs-built_in">recursiveBuild</span>(leftshapes);<br>node-&gt;right = <span class="hljs-built_in">recursiveBuild</span>(rightshapes);<br><br>node-&gt;bounds = <span class="hljs-built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);<br>&#125;<br><br><span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BVH-的创建（ASH）"><a href="#BVH-的创建（ASH）" class="headerlink" title="BVH 的创建（ASH）"></a>BVH 的创建（ASH）</h2><p>表面积启发式算法基于两个假设：如果包围盒的表面积越大，那么它被射线击中的可能性也就越大。包围盒内的物体数量越多，遍历它的开销就越大。比较所有划分方案的预计开销并选择最优的方案。<br>开销：<code>float cost = 1 + (countA * A.SurfaceArea() + countB * B.SurfaceArea()) / nArea;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function">BVHBuildNode* <span class="hljs-title">BVHAccel::recursiveBuild</span><span class="hljs-params">(std::vector&lt;Object*&gt; objects)</span> </span>&#123;<br>BVHBuildNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BVHBuildNode</span>();<br><br>Bounds3 bounds;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>bounds = <span class="hljs-built_in">Union</span>(bounds, objects[i]-&gt;<span class="hljs-built_in">getBounds</span>());<br>&#125;<br><span class="hljs-keyword">if</span> (objects.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 创建叶节点</span><br>node-&gt;bounds = objects[<span class="hljs-number">0</span>]-&gt;<span class="hljs-built_in">getBounds</span>();<br>node-&gt;object = objects[<span class="hljs-number">0</span>];<br>node-&gt;left = <span class="hljs-literal">nullptr</span>;<br>node-&gt;right = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (objects.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>node-&gt;left = <span class="hljs-built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="hljs-number">0</span>]&#125;);<br>node-&gt;right = <span class="hljs-built_in">recursiveBuild</span>(std::vector&#123;objects[<span class="hljs-number">1</span>]&#125;);<br><br>node-&gt;bounds = <span class="hljs-built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);<br><span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>Bounds3 centroidBounds;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>centroidBounds = <span class="hljs-built_in">Union</span>(centroidBounds,objects[i]-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>());<br>&#125;<br>std::vector&lt;Object*&gt; leftshapes;<br>std::vector&lt;Object*&gt; rightshapes;<br><br>Bounds3 nBounds;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>nBounds = <span class="hljs-built_in">Union</span>(nBounds, objects[i]-&gt;<span class="hljs-built_in">getBounds</span>());<br>&#125;<br><span class="hljs-type">float</span> nArea = centroidBounds.<span class="hljs-built_in">SurfaceArea</span>();<br><br><span class="hljs-type">int</span> minCostCoor = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mincostIndex = <span class="hljs-number">0</span>;<br><span class="hljs-type">float</span> minCost = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">infinity</span>();<br>std::map&lt;<span class="hljs-type">int</span>, std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; indexMap;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-type">int</span> bucketCount = <span class="hljs-number">12</span>;<br>std::vector&lt;Bounds3&gt; boundsBuckets;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; countBucket;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketCount; j++) &#123;<br>boundsBuckets.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Bounds3</span>());<br>countBucket.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br>std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; objMap;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; objects.<span class="hljs-built_in">size</span>(); j++) &#123;<br><span class="hljs-type">int</span> bid = bucketCount * centroidBounds.<span class="hljs-built_in">Offset</span>(<br>objects[j]-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>())[i];<br><br><span class="hljs-keyword">if</span> (bid &gt; bucketCount - <span class="hljs-number">1</span>) &#123;<br>bid = bucketCount - <span class="hljs-number">1</span>;<br>&#125;<br>Bounds3 b = boundsBuckets[bid];<br>b = <span class="hljs-built_in">Union</span>(b, objects[j]-&gt;<span class="hljs-built_in">getBounds</span>().<span class="hljs-built_in">Centroid</span>());<br>boundsBuckets[bid] = b;<br>countBucket[bid] = countBucket[bid] + <span class="hljs-number">1</span>;<br>objMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(j, bid));<br>&#125;<br><br>indexMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(i, objMap));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; boundsBuckets.<span class="hljs-built_in">size</span>(); j++) &#123;<br>Bounds3 A;<br>Bounds3 B;<br><span class="hljs-type">int</span> countA = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> countB = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; j; k++) &#123;<br>A = <span class="hljs-built_in">Union</span>(A, boundsBuckets[k]);<br>countA += countBucket[k];<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j; k &lt; boundsBuckets.<span class="hljs-built_in">size</span>(); k++) &#123;<br>B = <span class="hljs-built_in">Union</span>(B, boundsBuckets[k]);<br>countB += countBucket[k];<br>&#125;<br><br><span class="hljs-type">float</span> cost = <span class="hljs-number">1</span> + (countA * A.<span class="hljs-built_in">SurfaceArea</span>() +<br>countB * B.<span class="hljs-built_in">SurfaceArea</span>()) / nArea;<br><br><span class="hljs-keyword">if</span> (cost &lt; minCost) &#123;<br>minCost = cost;<br>mincostIndex = j;<br>minCostCoor = i;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (indexMap[minCostCoor][i] &lt; mincostIndex) &#123;<br>leftshapes.<span class="hljs-built_in">push_back</span>(objects[i]);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>rightshapes.<span class="hljs-built_in">push_back</span>(objects[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">assert</span>(objects.<span class="hljs-built_in">size</span>() == (leftshapes.<span class="hljs-built_in">size</span>() + rightshapes.<span class="hljs-built_in">size</span>()));<br><br>node-&gt;left = <span class="hljs-built_in">recursiveBuild</span>(leftshapes);<br>node-&gt;right = <span class="hljs-built_in">recursiveBuild</span>(rightshapes);<br><br>node-&gt;bounds = <span class="hljs-built_in">Union</span>(node-&gt;left-&gt;bounds, node-&gt;right-&gt;bounds);<br>&#125;<br><br><span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BVH-的遍历"><a href="#BVH-的遍历" class="headerlink" title="BVH 的遍历"></a>BVH 的遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Intersection <span class="hljs-title">BVHAccel::getIntersection</span><span class="hljs-params">(BVHBuildNode* node, <span class="hljs-type">const</span> Ray&amp; ray)</span> <span class="hljs-type">const</span> </span>&#123;<br>Intersection inter;<br><br><span class="hljs-type">float</span> x = ray.direction.x;<br><span class="hljs-type">float</span> y = ray.direction.y;<br><span class="hljs-type">float</span> z = ray.direction.z;<br>std::array&lt;<span class="hljs-type">bool</span>, 3&gt; dirsIsNeg&#123;x &lt; <span class="hljs-number">0</span>,y &lt; <span class="hljs-number">0</span>,z &lt; <span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">// 与此节点的包围盒不相交</span><br><span class="hljs-keyword">if</span> (node-&gt;bounds.<span class="hljs-built_in">IntersectP</span>(ray, ray.direction_inv, dirsIsNeg) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">return</span> inter;<br>&#125;<br><span class="hljs-comment">// 遍历到叶节点</span><br><span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">nullptr</span>)     &#123;<br>inter = node-&gt;object-&gt;<span class="hljs-built_in">getIntersection</span>(ray);<br><span class="hljs-keyword">return</span> inter;<br>&#125;<br>Intersection hitL = <span class="hljs-built_in">getIntersection</span>(node-&gt;left, ray);<br>Intersection hitR = <span class="hljs-built_in">getIntersection</span>(node-&gt;right, ray);<br><br><span class="hljs-keyword">if</span> (hitL.distance &lt; hitR.distance) &#123;<br><span class="hljs-keyword">return</span> hitL;<br>&#125;<br><br><span class="hljs-keyword">return</span> hitR;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><p><img src="/img/GAMES101/01.png"></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://blog.csdn.net/qq_36242312/article/details/115495482">参考</a></p><h1 id="蒙特卡洛路径追踪"><a href="#蒙特卡洛路径追踪" class="headerlink" title="蒙特卡洛路径追踪"></a>蒙特卡洛路径追踪</h1><p>&emsp;&emsp;我们在上一章中得到了重要的渲染方程，在这一章中将使用蒙特卡洛算法实现方程中的积分，并用俄罗斯轮盘赌实现间接光照中对渲染方程的递归调用。</p><h2 id="蒙特卡洛"><a href="#蒙特卡洛" class="headerlink" title="蒙特卡洛"></a>蒙特卡洛</h2><p>按一定分布对原函数进行随机采样，利用概率分布函数进行加权平均。</p><ul><li>$\int f(x){\rm d}x&#x3D;\frac{1}{N}\sum^{N}_{i&#x3D;1}\frac{f(X_i)}{p^,(X_i)}$&emsp;$X_i$~$p^,(x)$</li><li>$L_o(p,\omega_o)\approx \frac{1}{N}\sum^{N}_{i&#x3D;1}\frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)}{p^,(\omega_i)}$<br><img src="/img/GAMES101/monte.png" alt="蒙特卡洛"><br>将定积分求解转化为对随机变量求平均。<br>当我们对半球进行均匀采样时：$p^,(\omega_i)&#x3D;\frac{\pi}{2}$</li></ul><h2 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h2><p>若计算每根光线反射出的N跟光线，递归次数呈指数级上涨，开销难以接受。<br><strong>解决方法</strong>：对一个像素内多次发射出一根光线，每次反射只产生一根光线，结果求平均。此时上方的N &#x3D; 1。</p><h2 id="俄罗斯轮盘赌"><a href="#俄罗斯轮盘赌" class="headerlink" title="俄罗斯轮盘赌"></a>俄罗斯轮盘赌</h2><p>接下来解决递归如何返回的问题。在真实世界中的光线可能会经过无数次弹射才进入人眼，但在有限的计算时间内这几乎是无法模拟的。<br><strong>解决方法</strong>：以期望代替无限次递归逼近的结果。设一小数 p(0,1)，每次递归内以概率 (p - 1) 直接返回 0，以概率 p 进入下一层递归，并对结果除以 p。此时递归的期望为：</p><ul><li>$E&#x3D;P*(L_o&#x2F;P)+(1-P)*0&#x3D;L_o$<div class="note note-secondary">            <p>递归的期望值确实是正确的，但是根据实现的不同，或者受制于显示器色域，超过 255 的值可能被截断至 255，导致结果看起来偏暗。</p>          </div></li></ul><h2 id="最后一个问题"><a href="#最后一个问题" class="headerlink" title="最后一个问题"></a>最后一个问题</h2><p>在目前的算法中，从视点发射出的一根光线若直到最终都没有击中发光物体便不会返回任何 Radiance。这样在场景中光源表面积非常小的情况下便很难产生有效的递归，因为对半球内方向随机采样难以精确采样到发光物体。<br><strong>解决方法</strong>：每层递归内将直接光照与间接光照的贡献分离开，并直接对光源进行采样。这时需要将光源方向$\omega$转换为光源在单位球面上对应的面积 A，然后对 A 做积分，此时的概率密度函数为 $\frac{1}{A}$<br><img src="/img/GAMES101/wa.png"></p><ul><li>$d\omega&#x3D;\frac{\cos \theta^,dA}{|x^,-x|^2}$</li></ul><p><em>可以理解为 $\cos \theta^,$ 负责把光源的面积转过来做为一个锥体的底部，再根据相似三角形原理将面积缩放到单位球面上。</em><br>光源对单位面积的贡献为：</p><ul><li>$L_o(x,\omega_o)&#x3D;\int_ALi(x,\omega_i)f_r(x,\omega_i,\omega_o)\frac{\cos \theta \cos \theta^,}{|x^,-x|^2}{\rm d}A$</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>Shad(p, wo) {<br>&emsp;&emsp;对光源采样 （pdf_light &#x3D; 1 &#x2F; A）<br>&emsp;&emsp;if (p点与光源间无遮挡)<br>&emsp;&emsp;&emsp;&emsp;L_dir &#x3D; Li * f_r * cos$\theta$ * cos$\theta^,$ &#x2F; $|x^,-p|^2$ &#x2F; pdf_light<br>&emsp;&emsp;俄罗斯轮盘赌 P_RR<br>&emsp;&emsp;对半球采样（pdf_hemi &#x3D; 1 &#x2F; 2$\pi$）<br>&emsp;&emsp;追踪光线 r(p, wi)<br>&emsp;&emsp;if (r 击中非发光物体 q)<br>&emsp;&emsp;&emsp;&emsp;L_indir &#x3D; Shad(q, -wi) * f_r * $\cos \theta$ &#x2F; pdf_hemi &#x2F; P_RR<br>&emsp;&emsp;return L_dir + L_indir<br>}</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Vector3f <span class="hljs-title">Scene::castRay</span><span class="hljs-params">(<span class="hljs-type">const</span> Ray&amp; ray, <span class="hljs-type">int</span> depth)</span> <span class="hljs-type">const</span> </span>&#123;<br>Intersection inter = <span class="hljs-built_in">intersect</span>(ray);<br><br><span class="hljs-keyword">if</span> (inter.happened) &#123;<br><span class="hljs-keyword">if</span> (inter.m-&gt;<span class="hljs-built_in">hasEmission</span>()) &#123;<br><span class="hljs-comment">// 如果视线可以直接捕捉光源</span><br><span class="hljs-keyword">if</span> (depth == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> inter.m-&gt;<span class="hljs-built_in">getEmission</span>();<br>&#125;<br><span class="hljs-comment">/* 任何 Secondary Ray 击中光源时不返回亮度，</span><br><span class="hljs-comment">   光源提供的亮度由每个非光源交点对光源采样得到 */</span><br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function">Vector3f <span class="hljs-title">L_dir</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Vector3f <span class="hljs-title">L_indir</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>Intersection lightInter;<br><span class="hljs-type">float</span> pdf_light = <span class="hljs-number">0.f</span>;<br><span class="hljs-built_in">sampleLight</span>(lightInter, pdf_light);<br><br><span class="hljs-comment">// 物体表面单位法向量</span><br>Vector3f N = inter.normal;<br><span class="hljs-comment">// 光源表面单位法向量</span><br>Vector3f NN = lightInter.normal;<br><br>Vector3f objPos = inter.coords;<br>Vector3f lightPos = lightInter.coords;<br><br>Vector3f objectToLight = lightPos - objPos;<br><span class="hljs-comment">// objectToLightDierction</span><br>Vector3f o2lDir = objectToLight.<span class="hljs-built_in">normalized</span>();<br><span class="hljs-comment">// objectToLightIntersection</span><br>Intersection o2lInter = <span class="hljs-built_in">intersect</span>(<span class="hljs-built_in">Ray</span>(objPos, o2lDir));<br><br><span class="hljs-comment">// 如果反射击中光源</span><br><span class="hljs-keyword">if</span> (o2lInter.happened &amp;&amp; o2lInter.m-&gt;<span class="hljs-built_in">hasEmission</span>()) &#123;<br><span class="hljs-comment">// (o2lInter.coords - lightPos).norm() &lt; 1e-2</span><br>Vector3f f_r = inter.m-&gt;<span class="hljs-built_in">eval</span>(ray.direction, o2lDir, N);<br>L_dir = lightInter.emit * f_r *<br><span class="hljs-built_in">dotProduct</span>(o2lDir, N) * <span class="hljs-built_in">dotProduct</span>(-o2lDir, NN) /<br><span class="hljs-built_in">dotProduct</span>(objectToLight, objectToLight) / pdf_light;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_random_float</span>() &gt; RussianRoulette) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br>Vector3f nextDir = inter.m-&gt;<span class="hljs-built_in">sample</span>(ray.direction, N).<span class="hljs-built_in">normalized</span>();<br><span class="hljs-function">Ray <span class="hljs-title">nextRay</span><span class="hljs-params">(objPos, nextDir)</span></span>;<br>Intersection nextInter = <span class="hljs-built_in">intersect</span>(nextRay);<br><span class="hljs-keyword">if</span> (nextInter.happened &amp;&amp; !nextInter.m-&gt;<span class="hljs-built_in">hasEmission</span>()) &#123;<br><span class="hljs-type">float</span> pdf_hemi = inter.m-&gt;<span class="hljs-built_in">pdf</span>(ray.direction, nextDir, N);<br>Vector3f f_r = inter.m-&gt;<span class="hljs-built_in">eval</span>(ray.direction, nextDir, N);<br>L_indir = <span class="hljs-built_in">castRay</span>(nextRay, depth + <span class="hljs-number">1</span>) * f_r * <span class="hljs-built_in">dotProduct</span>(nextDir, N) /<br>pdf_hemi / RussianRoulette;<br>&#125;<br><br><span class="hljs-keyword">return</span> L_dir + L_indir;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h2><p><img src="/img/GAMES101/01.png"></p><h1 id="微表面模型"><a href="#微表面模型" class="headerlink" title="微表面模型"></a>微表面模型</h1><p>&emsp;&emsp;所有的 PBR 技术都基于微表面理论。这项理论认为，达到微观尺度之后任何表面都可以用被称为微表面 (Microfacets) 的细小镜面来进行描绘。在微观尺度下，没有任何表面是完全光滑的。然而由于这些微表面已经微小到无法逐像素的继续对其进行区分，因此我们只有假设一个粗糙度 (Roughness) 参数，然后用统计学的方法来概略的估算微表面的粗糙程度。</p><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p><strong>性质</strong><br>非负、线性、可逆、能量守恒、各向同性、各向异性</p><ul><li>$f(i,o)&#x3D;\frac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)}$</li></ul><p>F：菲涅尔方程，定义不同表面角下，表面所反射光线占比。<br>D：法线的分布。<br>G：当 i 或 o 几乎平行于表面时，微观下凹凸不平的表面会发生自遮挡。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里参考 <a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">LearnOpenGL</a> 给出的实现。<br>并且只考虑 PBR 材质中的金属度与粗糙度。</p><p><img src="/img/GAMES101/fm.png" alt="从下往上球体的金属性从0.0变到1.0， 从左到右球体的粗糙度从0.0变到1.0。"></p><h3 id="菲涅尔方程的近似"><a href="#菲涅尔方程的近似" class="headerlink" title="菲涅尔方程的近似"></a>菲涅尔方程的近似</h3><p>这里在 0.04 - ALBEDO (0.96) 间用金属度做插值，0.04 为基础反射率，0.96 接近于铝的反射率。<br>可以简单地认为导体的反射率大于绝缘体，并且对于导体表面，使用它们的折射指数计算基础折射率并不能得出正确的结果。所以我们预先计算出平面的反射率，然后基于相应观察角的 Fresnel-Schlick 近似对这个值进行插值，这样我们就能对金属和非金属材质使用同一个公式了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALBEDO 0.96f</span><br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">FresnelSchlick</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector3f&amp; H, <span class="hljs-type">const</span> Vector3f&amp; V, <span class="hljs-type">const</span> <span class="hljs-type">float</span>&amp; metalness)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">float</span> inter = <span class="hljs-number">0.04f</span> * (<span class="hljs-number">1</span> - metalness) + ALBEDO * metalness;<br>    <span class="hljs-type">float</span> cosTheta = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dotProduct</span>(H, V), <span class="hljs-number">0.f</span>);<br><br>    <span class="hljs-keyword">return</span> inter + (<span class="hljs-number">1.f</span> - inter) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1.f</span> - cosTheta, <span class="hljs-number">5.f</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="法线分布模型"><a href="#法线分布模型" class="headerlink" title="法线分布模型"></a>法线分布模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 表示法线分布方向的正态分布函数</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">DistributionGGX</span><span class="hljs-params">(Vector3f N, Vector3f H, <span class="hljs-type">float</span> roughness)</span> </span>&#123;<br>    <span class="hljs-type">float</span> a = roughness * roughness;<br>    <span class="hljs-type">float</span> a2 = a * a;<br>    <span class="hljs-type">float</span> NdotH = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dotProduct</span>(N, H), <span class="hljs-number">0.f</span>);<br>    <span class="hljs-type">float</span> NdotH2 = NdotH * NdotH;<br><br>    <span class="hljs-type">float</span> nom = a2;<br>    <span class="hljs-type">float</span> denom = (NdotH2 * (a2 - <span class="hljs-number">1.f</span>) + <span class="hljs-number">1.f</span>);<br>    denom = M_PI * denom * denom;<br><br>    <span class="hljs-keyword">return</span> nom / std::<span class="hljs-built_in">max</span>(denom, <span class="hljs-number">1e-5f</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GeometrySchlickGGX</span><span class="hljs-params">(<span class="hljs-type">float</span> NdotV, <span class="hljs-type">float</span> roughness)</span> </span>&#123;<br>    <span class="hljs-type">float</span> r = (roughness + <span class="hljs-number">1.f</span>);<br>    <span class="hljs-type">float</span> k = (r * r) / <span class="hljs-number">8.f</span>;<br><br>    <span class="hljs-type">float</span> nom = NdotV;<br>    <span class="hljs-type">float</span> denom = NdotV * (<span class="hljs-number">1.f</span> - k) + k;<br><br>    <span class="hljs-keyword">return</span> nom / std::<span class="hljs-built_in">max</span>(denom, <span class="hljs-number">1e-5f</span>);<br>&#125;<br><span class="hljs-comment">// 从统计学上近似的求得微平面间相互遮蔽的比率</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">GeometrySmith</span><span class="hljs-params">(Vector3f N, Vector3f V, Vector3f L, <span class="hljs-type">float</span> roughness)</span> </span>&#123;<br>    <span class="hljs-type">float</span> NdotV = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dotProduct</span>(N, V), <span class="hljs-number">0.f</span>);<br>    <span class="hljs-type">float</span> NdotL = std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dotProduct</span>(N, L), <span class="hljs-number">0.f</span>);<br>    <span class="hljs-type">float</span> ggx2 = <span class="hljs-built_in">GeometrySchlickGGX</span>(NdotV, roughness);<br>    <span class="hljs-type">float</span> ggx1 = <span class="hljs-built_in">GeometrySchlickGGX</span>(NdotL, roughness);<br><br>    <span class="hljs-keyword">return</span> ggx1 * ggx2;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BRDF-1"><a href="#BRDF-1" class="headerlink" title="BRDF"></a>BRDF</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALBEDO 0.96f</span><br><br><span class="hljs-function">Vector3f <span class="hljs-title">Material::eval</span><span class="hljs-params">(<span class="hljs-type">const</span> Vector3f &amp;wi, <span class="hljs-type">const</span> Vector3f &amp;wo, <span class="hljs-type">const</span> Vector3f &amp;N)</span></span>&#123;<br>    <span class="hljs-keyword">switch</span>(m_type)&#123;<br>        <span class="hljs-keyword">case</span> DIFFUSE:<br>        &#123;<br>            <span class="hljs-type">float</span> cosalpha = <span class="hljs-built_in">dotProduct</span>(N, wo);<br>            <span class="hljs-keyword">if</span> (cosalpha &gt; <span class="hljs-number">0.f</span>) &#123;<br>                Vector3f diffuse = Kd / M_PI;<br>                <span class="hljs-keyword">return</span> diffuse;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.f</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> Microfacet:<br>        &#123;<br>            <span class="hljs-type">float</span> cosalpha = <span class="hljs-built_in">dotProduct</span>(N, wo);<br>            <span class="hljs-keyword">if</span> (cosalpha &gt; <span class="hljs-number">0.f</span>) &#123;<br>                <span class="hljs-type">float</span> roughness = <span class="hljs-number">0.9f</span>;<br>                <span class="hljs-type">float</span> metallic = <span class="hljs-number">0.9f</span>;<br><br>                Vector3f V = -wi;<br>                Vector3f L = wo;<br>                Vector3f H = <span class="hljs-built_in">normalize</span>(V + L);<br><br>                <span class="hljs-type">float</span> F = Material::<span class="hljs-built_in">FresnelSchlick</span>(H, V, metallic);<br>                <span class="hljs-type">float</span> G = Material::<span class="hljs-built_in">GeometrySmith</span>(N, V, L, roughness);<br>                <span class="hljs-type">float</span> D = Material::<span class="hljs-built_in">DistributionGGX</span>(N, H, roughness);<br><br>                Vector3f nominator = F * G * D;<br>                <span class="hljs-type">float</span> denominator = <span class="hljs-number">4</span> * std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dotProduct</span>(N, V), <span class="hljs-number">0.f</span>) * <br>                    std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dotProduct</span>(N, L), <span class="hljs-number">0.f</span>);<br>                Vector3f specular = nominator / std::<span class="hljs-built_in">max</span>(denominator, <span class="hljs-number">1e-5f</span>);<br>                <br>                Vector3f kS = F;<br>                Vector3f kD = <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">1.f</span>) - kS;<br>                kD = kD * <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">1.f</span> - metallic);<br><br>                Vector3f diffuse = ALBEDO / M_PI;<br><br>                <span class="hljs-comment">/* 应当注意：这里的实现（微表面结合 diffuse）是 LearnOpenGL 提供的模型，</span><br><span class="hljs-comment">                   但是闫老师在 GAMES202 中指出这是错误且没有物理依据的。*/</span><br>                <span class="hljs-keyword">return</span> kD * diffuse + specular;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector3f</span>(<span class="hljs-number">0.f</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101/r1m9.png" alt="r1m9"></div><div class="group-image-wrap"><img src="/img/GAMES101/r5m9.png" alt="r5m9"></div><div class="group-image-wrap"><img src="/img/GAMES101/r9m9.png" alt="r9m9"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101/r1m5.png" alt="r1m5"></div><div class="group-image-wrap"><img src="/img/GAMES101/r5m5.png" alt="r5m5"></div><div class="group-image-wrap"><img src="/img/GAMES101/r9m5.png" alt="r9m5"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/GAMES101/r1m1.png" alt="r1m1"></div><div class="group-image-wrap"><img src="/img/GAMES101/r5m1.png" alt="r5m1"></div><div class="group-image-wrap"><img src="/img/GAMES101/r9m1.png" alt="r9m1"></div></div></div><h2 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/">LearnOpenGL</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Rendering</tag>
      
      <tag>AntiAliasing</tag>
      
      <tag>Rasterization</tag>
      
      <tag>RayTracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Archive】背包，卡肉，镜头抖动，有限状态机</title>
    <link href="/2021/08/29/Unity/"/>
    <url>/2021/08/29/Unity/</url>
    
    <content type="html"><![CDATA[<h2 id="背包系统"><a href="#背包系统" class="headerlink" title="背包系统"></a>背包系统</h2><p>&emsp;&emsp;背包 GUI 的实现、ScriptableObject、数据的存储与读取。</p><h2 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h2><p><img src="/img/Unity/jg.png"></p><ul><li><strong>Bag</strong> 挂载 BagOnDrag 脚本</li><li><strong>Grid</strong> 挂载 Grid Layout Group 组件，使其子物体（Slot）整齐地排放</li><li><strong>Slot</strong> 挂载 Slot 脚本，更改其子物体（Item）以实现拖拽</li><li><strong>Item</strong> 挂载 ItemOnDrag 脚本和 CanvasGroup 组件，以及作为 buttom 用于触发 Slot 中的 OnItemClicked()</li><li><strong>Image 和 Count</strong> 负责物品图片和数量的显示</li></ul><p><a href="https://docs.unity.cn/cn/2019.4/Manual/script-GridLayoutGroup.html">Grid Layout Group</a></p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="物品数据"><a href="#物品数据" class="headerlink" title="物品数据"></a>物品数据</h3><p>以 ScriptableObject 的方式存储每一种物品的数据。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cs">[<span class="hljs-meta">CreateAssetMenu(fileName = <span class="hljs-string">&quot;NewItem&quot;</span>,menuName = <span class="hljs-string">&quot;Inventory/New Item&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InventoryItem</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> itemName;<br>    <span class="hljs-keyword">public</span> Sprite itemSprite;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> itemCount = <span class="hljs-number">1</span>;<br>    [<span class="hljs-meta">TextArea</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> itemInfo;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背包数据"><a href="#背包数据" class="headerlink" title="背包数据"></a>背包数据</h3><p>以 ScriptableObject 的方式存储每个背包的数据,每个背包类内维护一个 List 用于存储多个物品。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cs">[<span class="hljs-meta">CreateAssetMenu(fileName = <span class="hljs-string">&quot;NewBag&quot;</span>, menuName = <span class="hljs-string">&quot;Inventory/New Bag&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InventoryBag</span> : <span class="hljs-title">ScriptableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;InventoryItem&gt; itemList = <span class="hljs-keyword">new</span> List&lt;InventoryItem&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="捡起物品"><a href="#捡起物品" class="headerlink" title="捡起物品"></a>捡起物品</h3><p>ItemOnWorld 挂载在物品对象上，随时更新两个 SO 的数据。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemOnWorld</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> InventoryItem inventoryItem;<br>    <span class="hljs-keyword">public</span> InventoryBag inventoryBag;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (collision.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>            AddItemToBag();<br>            Destroy(gameObject);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddItemToBag</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (inventoryBag.itemList.Contains(inventoryItem)) &#123;<br>            inventoryItem.itemCount++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 背包内不存在此物品</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; inventoryBag.itemList.Count; i++) &#123;<br>                <span class="hljs-comment">// 顺序找到背包内第一个空余位置</span><br>                <span class="hljs-keyword">if</span> (inventoryBag.itemList[i] == <span class="hljs-literal">null</span>) &#123;<br>                    inventoryBag.itemList[i] = inventoryItem;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                Debug.Log(<span class="hljs-string">&quot;Bag Over Flow!&quot;</span>);<br>            &#125;<br>        &#125;<br>        InventoryManager.UpdateGUI();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><p>单例模式的 InventoryManager，主要作用是提供更新 GUI 的接口 <strong>InventoryManager.UpdateGUI()</strong> 。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InventoryManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">static</span> InventoryManager instance;<br><br>    <span class="hljs-keyword">public</span> InventoryBag bag;<br>    <span class="hljs-keyword">public</span> GameObject grid;<br>    <span class="hljs-keyword">public</span> GameObject emptySlot;<span class="hljs-comment">// 预制体Slot</span><br>    <span class="hljs-keyword">public</span> Text itemInfo;<span class="hljs-comment">// 显示在背包左下角的UI</span><br>    <span class="hljs-keyword">public</span> List&lt;GameObject&gt; slotList = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) &#123;<br>            Destroy(gameObject);<br>        &#125;<br>        instance = <span class="hljs-keyword">this</span>;<br>        UpdateGUI();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateItemInfo</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> info</span>)</span> &#123;<br>        instance.itemInfo.text = info;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateGUI</span>()</span> &#123;<br>        <span class="hljs-comment">// 先清空Grid的子物体与slotList[]</span><br>        instance.slotList.Clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; instance.grid.transform.childCount; i++) &#123;<br>            Destroy(instance.grid.transform.GetChild(i).gameObject);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; instance.bag.itemList.Count; i++) &#123;<br>            <span class="hljs-comment">// 将emptySlot生成为grid的子物体，然后加入slotList[]</span><br>            instance.slotList.Add(Instantiate(<br>                instance.emptySlot, instance.grid.transform, <span class="hljs-literal">false</span>));<br><br>            <span class="hljs-comment">// 用itemList[]刷新slotList[]</span><br>            instance.slotList[i].GetComponent&lt;Slot&gt;()<br>                .InitSlot(instance.bag.itemList[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><p>负责 UpdateGUI() 中针对具体 Slot 中 Item 数据的更新，以及负责 bag 中物品描述的更新。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Slot</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject slotItem;<br>    <span class="hljs-keyword">public</span> Image slotImage;<br>    <span class="hljs-keyword">public</span> Text slotCount;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> slotInfo;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>        InventoryManager.UpdateItemInfo(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnItemClicked</span>()</span> &#123;<br>        <span class="hljs-comment">// 在作Item中以OnClick的形式调用</span><br>        InventoryManager.UpdateItemInfo(slotInfo);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitSlot</span>(<span class="hljs-params">InventoryItem inventoryItem</span>)</span> &#123;<br>        <span class="hljs-comment">// 将传入的Itme信息写入该Slot的子物体</span><br>        <span class="hljs-keyword">if</span> (inventoryItem == <span class="hljs-literal">null</span>) &#123;<br>            slotItem.SetActive(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            slotImage.sprite = inventoryItem.itemSprite;<br>            slotCount.text = inventoryItem.itemCount.ToString();<br>            slotInfo = inventoryItem.itemInfo;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背包内物品的拖拽"><a href="#背包内物品的拖拽" class="headerlink" title="背包内物品的拖拽"></a>背包内物品的拖拽</h3><p>实现 EventSystems 中三个接口以响应鼠标的交互。<br>更改 Item 的父级和 Item 的位置以实现拖拽效果。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemOnDrag</span><br>    : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IBeginDragHandler</span>, <span class="hljs-title">IDragHandler</span>, <span class="hljs-title">IEndDragHandler</span><br>&#123;<br>    <span class="hljs-keyword">public</span> InventoryBag bag;<br><br>    <span class="hljs-keyword">private</span> Transform originalParent;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> firstIndex, secondIndex;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBeginDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;<br>        firstIndex = GetIndex(transform.parent);<br>        originalParent = transform.parent;<br>        <span class="hljs-comment">// 将Item移至Canvas子集以不至于被其他UI遮挡</span><br>        transform.SetParent(transform.parent.parent.parent.parent);<br>        transform.position = eventData.position;<br>        <span class="hljs-comment">// 令所拖拽的Item本身不会遮挡鼠标射线</span><br>        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;<br>        transform.position = eventData.position;<br>        <span class="hljs-comment">// Debug.Log(eventData.pointerCurrentRaycast.gameObject.name);</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEndDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;<br>        GameObject crtObject = eventData.pointerCurrentRaycast.gameObject;<br>        <span class="hljs-keyword">if</span> (crtObject == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 拖至UI界面之外，Item复位</span><br>            transform.SetParent(originalParent);<br>            transform.position = originalParent.transform.position;<br>            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (crtObject.name == <span class="hljs-string">&quot;Image&quot;</span> || crtObject.name == <span class="hljs-string">&quot;Count&quot;</span>) &#123;<br>            <span class="hljs-comment">// 拖至另一Item上，交换两者</span><br>            Transform crtItem = crtObject.transform.parent;<br>            Transform crtSlot = crtItem.parent;<br>            secondIndex = GetIndex(crtSlot);<br><br>            transform.SetParent(crtSlot);<br>            transform.position = crtSlot.position;<br><br>            crtItem.SetParent(originalParent);<br>            crtItem.position = originalParent.position;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(crtObject.name == <span class="hljs-string">&quot;Slot(Clone)&quot;</span>) &#123;<br>            <span class="hljs-comment">// 拖至空Slot</span><br>            secondIndex = GetIndex(crtObject.transform);<br>            transform.SetParent(crtObject.transform);<br>            transform.position = crtObject.transform.position;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 拖至其他UI上，Item复位</span><br>            transform.SetParent(originalParent);<br>            transform.position = originalParent.transform.position;<br>            GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Debug.Log(<span class="hljs-string">&quot;firstIndex: &quot;</span> + firstIndex + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-string">&quot;secondIndex: &quot;</span> + secondIndex);<br>    <br>        <span class="hljs-comment">// 更新itemList</span><br>        InventoryItem tmp = bag.itemList[firstIndex];<br>        bag.itemList[firstIndex] = bag.itemList[secondIndex];<br>        bag.itemList[secondIndex] = tmp;<br><br>        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetIndex</span>(<span class="hljs-params">Transform currentSlot</span>)</span> &#123;<br>        <span class="hljs-comment">// 返回slot在grid中的顺序</span><br>        Transform grid = currentSlot.parent;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt; grid.childCount; i++) &#123;<br>            <span class="hljs-keyword">if</span> (grid.GetChild(i) == currentSlot) &#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="背包的拖拽"><a href="#背包的拖拽" class="headerlink" title="背包的拖拽"></a>背包的拖拽</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BagOnDrag</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IDragHandler</span><br>&#123;<br>    <span class="hljs-keyword">private</span> RectTransform rectTransform;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        rectTransform = GetComponent&lt;RectTransform&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;<br>        rectTransform.anchoredPosition += eventData.delta;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="存储-Scriptable-Object"><a href="#存储-Scriptable-Object" class="headerlink" title="存储 Scriptable Object"></a>存储 Scriptable Object</h2><p><strong>存储时</strong><br>Scriptable Object 通过 JsonUtility.ToJson(so) 转换为 json。<br>json 通过 formatter.Serialize(file, json) 写入文件。</p><p><strong>读取时</strong><br>文件通过 formatter.Deserialize(file) 转换为 json。<br>json 通过 JsonUtility.FromJsonOverwrite(json, so) 写入 Scriptable Object。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization.Formatters.Binary;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SaveLoadManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> InventoryBag inventoryBag;<br>    <span class="hljs-keyword">public</span> InventoryItem item1;<br>    <span class="hljs-keyword">public</span> InventoryItem item2;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> PATH;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        PATH = Application.persistentDataPath;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SaveGame</span>()</span> &#123;<br>        <span class="hljs-comment">// 在bottom中被调用</span><br>        Debug.Log(PATH);<br>        <span class="hljs-keyword">if</span> (!Directory.Exists(PATH + <span class="hljs-string">&quot;/SaveData&quot;</span>)) &#123;<br>            Directory.CreateDirectory(PATH + <span class="hljs-string">&quot;/SaveData&quot;</span>);<br>        &#125;<br><br>        SaveData(inventoryBag, <span class="hljs-keyword">nameof</span>(inventoryBag));<br>        SaveData(item1, <span class="hljs-keyword">nameof</span>(item1));<br>        SaveData(item2, <span class="hljs-keyword">nameof</span>(item2));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SaveData</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T so, <span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        BinaryFormatter formatter = <span class="hljs-keyword">new</span> BinaryFormatter();<br>        FileStream file = File.Create(PATH + <span class="hljs-string">&quot;/SaveData/&quot;</span> + name + <span class="hljs-string">&quot;.bin&quot;</span>);<br>        <span class="hljs-built_in">string</span> json = JsonUtility.ToJson(so);<br>        formatter.Serialize(file, json);<br>        file.Close();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadGame</span>()</span> &#123;<br>        <span class="hljs-comment">// 在bottom中被调用</span><br>        LodData(inventoryBag, <span class="hljs-keyword">nameof</span>(inventoryBag));<br>        LodData(item1, <span class="hljs-keyword">nameof</span>(item1));<br>        LodData(item2, <span class="hljs-keyword">nameof</span>(item2));<br><br>        InventoryManager.UpdateGUI();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LodData</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T so, <span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        BinaryFormatter formatter = <span class="hljs-keyword">new</span> BinaryFormatter();<br>        <span class="hljs-keyword">if</span> (File.Exists(PATH + <span class="hljs-string">&quot;/SaveData/&quot;</span> + name + <span class="hljs-string">&quot;.bin&quot;</span>)) &#123;<br>            FileStream file =<br>                File.Open(PATH + <span class="hljs-string">&quot;/SaveData/&quot;</span> + name + <span class="hljs-string">&quot;.bin&quot;</span>, FileMode.Open);<br>            <span class="hljs-built_in">string</span> json = (<span class="hljs-built_in">string</span>)formatter.Deserialize(file);<br>            JsonUtility.FromJsonOverwrite(json, so);<br>            file.Close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/ScriptableObject.html">Scriptable Object</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/CreateAssetMenuAttribute.html">Create Asset Menu Attribute</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Object.Instantiate.html">Instantiate</a><br><a href="https://docs.unity.cn/cn/2019.4/Manual/SupportedEvents.html">Supported Events</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/RectTransform.html">Rect Transform</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Application-persistentDataPath.html">persistentDataPath</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Windows.Directory.html">Directory</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/JsonUtility.html">JsonUtility</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter?view=net-5.0">BinaryFormatter</a></p><h2 id="打击感"><a href="#打击感" class="headerlink" title="打击感"></a>打击感</h2><p>&emsp;&emsp;一般来说，打击感由帧冻结、镜头抖动与运动、敌人的受击反馈（动画、音效、击退等）、特效、环境的反馈等组成。<br><img src="/img/Unity/dhq.png" alt="动画器"></p><h3 id="连击"><a href="#连击" class="headerlink" title="连击"></a>连击</h3><div class="note note-secondary">            <p>&emsp;&emsp;攻击结束方法可以不在攻击动画的最后一帧调用，而是提前几帧。这是因为连击往往存在预输入，这样做可以提高连贯性，提升手感。</p>          </div><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">private</span> Coroutine tmpCoroutine = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 仅在 Attack 中使用</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attack</span>()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!animator.GetBool(isAttackID) &amp;&amp; !isHurt &amp;&amp; !isDash &amp;&amp; !isParryStance) &#123;<br>        <span class="hljs-comment">// 可攻击的状态</span><br>        <span class="hljs-keyword">if</span> (uponGround) &#123;<br>            <span class="hljs-comment">// 地面攻击</span><br><br>            <span class="hljs-keyword">if</span> (Input.GetMouseButton(<span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-comment">// 左键轻攻击</span><br>                <span class="hljs-keyword">if</span> (tmpCoroutine != <span class="hljs-literal">null</span>) &#123;<br>                    StopCoroutine(tmpCoroutine);<br>                &#125;<br>                <span class="hljs-comment">/* 关闭协程确保这段时间内 isAttack 不会被设为 false</span><br><span class="hljs-comment">                   启动协程倒计时使 isAttack 为 false */</span><br>                tmpCoroutine = StartCoroutine(WaitForAttackOver(<span class="hljs-number">4f</span> / <span class="hljs-number">14f</span>));<br><br>                body.velocity = Vector2.zero;<br>                isAttack = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 每次轻攻击时计时器重置为最大值</span><br>                timer = interval;<br>                combo++;<br>                <span class="hljs-keyword">if</span> (combo &gt; finalMaxCombo) &#123;<br>                    <span class="hljs-comment">// combo 为 1 时播放一段攻击动画，为 2 时播放二段攻击动画</span><br>                    combo = <span class="hljs-number">1</span>;<br>                &#125;<br><br>                animator.SetBool(isAttackID, <span class="hljs-literal">true</span>);<br>                animator.SetTrigger(lightAttackID);<br>                body.MovePosition(frontPoint.position);<br>                animator.SetInteger(comboID, combo);<br>                attackName = <span class="hljs-string">&quot;Light&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Input.GetMouseButton(<span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// 右键重攻击</span><br>                <span class="hljs-keyword">if</span> (tmpCoroutine != <span class="hljs-literal">null</span>) &#123;<br>                    StopCoroutine(tmpCoroutine);<br>                &#125;<br>                tmpCoroutine = StartCoroutine(WaitForAttackOver(<span class="hljs-number">6f</span> / <span class="hljs-number">14f</span>));<br><br>                body.velocity = Vector2.zero;<br>                isAttack = <span class="hljs-literal">true</span>;<br>                animator.SetBool(isAttackID, <span class="hljs-literal">true</span>);<br>                animator.SetTrigger(haveyAttackID);<br>                attackName = <span class="hljs-string">&quot;Heavy&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 空中攻击</span><br><br>            <span class="hljs-keyword">if</span> (Input.GetMouseButton(<span class="hljs-number">0</span>)) &#123;<br>                <span class="hljs-comment">// 空中普通攻击</span><br>                animator.SetBool(isAttackID, <span class="hljs-literal">true</span>);<br>                animator.SetTrigger(lightAttackID);<br>                attackName = <span class="hljs-string">&quot;Light&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (Input.GetMouseButton(<span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// 下落攻击</span><br>                <span class="hljs-keyword">if</span> (tmpCoroutine != <span class="hljs-literal">null</span>) &#123;<br>                    StopCoroutine(tmpCoroutine);<br>                &#125;<br>                tmpCoroutine = StartCoroutine(WaitForAttackOver(<span class="hljs-number">6f</span> / <span class="hljs-number">14f</span>));<br><br>                body.velocity = Vector2.zero;<br>                isAttack = <span class="hljs-literal">true</span>;<br>                isSlam = <span class="hljs-literal">true</span>;<br>                animator.SetBool(isAttackID, <span class="hljs-literal">true</span>);<br>                animator.SetTrigger(haveyAttackID);<br>                attackName = <span class="hljs-string">&quot;Slam&quot;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (timer &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 倒计时结束后重置 combo 数</span><br>        timer -= Time.deltaTime;<br>        <span class="hljs-keyword">if</span> (timer &lt;= <span class="hljs-number">0</span>) &#123;<br>            combo = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在Attack()中被调用</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">WaitForAttackOver</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> time</span>)</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params">time</span>)</span>;<br>    isAttack = <span class="hljs-literal">false</span>;<br>    isSlam = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 确保即使攻击动画被打断，animator 中的 isAttack 也会正确地被重置</span><br>    animator.SetBool(isAttackID, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 在每个攻击动画快结束时调用</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AttackOver</span>()</span> &#123;<br>    animator.SetBool(isAttackID, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="帧冻结"><a href="#帧冻结" class="headerlink" title="帧冻结"></a>帧冻结</h3><div class="note note-secondary">            <p>帧冻结结束后可以适当提升3-5倍的动画速度以补偿缺失的时间。</p>          </div><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AttackSense</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AttackSense instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isShake;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        instance = <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FrameFreeze</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> pauseFrame</span>)</span> &#123;<br>        StartCoroutine(PauseOnAttack(pauseFrame));<br>    &#125;<br>    <span class="hljs-function">IEnumerator <span class="hljs-title">PauseOnAttack</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> pauseFrame</span>)</span> &#123;<br>        <span class="hljs-built_in">float</span> pauseTime = pauseFrame / <span class="hljs-number">60f</span>;<br>        Time.timeScale = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSecondsRealtime</span>(<span class="hljs-params">pauseTime</span>)</span>;<br>        Time.timeScale = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="镜头抖动"><a href="#镜头抖动" class="headerlink" title="镜头抖动"></a>镜头抖动</h3><p>为相机添加<br><img src="/img/Unity/dd1.png"><br>为玩家的攻击碰撞体添加，并调整对应的参数<br><img src="/img/Unity/dd2.png"></p><h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>敌人的反馈会在有限状态机中进行具体的实现。</p><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>&emsp;&emsp;有限状态机是一个具有有限数量状态的模型，并且同时只能处于一种状态，可以通过外部输入等方式触发状态之间的切换。这里实现一个简易的敌人 AI。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>所有的状态类都继承这个接口。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IState</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnter</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnFixedUpdate</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnExit</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FSM"><a href="#FSM" class="headerlink" title="FSM"></a>FSM</h3><p>挂载在敌人身上，这里省略一些组件的定义与获取。一些对所有状态通用的方法也可以写在这里。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-comment">// 先创建一个枚举类存储所有状态，作为字典中的键</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> StateType &#123;<br>    Idle, Run, Attack, Hurt, Throw, SpecialAttack<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FSM</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> IState crtState = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 当前状态</span><br>    <span class="hljs-keyword">private</span> Dictionary&lt;StateType, IState&gt; stateLise =<br>        <span class="hljs-keyword">new</span> Dictionary&lt;StateType, IState&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 注册状态并将 FSM 自身传入状态</span><br>        stateLise.Add(StateType.Idle, <span class="hljs-keyword">new</span> IdleState(<span class="hljs-keyword">this</span>));<br>        stateLise.Add(StateType.Run, <span class="hljs-keyword">new</span> RunState(<span class="hljs-keyword">this</span>));<br>        stateLise.Add(StateType.Attack, <span class="hljs-keyword">new</span> AttackState(<span class="hljs-keyword">this</span>));<br>        stateLise.Add(StateType.Hurt, <span class="hljs-keyword">new</span> HurtState(<span class="hljs-keyword">this</span>));<br>        stateLise.Add(StateType.Throw, <span class="hljs-keyword">new</span> ThrowState(<span class="hljs-keyword">this</span>));<br>        stateLise.Add(StateType.SpecialAttack, <span class="hljs-keyword">new</span> SpecialAttackState(<span class="hljs-keyword">this</span>));<br><br>        ChangeState(StateType.Idle);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        crtState.OnUpdate();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>        crtState.OnFixedUpdate();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ChangeState</span>(<span class="hljs-params">StateType type</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (crtState != <span class="hljs-literal">null</span>) &#123;<br>            crtState.OnExit();<br>        &#125;<br>        crtState = stateLise[type];<br>        crtState.OnEnter();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="状态类"><a href="#状态类" class="headerlink" title="状态类"></a>状态类</h3><p><em>以普通攻击状态为例。</em><br>动画在具体的状态类中进行控制，动画中包含了录制好的攻击碰撞器（Trigger）的启用与变形。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AttackState</span> : <span class="hljs-title">IState</span> &#123;<br>    <span class="hljs-keyword">private</span> FSM fsm;<br>    <span class="hljs-keyword">private</span> AnimatorStateInfo animeInfo;<br>    <span class="hljs-comment">// 在构造函数中获取 fsm</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AttackState</span>(<span class="hljs-params">FSM fsmIn</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.fsm = fsmIn;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnter</span>()</span> &#123;<br>        fsm.body.velocity = Vector2.zero;<br>        fsm.animator.Play(<span class="hljs-string">&quot;Rogue_Attack&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>()</span> &#123;<br>        animeInfo = fsm.animator.GetCurrentAnimatorStateInfo(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (animeInfo.normalizedTime &gt;= <span class="hljs-number">0.99f</span>) &#123;<br>            fsm.ChangeState(StateType.Idle);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnFixedUpdate</span>()</span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnExit</span>()</span> &#123;<br>        fsm.idleStartTime = Time.time;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>&emsp;&emsp;对于需要大量或者多次反复实例化，且需要销毁的物体（比如子弹、残影等），频繁地创建与销毁物体对于性能的开销过大。</p><p>&emsp;&emsp;故使用对象池，提前生成一定数量的空物体，在需要时取一进行启用与赋值，一段时间后进行回收，一定程度上减少了动态加载性能的消耗。</p><p>&emsp;&emsp;这里实现一个角色冲锋产生残影的效果。</p><h3 id="预制体"><a href="#预制体" class="headerlink" title="预制体"></a>预制体</h3><p><img src="/img/Unity/image.png" alt="空物体预制体"></p><h3 id="对象池实现"><a href="#对象池实现" class="headerlink" title="对象池实现"></a>对象池实现</h3><p>由一单例控制空物体的预生成、启用和回收。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AfterimagePool</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AfterimagePool instance;<br>    <span class="hljs-keyword">public</span> GameObject imagePrefab;<br><br>    <span class="hljs-keyword">private</span> Queue&lt;GameObject&gt; pool = <span class="hljs-keyword">new</span> Queue&lt;GameObject&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">this</span>;<br>        &#125;<br>        FillPoll(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在对象自身脚本中调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReturnToPool</span>(<span class="hljs-params">GameObject objectIn</span>)</span> &#123;<br>        objectIn.SetActive(<span class="hljs-literal">false</span>);<br>        pool.Enqueue(objectIn);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FillPoll</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> num</span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            GameObject newImage = Instantiate(imagePrefab);<br>            newImage.transform.SetParent(transform);<br>            ReturnToPool(newImage);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Player 为冲刺状态时会在 FixedUpdate 中反复调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeFromPool</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (pool.Count &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 对象池不够用时多生成几个预制件</span><br>            FillPoll(<span class="hljs-number">5</span>);<br>        &#125;<br>        GameObject crtImage = pool.Dequeue();<br>        crtImage.SetActive(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启用物体"><a href="#启用物体" class="headerlink" title="启用物体"></a>启用物体</h3><p>在 OnEnable() 中将 Player 此刻的 Sprite、位置等信息赋给空物体，然后不断减小其 Alpha 值。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Afterimage</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> activeTime;<br>    [<span class="hljs-meta">Range(0f, 1f)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> startAlpha;<br><br>    <span class="hljs-keyword">private</span> Transform player;<br>    <span class="hljs-keyword">private</span> SpriteRenderer thisSR, playerSR;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> alpha, startTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>        player = GameObject.FindGameObjectWithTag(<span class="hljs-string">&quot;Player&quot;</span>).transform;<br>        thisSR = GetComponent&lt;SpriteRenderer&gt;();<br>        playerSR = player.GetComponent&lt;SpriteRenderer&gt;();<br><br>        alpha = startAlpha;<br>        startTime = Time.time;<br><br>        thisSR.sprite = playerSR.sprite;<br>        transform.position = player.position;<br>        transform.localScale = player.localScale;<br>        transform.rotation = player.rotation;<br>        StartCoroutine(DecreaseAlpha());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        thisSR.color = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">1</span>, alpha);<br>        <span class="hljs-keyword">if</span> (Time.time - startTime &gt;= activeTime) &#123;<br>            AfterimagePool.instance.ReturnToPool(gameObject);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">DecreaseAlpha</span>()</span> &#123;<br>        <span class="hljs-keyword">while</span> (alpha &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// alpha 需要在 activeTime 秒内从 startAlpha 减为 0</span><br>            alpha -= (startAlpha / (activeTime * <span class="hljs-number">50</span>));<br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForFixedUpdate</span>()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例有且仅有一个静态的实例，可以直接通过这个实例调用方法，而无需实例化该类的对象。</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExampleManager instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExampleFun</span>()</span>&#123;<br>        DO SOMETHING;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>外部调用时只需写作</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cs">ExampleManager.instance.ExampleFun();<br></code></pre></td></tr></table></figure><h3 id="另一种做法"><a href="#另一种做法" class="headerlink" title="另一种做法"></a>另一种做法</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExampleManager instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExampleManager Instance &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                instance = FindObjectOfType&lt;ExampleManager&gt;();<br>            &#125;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExampleFun</span>()</span>&#123;<br>        DO SOMETHING;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>外部调用时写作</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cs">ExampleManager.Instance.ExampleFun();<br></code></pre></td></tr></table></figure><h3 id="更优雅的做法"><a href="#更优雅的做法" class="headerlink" title="更优雅的做法"></a>更优雅的做法</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleManager</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">MonoBehaviour</span> <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">ExampleManager</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExampleManager Instance &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span>&#123;<br>        id(instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = (T)<span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> IsInit&#123;<br>        <span class="hljs-keyword">get</span>&#123;<br>            <span class="hljs-keyword">return</span> (instance != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestory</span>()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">this</span>)&#123;<br>            instance = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以后任何新的单例类只用继承这个泛型类即可。</p><h3 id="我的-SoundManager"><a href="#我的-SoundManager" class="headerlink" title="我的 SoundManager"></a>我的 SoundManager</h3><h4 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h4><ul><li>首先需要一个挂载 Manager 的 Object</li><li>上一个场景的 Manager 实例需要带到下一个场景中去，故使用 DontDestroyOnLoad(gameObject)</li><li>调试时若不从第一个场景进入则不存在该 Object，十分不便</li><li>若每个场景都放置该 bject，大量不会销毁的 Object 会带着其上挂载的的 Manager 堆积起来</li><li>故在 Awake 中做判断销毁任何新加载的 Object<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SFXMananger</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SFXMananger instance;<br><br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> AudioClip hurtAudio, collectAudio, enemyDestoryAudio;<br>    <span class="hljs-keyword">private</span> AudioSource audioSource;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        audioSource = GetComponent&lt;AudioSource&gt;();<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instance != <span class="hljs-keyword">this</span>) &#123;<br>            Destroy(gameObject);<br>        &#125;<br>        DontDestroyOnLoad(gameObject);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HurtAudio</span>()</span> &#123;<br>        audioSource.clip = hurtAudio;<br>        audioSource.Play();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CollectAudio</span>()</span> &#123;<br>        audioSource.clip = collectAudio;<br>        audioSource.Play();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EnemyDestoryAudio</span>()</span> &#123;<br>        audioSource.clip = enemyDestoryAudio;<br>        audioSource.Play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="bgm"><a href="#bgm" class="headerlink" title="bgm"></a>bgm</h4><p>在满足与音效相同的条件之上，反复加载同一场景时，我不希望 bgm 从头开始播放。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BGMManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BGMManager instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> sceneIndex;<br><br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> AudioClip openingBGM, scene1BGM, scene2BGM, scene3BGM, endingBGM, defautBGM;<br>    <span class="hljs-keyword">private</span>  AudioSource audioSource;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span> ()</span> &#123;<br>        audioSource = GetComponent&lt;AudioSource&gt;();<br>        <span class="hljs-built_in">int</span> crtIndex = SceneManager.GetActiveScene().buildIndex;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 只有首个 Manager 加载时会进入这个分支</span><br>            instance = <span class="hljs-keyword">this</span>;<br>            sceneIndex = crtIndex;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instance != <span class="hljs-keyword">this</span>) &#123;<br>            Destroy(gameObject);<br>            <span class="hljs-keyword">if</span> (sceneIndex != crtIndex) &#123;<br>                <span class="hljs-comment">// 根据关卡编号切换 bgm，重新加载同一关时则不需要切换</span><br>                instance.SwitchBGM(crtIndex);<br>                sceneIndex = crtIndex;<br>            &#125;<br>        &#125;<br>        DontDestroyOnLoad(gameObject);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SwitchBGM</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (i) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                audioSource.clip = openingBGM;<br>                audioSource.Play();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                audioSource.clip = scene1BGM;<br>                audioSource.Play();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                audioSource.clip = scene2BGM;<br>                audioSource.Play();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                audioSource.clip = scene3BGM;<br>                audioSource.Play();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                audioSource.clip = endingBGM;<br>                audioSource.Play();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-literal">default</span>:<br>                audioSource.clip = defautBGM;<br>                audioSource.Play();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>&emsp;&emsp;协程就像一个函数，能够暂停执行并将控制权返还给 Unity 一段时间，可以是等待一帧，可以是等待几秒，也可以是等待另一个协程。当需要一个函数的内容（如一个循环）不需要在单帧内执行完成时往往会使用协程。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function">IEnumerator <span class="hljs-title">Fun</span>()</span>&#123;<br>    DO SOMETHING;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">// 暂停执行并在下一帧恢复的点</span><br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">.1</span>f</span>)</span>;<span class="hljs-comment">// 暂停执行并等待 0.1s 后恢复的点</span><br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">Fun2(</span>))</span>;<span class="hljs-comment">// 暂停执行并等待 Fun2() 返还控制权</span><br>&#125;<br><br>StartCoroutine(Fun());<br></code></pre></td></tr></table></figure><h3 id="我的主菜单"><a href="#我的主菜单" class="headerlink" title="我的主菜单"></a>我的主菜单</h3><p>间隔dt秒依次激活所有 UI。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainMenu</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject titleUI, startUI, endUI;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        StartCoroutine(Delayed(<span class="hljs-number">0.65f</span>, titleUI, startUI, endUI));<br>    &#125;<br>    <span class="hljs-function">IEnumerator <span class="hljs-title">Delayed</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> dt, <span class="hljs-keyword">params</span> GameObject[] list</span>)</span> &#123;<br>        <span class="hljs-keyword">foreach</span> (GameObject obj <span class="hljs-keyword">in</span> list) &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params">dt</span>)</span>;<br>            obj.SetActive(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Bounds.html">Bounds</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Rigidbody2D.MovePosition.html">MovePosition</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Animator.html">Animator</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/AnimatorStateInfo.html">AnimatorStateInfo</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/SpriteRenderer.html">SpriteRenderer</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/SceneManagement.SceneManager.html">SceneManager</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/SceneManagement.Scene.html">Scene</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Object.DontDestroyOnLoad.html">DontDestroyOnLoad</a><br><a href="https://docs.unity.cn/cn/2019.4/Manual/Coroutines.html">Coroutines</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/YieldInstruction.html">YieldInstruction</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Archive】Sunny Land, a platformmer game</title>
    <link href="/2021/08/19/SunnyLand/"/>
    <url>/2021/08/19/SunnyLand/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><ul><li>使用 Unity 制作的 2D 平台跳跃游戏</li><li>压缩包大小：46MB</li><li>平台：Win</li><li>只有三关，根据游戏经验的不同，完整的游戏时长会在 10min-60min 之间</li><li><a href="https://pan.baidu.com/s/13p5wTAWneAB5FFj7NqWDCw">百度网盘</a> 提取码: twwx</li><li><a href="https://wwr.lanzoui.com/iIc6zstlg8h">蓝奏云</a></li></ul><h2 id="一览"><a href="#一览" class="headerlink" title="一览"></a>一览</h2><p><img src="/img/SunnyLand/yl1.png"><br><img src="/img/SunnyLand/yl3.png"></p><h2 id="关于关卡设计"><a href="#关于关卡设计" class="headerlink" title="关于关卡设计"></a>关于关卡设计</h2><div class="note note-secondary">            <p>如果您还未进行过游戏，强烈建议体验过后再继续阅读，以免破坏您的游戏体验。</p>          </div><p>林田宏一曾提到过任天堂的关卡设计公式：<strong>介绍、练习、掌握、决战</strong>。我对此的理解是：</p><ol><li><strong>介绍</strong>  在安全的环境下向玩家介绍一个新机制。</li><li><strong>练习与掌握</strong>  逐渐提高难度，尝试将新机制与旧机制相结合。</li><li><strong>决战</strong>  玩家对机制掌握程度的综合考验，同时包含一定的仪式性以带来成就感。</li></ol><p>同时，对于介绍部分，我更倾向于以潜移默化的方式，以非文字的形式教会玩家一个机制。</p><h3 id="以第一关为例"><a href="#以第一关为例" class="headerlink" title="以第一关为例"></a>以第一关为例</h3><p>&emsp;&emsp; <strong>图1.1中</strong> ，三次起跳点的间隔是一模一样的。玩家在熟悉这个节奏后，第三次起跳后一定会踩到青蛙身上将青蛙消灭.这里介绍的便是下落可以消灭敌人的机制。</p><ul><li><em>这里借鉴了空洞骑士的新手教程。</em></li></ul><p>&emsp;&emsp; <strong>图1.2</strong> 青蛙之后紧接着放置了一个不能以普通方式获得的钻石，这里需要利用消灭青蛙之后重置跳跃次数的机制进行二段跳。</p><ul><li><em>当然这是个不讲理的设计，理想情况是由经验丰富玩家下意识按出二段跳并收获一点小惊喜，然而实际测试时发现多数玩家会在多次重开关卡后才意识到这个机制。回头有想法了再优化罢。</em></li></ul><p>&emsp;&emsp; <strong>图1.3</strong> 中设置之前两倍宽的跳跃距离并在正中央放置樱桃，这里介绍的是拾取樱桃可以增加跳跃次数的机制</p><p>&emsp;&emsp; <strong>图1.4</strong> 便是对玩家的最终考验，兼具难度与爽快（</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/SunnyLand/s11.png" alt="1.1"></div><div class="group-image-wrap"><img src="/img/SunnyLand/s12.png" alt="1.2"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/SunnyLand/s13.png" alt="1.3"></div><div class="group-image-wrap"><img src="/img/SunnyLand/s14.png" alt="1.4"></div></div></div><p><strong>总结一下</strong><br>&emsp;&emsp;关卡设计过于依赖玩家先前的游戏经验了。<br>&emsp;&emsp;测试时有人能在十分钟内通关并且挖掘出一些我也没有意识到的机制，但同时更多的人会吐槽难度过高有点折磨。如何找到其中的平衡点是还需要考虑的事。</p><h2 id="关于机制"><a href="#关于机制" class="headerlink" title="关于机制"></a>关于机制</h2><p><strong>明文介绍过的机制</strong></p><ul><li>A、D移动</li><li>空格跳跃</li><li>R重新开始当前关卡</li></ul><p><strong>需要玩家悟出来的机制</strong></p><ul><li>拾取樱桃增加一次跳跃次数</li><li>消灭敌人重置跳跃次数</li><li>触地重置跳跃次数</li><li>非触地状态无法起跳</li></ul><p><strong>其他（没什么用）的机制</strong></p><ul><li>S下蹲</li><li>N下一关</li><li>小狐狸会被移动板压死</li><li>一处隐藏</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><img src="/img/SunnyLand/ed.png"></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.bilibili.com/video/BV1tq4y1M78n">演示视频</a><br><a href="https://github.com/Hinageshi01/2DPlatformProject">GitHub</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Archive】Make Your First Game</title>
    <link href="/2021/08/12/MakeYourFirstGame/"/>
    <url>/2021/08/12/MakeYourFirstGame/</url>
    
    <content type="html"><![CDATA[<h2 id="角色控制，包括移动与多段跳"><a href="#角色控制，包括移动与多段跳" class="headerlink" title="角色控制，包括移动与多段跳"></a>角色控制，包括移动与多段跳</h2><h3 id="朝向"><a href="#朝向" class="headerlink" title="朝向"></a>朝向</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-built_in">float</span> forward = Input.GetAxisRaw(<span class="hljs-string">&quot;Horizontal&quot;</span>);<span class="hljs-comment">// 返回-1,0,1</span><br><span class="hljs-keyword">if</span> (forward != <span class="hljs-number">0</span>) &#123;<br> transform.localScale = <span class="hljs-keyword">new</span> Vector3(forward, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed;<br><span class="hljs-keyword">private</span> Rigidbody2D body;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span>&#123;<br> body = GetComponent&lt;Rigidbody2D&gt;();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpDate</span>()</span>&#123;<br> <span class="hljs-built_in">float</span> horizontalMove = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br> body.velocity =<br>        <span class="hljs-keyword">new</span> Vector2(horizontalMove * speed * Time.fixedDeltaTime, body.velocity.y);<br> <span class="hljs-comment">// Input.GetAxis()返回-1f至1f的浮点，这么做会使角色移动产生“脚滑”的现象</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h3><p>以跳跃作为核心玩法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> jumpForce;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> finalJumpCount;<span class="hljs-comment">// 用于重置jumpCount</span><br><span class="hljs-keyword">public</span> Transform footPoint;<span class="hljs-comment">// 用于检测脚是否与地面接触</span><br><span class="hljs-keyword">public</span> LayerMask ground;<span class="hljs-comment">// 代表地面Layer</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> jumpCount;<span class="hljs-comment">// 代表玩家当前可跳跃的次数</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> jumpPressed = <span class="hljs-literal">false</span>, isJumped = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> time = <span class="hljs-number">-1f</span>;<span class="hljs-comment">// 用于确保jumpPressed随时处于正确状态的计时器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>    <span class="hljs-comment">// 在Update中确保能敏感地接收到起跳请求，再去FixedUpDate中进行Rigidbody相关的运算</span><br>    <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>) &amp;&amp; jumpCount &gt; <span class="hljs-number">0</span>) &#123;<br>        jumpPressed = <span class="hljs-literal">true</span>;<br>        time = Time.time + <span class="hljs-number">0.05f</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (time &gt;= <span class="hljs-number">0</span> &amp;&amp; time &lt; Time.time) &#123;<br>        <span class="hljs-comment">// 经过一个短暂的计时后重置jumpPressed</span><br>        jumpPressed = <span class="hljs-literal">false</span>;<br>        time = <span class="hljs-number">-1f</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span>&#123;<br>    <span class="hljs-keyword">if</span> (Physics2D.OverlapCircle(footPoint.position, <span class="hljs-number">0.1f</span>, ground)) &#123;<br>        <span class="hljs-comment">// 落地时重置跳跃相关的参数，而且要避免刚起跳时OverlapCircle检测到地面</span><br>        jumpCount = finalJumpCount;<br>        isJumped = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (jumpPressed) &#123;<br>        <span class="hljs-comment">// 跳跃</span><br>        <span class="hljs-keyword">if</span> (Physics2D.OverlapCircle(footPoint.position, <span class="hljs-number">0.3f</span>, ground)) &#123;<br>            <span class="hljs-comment">// 地面起跳</span><br>            body.velocity = <span class="hljs-keyword">new</span> Vector2(body.velocity.x, jumpForce);<br>            jumpCount--;<br>            jumpPressed = <span class="hljs-literal">false</span>;<br>            isJumped = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 代表经过跳跃离开地面</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isJumped) &#123;<br>            <span class="hljs-comment">// 空中起跳</span><br>            body.velocity = <span class="hljs-keyword">new</span> Vector2(body.velocity.x, jumpForce);<br>            jumpCount--;<br>            jumpPressed = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 剩余情况为不经跳跃离开地面且没有消灭敌人/吃到樱桃时请求跳跃，不予起跳</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="玩家与收集物的交互，与敌人的交互。"><a href="#玩家与收集物的交互，与敌人的交互。" class="headerlink" title="玩家与收集物的交互，与敌人的交互。"></a>玩家与收集物的交互，与敌人的交互。</h2><h3 id="收集品、简单的UI"><a href="#收集品、简单的UI" class="headerlink" title="收集品、简单的UI"></a>收集品、简单的UI</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">using</span> UnityEngine.UI;<br><br><span class="hljs-keyword">public</span> Text diamondCount;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> diamond = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (collision.CompareTag(<span class="hljs-string">&quot;Cherry&quot;</span>)) &#123;<br>        Destroy(collision.gameObject);<br>        jumpCount++;<br>        isJumped = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 无论怎样离开地面，吃到樱桃后解锁跳跃条件</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (collision.CompareTag(<span class="hljs-string">&quot;Diamond&quot;</span>)) &#123;;<br>        Destroy(collision.gameObject);<br>        diamond++;<br>        diamondCount.text = diamond.ToString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h3><h4 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h4><p>首先创建所有敌人类的父类 Enemy，其中播放死亡动画和摧毁对象的方法对所有敌人来说都是通用的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> Animator animator;<br>    <span class="hljs-keyword">protected</span> Rigidbody2D rb;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> deathID;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        animator = GetComponent&lt;Animator&gt;();<br>        rb = GetComponent&lt;Rigidbody2D&gt;();<br>        deathID = Animator.StringToHash(<span class="hljs-string">&quot;Death&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Death</span>()</span> &#123;<br>        GetComponent&lt;Collider2D&gt;().enabled = <span class="hljs-literal">false</span>;<br>        rb.constraints = RigidbodyConstraints2D.FreezeAll;<br>        <span class="hljs-comment">// 沿所有轴冻结旋转和移动，保证Enemy不至于一边被玩家一脚踹飞一边播放死亡动画</span><br>        animator.SetTrigger(deathID);<br>    &#125;<br><br>    <span class="hljs-comment">// 在Death动画的结尾调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Disappear</span>()</span> &#123;<br>        Destroy(gameObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Frog类"><a href="#Frog类" class="headerlink" title="Frog类"></a>Frog类</h4><p>Frog 需要在一定范围内以跳跃的方式移动，这个坐标由他的两个子物体 leftPoint 和 rightPoint 提供。使用动画事件方便地使函数在正确的时机被调用。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnemyFrog</span> : <span class="hljs-title">Enemy</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform leftPoint, rightPoint;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> jumpForce;<br>    <span class="hljs-keyword">public</span> LayerMask ground;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> forwardLeft;<br><br>    <span class="hljs-keyword">private</span> Rigidbody2D body;<br>    <span class="hljs-keyword">private</span> Collider2D collisionBox;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> leftX, rightX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> jumpingID, fallingID;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-keyword">base</span>.Start();<br>        body = GetComponent&lt;Rigidbody2D&gt;();<br>        collisionBox = GetComponent&lt;Collider2D&gt;();<br>        leftX = leftPoint.position.x;<br>        rightX = rightPoint.position.x;<br>        Destroy(leftPoint.gameObject);<br>        Destroy(rightPoint.gameObject);<br>        <span class="hljs-comment">// 获取移动范围坐标后即可摧毁标志对象</span><br>        jumpingID = Animator.StringToHash(<span class="hljs-string">&quot;Jumping&quot;</span>);<br>        fallingID = Animator.StringToHash(<span class="hljs-string">&quot;Falling&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (animator.GetBool(jumpingID) &amp;&amp; body.velocity.y &lt;= <span class="hljs-number">0</span>) &#123;<br>            animator.SetBool(jumpingID, <span class="hljs-literal">false</span>);<br>            animator.SetBool(fallingID, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (animator.GetBool(fallingID) &amp;&amp; collisionBox.IsTouchingLayers(ground)) &#123;<br>            animator.SetBool(fallingID, <span class="hljs-literal">false</span>);<br>            body.velocity = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">movement</span>()</span> &#123;<span class="hljs-comment">// 在Idel动画的结尾调用</span><br>        <span class="hljs-keyword">if</span> (forwardLeft) &#123;<span class="hljs-comment">// 朝左</span><br>            <span class="hljs-keyword">if</span> (transform.position.x &lt;= leftX) &#123;<span class="hljs-comment">// 需要转身</span><br>                forwardLeft = <span class="hljs-literal">false</span>;<br>                transform.localScale = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            &#125;<br>            body.velocity = <span class="hljs-keyword">new</span> Vector2(-transform.localScale.x * speed, jumpForce);<br>            animator.SetBool(jumpingID, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 朝右</span><br>            <span class="hljs-keyword">if</span> (transform.position.x &gt;= rightX) &#123;<span class="hljs-comment">// 需要转身</span><br>                forwardLeft = <span class="hljs-literal">true</span>;<br>                transform.localScale = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            &#125;<br>            body.velocity = <span class="hljs-keyword">new</span> Vector2(-transform.localScale.x * speed, jumpForce);<br>            animator.SetBool(jumpingID, <span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="PlayerController类"><a href="#PlayerController类" class="headerlink" title="PlayerController类"></a>PlayerController类</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D collision</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (collision.gameObject.CompareTag(<span class="hljs-string">&quot;Enemy&quot;</span>)) &#123;<span class="hljs-comment">// 触敌</span><br>        <span class="hljs-keyword">if</span> (animator.GetBool(fallingID) &amp;&amp;<br>            transform.position.y - collision.transform.position.y &gt; <span class="hljs-number">0.35f</span>) &#123;<br><br>            <span class="hljs-comment">// 保证触敌时两者处于一个相对垂直的位置</span><br>            Enemy enemy = collision.gameObject.GetComponent&lt;Enemy&gt;();<br>            enemy.Death();<br>            body.velocity = <span class="hljs-keyword">new</span> Vector2(body.velocity.x, jumpForce);<br>            jumpCount = finalJumpCount;<br>            isJumped = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 无论怎样离开地面，消灭敌人后解锁跳跃条件</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 受伤</span><br>            isHurt = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 用于切换动画以及屏蔽受伤状态下移动相关的输入</span><br>            <span class="hljs-keyword">if</span> (transform.position.x &lt;= collision.transform.position.x) &#123;<span class="hljs-comment">// 右侧触敌</span><br>                body.velocity = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">-10f</span>, body.velocity.y + jumpForce * <span class="hljs-number">0.7f</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 左侧接敌</span><br>                body.velocity = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">10f</span>, body.velocity.y + jumpForce * <span class="hljs-number">0.7f</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对话框、运动透视、菜单中调节音量。"><a href="#对话框、运动透视、菜单中调节音量。" class="headerlink" title="对话框、运动透视、菜单中调节音量。"></a>对话框、运动透视、菜单中调节音量。</h2><h3 id="对话框提示"><a href="#对话框提示" class="headerlink" title="对话框提示"></a>对话框提示</h3><p>对话框的渐入渐出和移动由录制动画实现，通用的 Dialog 类挂载在一个 Trigger 上，负责动画的切换。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dialog</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject dialog;<br><br>    <span class="hljs-keyword">private</span> Animator animator;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> enterID,exitID;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        animator = dialog.GetComponent&lt;Animator&gt;();<br>        enterID = Animator.StringToHash(<span class="hljs-string">&quot;Enter&quot;</span>);<br>        exitID = Animator.StringToHash(<span class="hljs-string">&quot;Exit&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerStay2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (collision.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>) &amp;&amp; !dialog.activeSelf) &#123;<br>            dialog.SetActive(<span class="hljs-literal">true</span>);<br>            animator.SetBool(enterID, <span class="hljs-literal">true</span>);<br>            animator.SetBool(exitID, <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerExit2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (collision.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>            animator.SetBool(enterID, <span class="hljs-literal">false</span>);<br>            animator.SetBool(exitID, <span class="hljs-literal">true</span>);<br>            Invoke(<span class="hljs-string">&quot;setActiceFalse&quot;</span>, <span class="hljs-number">0.1f</span>);<span class="hljs-comment">//等待退出动画结束</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setActiceFalse</span>()</span> &#123;<br>        dialog.SetActive(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运动透视"><a href="#运动透视" class="headerlink" title="运动透视"></a>运动透视</h3><p>将这个脚本挂载在某一层背景上。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Parallax</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> Transform camera;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> moveRate;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> lockY;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> bgStartX, bgStartY;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> cmStartX, cmStartY;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span>&#123;<br>        bgStartX = transform.position.x;<br>        bgStartY = transform.position.y;<br><br>        cmStartX = camera.position.x;<br>        cmStartY = camera.position.y;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>        <span class="hljs-built_in">float</span> difX = camera.position.x - cmStartX;<br>        <span class="hljs-built_in">float</span> difY = camera.position.y - cmStartY;<br><br>        <span class="hljs-keyword">if</span> (lockY) &#123;<br>            transform.position = <span class="hljs-keyword">new</span> Vector2(bgStartX + difX * moveRate,<br>                transform.position.y);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            transform.position =<br>                <span class="hljs-keyword">new</span> Vector2(bgStartX + difX, bgStartY + difY) * moveRate;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="音量调节"><a href="#音量调节" class="headerlink" title="音量调节"></a>音量调节</h3><p>将所有 Source 输出到一个 Mixer 内，若想更新 Mixer 的属性（比如音量），需先将音频组检视面板中的属性暴露出来再 Set。再将该函数交由一 SliderUI 调用，动态地传入值即可。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetAudioVolume</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> volume</span>)</span> &#123;<br>    audioMixer.SetFloat(<span class="hljs-string">&quot;MainVolume&quot;</span>, volume);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://space.bilibili.com/370283072/channel/seriesdetail?sid=212003">M_Studio</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Input.html">Input</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Rigidbody2D.html">Rigidbody2D</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Physics2D.html">Physics2D</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/RigidbodyConstraints2D.html">RigidbodyConstraints2D</a><br><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Time-timeScale.html">timeScale</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Archive】Soul Forging, a Minecraft mod</title>
    <link href="/2021/08/07/SoulForging/"/>
    <url>/2021/08/07/SoulForging/</url>
    
    <content type="html"><![CDATA[<div class="note note-secondary">            <p>本模组所使用的 Forge 版本为 1.12.2-14.23.5.2847</p>          </div><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p><strong>欢迎使用SoulForging！</strong><br>&emsp;&emsp;这是一个关于灵魂和金属的模组，新的武器，新的盔甲，新的附魔，新的食物，新的村民，新的敌人等待着你的探索……</p><ul><li>以“使原版用处最小的金发挥作用”为切入点</li><li>添加新的金属锭“赋魂金”，数值高于钻石且拥有与金相同的附魔品质</li><li>为大部分实体添加新的掉落物</li><li><a href="http://school-works.test.upcdn.net/SoulForging-1.1.0.jar">cdn</a></li><li><a href="https://wwr.lanzoui.com/iZ9sSstof7i">蓝奏云</a> 密码: f4k8</li></ul><h2 id="一览"><a href="#一览" class="headerlink" title="一览"></a>一览</h2><p><img src="/img/SoulForging/yl.png"></p><h2 id="合成规则与烧炼规则"><a href="#合成规则与烧炼规则" class="headerlink" title="合成规则与烧炼规则"></a>合成规则与烧炼规则</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/SoulForging/zz_lhk.png"></div><div class="group-image-wrap"><img src="/img/SoulForging/zz_jj.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/SoulForging/zz_dhl.png"></div><div class="group-image-wrap"><img src="/img/SoulForging/zz_fhj.png"></div></div></div><h2 id="部分物品效果"><a href="#部分物品效果" class="headerlink" title="部分物品效果"></a>部分物品效果</h2><p><img src="/img/SoulForging/xg_jj.png" alt="灵魂结晶可以当作骨粉使用"><br><img src="/img/SoulForging/xg_wg.png" alt="甚至能增加经验，如此美味！"></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.mcmod.cn/class/4409.html">mc百科</a><br><a href="https://github.com/Hinageshi01/SoulForging">GitHub</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Forge</tag>
      
      <tag>Java</tag>
      
      <tag>mod</tag>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图形/引擎/渲染相关面经</title>
    <link href="/1970/02/01/Audition/"/>
    <url>/1970/02/01/Audition/</url>
    
    <content type="html"><![CDATA[<h2 id="网易互娱：游戏引擎研发工程师"><a href="#网易互娱：游戏引擎研发工程师" class="headerlink" title="网易互娱：游戏引擎研发工程师"></a>网易互娱：游戏引擎研发工程师</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><ul><li>class 与 struct 有什么区别？</li><li>了解过内存对齐吗，为什么要对齐，不对齐会怎样？<br><a href="https://blog.csdn.net/u014608280/article/details/79910820">struct 内存对齐</a><br><a href="http://www.cppblog.com/deercoder/archive/2011/03/13/141747.html">__declspec(align(#)) 的用法和大小计算</a></li><li><code>  struct TA &#123;   char a;   int b;   char c;   &#125;;   struct TB &#123;   char a;   char b;   int c;   &#125;;</code><br>这两个结构体的大小一样吗？</li><li>C++ 11 是什么，C++ 11 有什么新特性，说一下你对 C++ 11 的理解。<br><a href="https://blog.csdn.net/jiange_zh/article/details/79356417">C++11 常用新特性快速一览</a></li><li>C++ 的多态是怎么实现的？</li><li>虚函数是什么，什么时候应该用虚函数，虚函数是怎么实现的，虚函数表在哪，虚函数指针在哪？<br><a href="https://blog.csdn.net/weixin_40237626/article/details/82313339">虚函数实现原理</a><br><a href="https://blog.csdn.net/xiejingfa/article/details/50454819">C++ 虚函数实现原理</a></li></ul><h3 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h3><ul><li>简述一下渲染管线。</li><li>了解过线性颜色空间吗？<br><a href="https://zhuanlan.zhihu.com/p/35894054">GPU Gems 3 Chapter 24</a><br><a href="https://www.cnblogs.com/guanzz/p/7416821.html">Gamma 与线性颜色空间</a><br><a href="https://www.zhihu.com/question/27467127/answer/37602200">色彩校正中的 gamma 值是什么？</a><br><a href="https://www.zhihu.com/question/20084968">什么是线性</a><br><a href="https://64.github.io/tonemapping/">Tone Mapping</a><br><a href="https://blog.csdn.net/candycat1992/article/details/46228771/">我理解的伽马校正</a><br><a href="https://zhuanlan.zhihu.com/p/271011254">伽马还是线性？用一张图理理在U3D中该如何设置。</a><br><a href="https://zhuanlan.zhihu.com/p/21983679">Tone mapping 进化论</a></li><li>读 glsl，贴图采样、性能优化、高精度浮点。</li><li>了解过市面上游戏中的渲染技术吗？</li></ul><h2 id="搜狐畅游：引擎开发"><a href="#搜狐畅游：引擎开发" class="headerlink" title="搜狐畅游：引擎开发"></a>搜狐畅游：引擎开发</h2><ul><li>背面剔除怎么做的？</li><li>深度测试发生在那个阶段，了解过 Early-Z 吗？</li><li>推导一下 view 矩阵。</li><li>布林冯模型与冯模型哪个快？<br><a href="https://hinageshi01.github.io/2021/10/20/CGbasics/#phong">冯与布林冯</a></li><li>做过 IBL 吗？</li><li>了解过各类渲染优化吗？<br><a href="https://zhuanlan.zhihu.com/p/68158277">当我们谈优化时，我们谈些什么</a><br><a href="https://zhuanlan.zhihu.com/p/61358167">GPU 并行架构及渲染优化</a><br><a href="https://www.cnblogs.com/nafio/p/14101561.html">early-z、z-culling、hi-z、z-perpass 到底是什么</a><br><a href="https://zhuanlan.zhihu.com/p/135444145">延迟渲染与 MSAA 的那些事</a></li></ul><h2 id="腾讯：游戏客户端开发"><a href="#腾讯：游戏客户端开发" class="headerlink" title="腾讯：游戏客户端开发"></a>腾讯：游戏客户端开发</h2><ul><li>100 层高楼扔两个水晶球，设计一个算法，可以快速确定水晶球会摔碎的临界值。<br><a href="http://blog.sina.com.cn/s/blog_6c813dbd0101bh98.html#commonComment">100 层楼扔两个鸡蛋的问题</a></li><li>浮点数是怎么存储的？</li><li>STL库中 sort 底层实现、pow 底层实现?<br><a href="https://feihu.me/blog/2014/sgi-std-sort/">std::sort 源码剖析</a></li><li>快排复杂度是多少，有更快的吗，数学上怎么证明使用比较进行排序的时间复杂度不小于 O(nLog(n))？<br><a href="https://blog.csdn.net/developer1024/article/details/79770240">算法：排序算法之桶排序</a><br><a href="https://blog.csdn.net/micx0124/article/details/9852289">排序的最低时间复杂度为什么是 O(nlogn)</a><br><a href="https://www.zhihu.com/question/22393997">如何证明快速排序法的平均复杂度为 O(nlogn)？</a></li><li>两个进程处理一个数组，一个写入一个删除，怎么不冲突，怎么快？</li><li>哈希冲突了怎么办<br><a href="https://blog.csdn.net/wangwei249/article/details/70172811">哈希表及处理冲突的方法</a></li><li>模型描边几种做法，使用法线外扩时几次渲染？<br><a href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=11">GAMES202 Lecture 11</a><br>两次渲染，一次关闭深度写入画轮廓，第二次正常画模型。</li><li>工厂模式与抽象工厂区别？<br><a href="https://www.zhihu.com/question/20367734">抽象工厂模式和工厂模式的区别？</a></li><li>Unity 的协程用过吗？</li></ul><h2 id="快手：游戏图形开发"><a href="#快手：游戏图形开发" class="headerlink" title="快手：游戏图形开发"></a>快手：游戏图形开发</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>反转从位置 left 到位置 right 的链表节点<br><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">LeetCode 92. 反转链表 II</a></li><li>输出最长的不重复连续子串的长度<br><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode 3. 无重复字符的最长子串</a></li></ul><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><ul><li>什么是纯虚函数？</li><li>override 与 overload 有什么区别？</li><li>堆与栈有什么区别？<br><a href="https://www.cnblogs.com/hahawgp/archive/2013/04/08/3008737.html">c++ 中在堆和栈中申请空间的差别</a></li><li>map 与 set</li></ul><h3 id="图形学-1"><a href="#图形学-1" class="headerlink" title="图形学"></a>图形学</h3><ul><li>正交投影和透视投影的矩阵有什么区别？</li><li>法线贴图有什么意义，为什么法线贴图偏蓝色，TBN 矩阵怎么推导？<br><a href="https://hinageshi01.github.io/2021/10/20/CGbasics/#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E4%B8%8E%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE">切线空间与法线贴图</a></li><li>了解过抗锯齿吗，TAA 和 FXAA 是怎么做的？<br><a href="https://www.bilibili.com/video/BV1kY411P7QM">GAMES104 Lecture 7</a><br><a href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=14">GAMES202 Lecture 14</a></li><li>stencil 了解过吗？</li><li>pbr 材质公式包含哪几项，分别有什么意义，金属度影响的是哪一项？<br><a href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=10">GAMES202 Lecture 10 &amp; 11</a><br><a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">LearnOpenGL</a></li><li>阴影怎么做，软阴影怎么做，着色点是怎么对应到 ShadowMap 上的，平行光阴影怎么做？<br><a href="https://www.bilibili.com/video/BV1YK4y1T7yY?p=3">GAMES202 Lecture 1</a></li><li>glsl 写一个布林冯</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>最小生成树<br><a href="https://www.bilibili.com/video/BV1pT4y1v7Pm">【neko】最小生成树【算法编程#9】</a></li><li>进程与线程有什么区别<br><a href="https://www.zhihu.com/question/25532384/answer/81152571">线程和进程的区别是什么</a></li><li>虚拟内存<br><a href="https://zhuanlan.zhihu.com/p/96098896">如何理解虚拟内存</a></li><li>TCP&#x2F;IP，三次握手四次挥手</li><li>红黑树与平衡二叉树有什么区别</li><li>CPU 架构</li><li>CPU 调度机制</li></ul><h2 id="剑心互娱：渲染引擎开发工程师"><a href="#剑心互娱：渲染引擎开发工程师" class="headerlink" title="剑心互娱：渲染引擎开发工程师"></a>剑心互娱：渲染引擎开发工程师</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul><li>类似 <a href="https://leetcode-cn.com/problems/invert-binary-tree/">LeetCode 226. 翻转二叉树</a></li><li>类似 <a href="https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/">LeetCode 1503. 所有蚂蚁掉下来前的最后一刻</a><br>关键在于两只蚂蚁碰撞的时候会完全交换速度，就像他们互不影响地穿过去了一样。</li></ul><h3 id="C-2"><a href="#C-2" class="headerlink" title="C++"></a>C++</h3><ul><li>字符串长度？<br>有个 ‘\0’，要加一。</li><li>给出一段代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> *pBuffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">128</span>];<br>&#125;<br></code></pre></td></tr></table></figure>pBuffer 存储在什么内存区域，如果这个函数被执行多次会怎么样？<br><a href="https://blog.csdn.net/chenlycly/article/details/120958761">实例详解 C++ 程序的五大内存分区</a><br><a href="https://blog.csdn.net/chen1083376511/article/details/54930191">动态存储区、静态存储区、堆和栈的区别</a><br><a href="https://www.bilibili.com/video/BV1Ny4y1D7EE">【Cherno】Local Static in C++</a></li><li>父类虚函数 A，子类同名非虚函数（应该指的是同名不同参的函数），子类中虚函数表中存储的是哪个函数指针？<br><a href="https://hinageshi01.github.io/2022/01/24/CppPrimer13-16/#156-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F">虚函数与作用域</a></li><li>什么时候需要使用虚函数，父类的析构函数不是虚函数会怎么样？<br><a href="https://blog.csdn.net/starlee/article/details/619827">C++ 中虚析构函数的作用</a><br><a href="https://www.bilibili.com/video/BV1dK411w7Gg">【68】【Cherno C++】【中字】C++的虚析构函数</a><br>指向子类的父类类型指针无法调用子类的虚构函数，造成内存泄漏。</li><li>new 和 malloc 有什么区别，自由存储区是什么？<br><a href="https://isocpp.org/wiki/faq/freestore-mgmt#new-malloc-diff">【ISOCPP】What is the difference between new and malloc()?</a><br><a href="https://www.cnblogs.com/QG-whz/p/5140930.htmls">细说 new 与 malloc 的 10 点区别</a><br><a href="https://www.cnblogs.com/QG-whz/p/5060894.html">C++ 自由存储区是否等价于堆？</a><blockquote><p>堆是 C 语言和操作系统的概念，自由存储区是 C++ 中通过 new 动态分配对象的抽象概念。基本上，所有 C++ 编译器预设会使用对去实现自由存储区。但程序员也可以通过重载操作符改用其他方式实现自由存储区。<br>–《游戏引擎架构》</p></blockquote></li><li>内存池了解过吗？<br><a href="https://zhuanlan.zhihu.com/p/434087002">简单讲解 C++ 内存池原理与实现</a></li><li>引用和指针有什么区别，引用占内存空间吗？<br><a href="https://www.cnblogs.com/heyonggang/archive/2012/12/13/2815730.html">C++ 中指针和引用的区别</a><br><a href="https://www.cnblogs.com/ronny/p/3662556.html">你真的了解引用吗</a></li><li>结构体为什么要对齐，什么规则，#pragma pack() 的应用场合？<br><a href="https://www.jianshu.com/p/90a6eef329ec">#pragma pack 指令详解</a><br>关于应用场合，网上的文章清一色地表示：<blockquote><p>在网络协议编程中，经常会处理不同协议的数据报文。一种方法是通过指针偏移的方法来得到各种信息，但这样做不仅编程复杂，而且一旦协议有变化，程序修改起来也比较麻烦。在了解了编译器对结构空间的分配原则之后，我们完全可以利用这一特性定义自己的协议结构，通过访问结构的成员来获取各种信息。这样做，不仅简化了编程，而且即使协议发生变化，我们也只需修改协议结构的定义即可，其它程序无需修改，省时省力。</p></blockquote></li><li>模板优缺点有哪些？<br><a href="https://blog.csdn.net/tonychan129/article/details/21346713">使用 c++ 模板的优点和缺点</a><br><a href="https://blog.csdn.net/lijiayu2015/article/details/52650790">c++ 模板类声明和定义都放在 .h 文件的原因</a><br><a href="https://zhuanlan.zhihu.com/p/147623943">模板类在 .h 中定义，在 .cpp 中实现</a></li><li>红黑树和平衡二叉树有什么区别，红黑树什么情况比平衡二叉树快，什么情况慢？<br>插入删除快，查找慢</li><li>队列怎么实现？<br>数组双指针、双向链表</li><li>delete[] 是怎么知道数组长度的？<br><a href="https://isocpp.org/wiki/faq/compiler-dependencies#num-elems-in-new-array-overalloc">【ISOCPP】over-allocation</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* tmp = (<span class="hljs-type">char</span>*) <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[] (WORDSIZE + n * <span class="hljs-built_in">sizeof</span>(Fred));<br>Fred* p = (Fred*) (tmp + WORDSIZE);<br>*(<span class="hljs-type">size_t</span>*)tmp = n;<br><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 分配</span><br>&#125;<br><span class="hljs-built_in">catch</span>(...)&#123; ... &#125;<br></code></pre></td></tr></table></figure><a href="https://isocpp.org/wiki/faq/compiler-dependencies#num-elems-in-new-array-assocarray">【ISOCPP】associative array</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Fred* p = (Fred*) <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[] (n * <span class="hljs-built_in">sizeof</span>(Fred));<br><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 分配</span><br>&#125;<br><span class="hljs-built_in">catch</span>(...)&#123; ... &#125;<br><span class="hljs-comment">// arrayLengthAssociation is the imaginary name of a hidden, </span><br><span class="hljs-comment">// global associative array that maps from void* to size_t</span><br><span class="hljs-comment">// they maby use an AVL tree</span><br>arrayLengthAssociation.<span class="hljs-built_in">insert</span>(p, n);<br></code></pre></td></tr></table></figure></li><li>对 new[] 出来的数组做 delete 会怎样。<br><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-array">【ISOCPP】What if I forget the [] when deleteing an array allocated via new T[n]?</a><blockquote><p>All life comes to a catastrophic end.</p></blockquote><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-array-built-ins">【ISOCPP】Can I drop the [] when deleteing an array of some built-in type (char, int, etc)?</a><blockquote><p>But the above code is wrong, and it can cause a disaster at runtime. In particular, the code that’s called for delete p is operator delete(void*), but the code that’s called for delete[] p is operator delete<a href="void*"></a>. The default behavior for the latter is to call the former, but users are allowed to replace the latter with a different behavior (in which case they would normally also replace the corresponding new code in operator new<a href="size_t"></a>). If they replaced the delete[] code so it wasn’t compatible with the delete code, and you called the wrong one (i.e., if you said delete p rather than delete[] p), you could end up with a disaster at runtime.</p></blockquote>我并没有完全理解在这样的极端情况中具体会发生什么，这里仅记录一些测试结果。<br>在 VS2020 的测试中，对于基本数据类型数组来说，这么操作并不会引起内存泄漏。<br>对于自定义的数据类型数组，一旦为其定义了析构函数，便会报错：<code>Critical error detected c0000374</code>。<br>若没有定义析构函数，又在对象构造过程中发生了内存分配，便会产生内存泄漏。</li><li>new 出来的内存可以被 free 吗?<br><a href="https://isocpp.org/wiki/faq/freestore-mgmt#mixing-malloc-and-delete">【ISOCPP】Can I free() pointers allocated with new? Can I delete pointers allocated with malloc()?</a><blockquote><p>There is no guarantee that the mechanism used by new and delete to acquire and release raw memory is compatible with malloc() and free(). If mixing styles works on your system, you were simply “lucky” – for now.</p></blockquote></li><li>虚函数在虚函数表中是怎么匹配的？<br><a href="https://www.cnblogs.com/Allen-rg/p/6927319.html">虚函数底层原理</a></li><li>编译几个阶段？<br><a href="https://blog.csdn.net/wwxy1995/article/details/107869010">C&#x2F;C++ 程序编译的四个阶段</a></li><li>map 和 unorder_map 区别？<br><a href="https://zhuanlan.zhihu.com/p/210458185">map 和 unordered_map 的区别</a></li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li>最喜欢哪款游戏，为什么？</li><li>我看你 2077 和巫师三都玩过，你觉得 2077 相比于巫师三有哪些技术上的进步？</li><li>游戏中实时光追是怎么应用的？</li><li>UE5 演示视频看过吧，你觉得就画面来说还有哪些能够提升的地方，为什么人物相对于场景看起来那么不真实？</li><li>你觉得在游戏画面中哪部分最容易让人一眼察觉到画面的不真实？</li><li>mc 玩了多久，你觉得这个游戏开发过程中会有哪些技术难点，他是怎么呈现出这么大的一个世界的，世界中的方块是怎么存储的，实体之间的碰撞是怎么做的？</li><li>你之前的这个项目（一个 2D 平台跳跃游戏）你现在觉得有什么能改进的地方？</li></ul><h2 id="Bilibili：游戏引擎开发工程师"><a href="#Bilibili：游戏引擎开发工程师" class="headerlink" title="Bilibili：游戏引擎开发工程师"></a>Bilibili：游戏引擎开发工程师</h2><h3 id="图形学-2"><a href="#图形学-2" class="headerlink" title="图形学"></a>图形学</h3><ul><li>延迟渲染优缺点？<br><a href="https://zhuanlan.zhihu.com/p/28489928">延迟渲染（Deferred Rendering）的前生今世</a><br><a href="https://zhuanlan.zhihu.com/p/54694743">游戏引擎中的光照算法</a><br><a href="https://zhuanlan.zhihu.com/p/85615283">Forward+ Shading</a><br><a href="https://www.zhihu.com/question/366668747">延迟渲染为什么不支持 MSAA？</a><br><a href="https://www.zhihu.com/question/20236638/answer/44821615">FXAA、FSAA 与 MSAA 有什么区别？</a></li><li>ECS 了解过吗？<br><a href="https://www.bilibili.com/video/BV1YY4y1p74P">GAMES104 Lecture 3</a></li><li>PBR 相对于传统经验模型优缺点？<br><a href="https://www.bilibili.com/video/BV1J3411n7WT">GAMES104 Lecture 5</a><br><a href="https://game.academy.163.com/live?id=ga-1645069913225">E 星计划 光照综述</a></li><li>屏幕空间阴影了解过吗？<br><a href="https://blog.csdn.net/wodownload2/article/details/105202706">unity 屏幕空间阴影</a></li><li>级联阴影了解过吗？<br><a href="https://zhuanlan.zhihu.com/p/53689987">Cascaded Shadow Maps(CSM) 实时阴影的原理与实现</a><br><a href="https://zhuanlan.zhihu.com/p/45673049">Unity 实时阴影实现——Cascaded Shadow Mapping</a></li><li>HDR 了解过吗？<br><a href="https://www.bilibili.com/video/BV1VA41137Wp?p=2">百人计划 图形 2.7 LDR 与 HDR</a><br><a href="https://zhuanlan.zhihu.com/p/79203830">Tone Mapping 与 Gamma Correction</a><br><a href="https://www.bilibili.com/video/BV1kY411P7QM">GAMES104 Lecture 7</a></li><li>mesh shader 了解过吗？<br><a href="https://www.bilibili.com/video/BV1au411y7Fq">GAMES104 Lecture 6</a><br><a href="https://www.geeks3d.com/20200519/introduction-to-mesh-shaders-opengl-and-vulkan/">Quick Introduction to Mesh Shaders (OpenGL and Vulkan)</a><br><a href="https://www.zhihu.com/question/462023152/answer/1913213813">UE5 的 nanite 和 DX12U 的 meshshader 有什么不同？</a></li><li>光线追踪是怎么做的，离线光追有哪些加速策略，实时光追有哪些加速策略？<br>这里讲讲概念就给过了，展开讲我不会也讲不完。</li><li>测试分为哪几个部分，什么顺序？<br><a href="https://www.zhihu.com/question/384124671/answer/1121946801">深度测试&#x2F;模版测试&#x2F;透明度测试先后顺序是什么样的？</a><br><a href="https://zhuanlan.zhihu.com/p/263566318">用一篇文章理解半透明渲染、透明度测试和混合、提前深度测试并彻底理清渲染顺序。</a></li><li>有哪些降低 DrawCall 的手段，剔除分为哪几个部分，怎么做的？<br><a href="https://zhuanlan.zhihu.com/p/66407205">剔除：从软件到硬件</a><br><a href="https://zhuanlan.zhihu.com/p/74936111">【游戏场景剔除】剔除算法综述</a><br><a href="https://game.academy.163.com/live?id=ga-1645069975411">E 星计划 Lecture 6</a></li><li>移动端的 TBDR 了解过吗，有什么优缺点？<br><a href="https://zhuanlan.zhihu.com/p/259760974">IMR, TBR, TBDR 还有 GPU 架构方面的一些理解</a><br><a href="https://zhuanlan.zhihu.com/p/112120206">移动设备 GPU 架构知识汇总</a></li><li>Forward+ 了解过吗？</li><li>用 Unity 写过 Shader 吗，为什么选择学习 OpenGL？<br>面试官建议可以尝试一下新一点的图形 API，比如 Vulkan、DX12</li><li>Eigen 这个库的效率非常高，你觉得是为什么？<br><a href="https://www.zhihu.com/question/28571059">Eigen 的速度为什么这么快？</a><br><a href="https://eigen.tuxfamily.org/dox/TopicLazyEvaluation.html">Lazy Evaluation and Aliasing</a><br><a href="https://eigen.tuxfamily.org/dox/TopicInsideEigenExample.html">What happens inside Eigen, on a simple example</a></li><li>你觉得 C++11 中最重要的特性有哪些？<br>面试官又简单介绍了一些现代 C++ 的特性：rang、函数式编程、执行策略</li></ul><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><ul><li>快排优缺点，稳定吗，时间复杂度，空间复杂度，最坏什么情况？</li><li>堆排序优缺点？</li><li>这些排序算法怎么选择？<br><a href="https://blog.csdn.net/likefrank/article/details/2974949">各种排序算法的总结和比较</a></li><li>装箱开销体现在哪里？</li><li>map、unordered_map 中查询的时间复杂度是多少？</li><li>有哪些 hash 算法？</li></ul><h2 id="光线云：图形算法工程师"><a href="#光线云：图形算法工程师" class="headerlink" title="光线云：图形算法工程师"></a>光线云：图形算法工程师</h2><h3 id="图形学-3"><a href="#图形学-3" class="headerlink" title="图形学"></a>图形学</h3><ul><li>光栅化有哪些做法</li><li>VSM</li><li>平面反射</li><li>VBO、EBO、VAO</li><li>PBR 有哪些贴图<br>Albedo、Normal、Metallic、Roughness、AO</li></ul><h3 id="C-3"><a href="#C-3" class="headerlink" title="C++"></a>C++</h3><ul><li>STL 底层</li><li>C++ 异常</li><li>多线程</li><li>死锁怎么处理<br><a href="https://blog.csdn.net/wljliujuan/article/details/79614019">死锁，死锁的四个必要条件以及处理策略</a></li><li>哪些数据是一个线程私有的</li><li>红黑树底层<br><a href="http://data.biancheng.net/view/85.html">红黑树算法和应用</a></li><li>构造函数为什么不能是虚函数<br>对象未创建时不存在虚函数表指针。</li><li>智能指针</li><li>模板类</li></ul><h2 id="网龙：程序研究员"><a href="#网龙：程序研究员" class="headerlink" title="网龙：程序研究员"></a>网龙：程序研究员</h2><h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><ul><li>深度测试在什么空间</li><li>三角形内怎么进行插值，重心坐标怎么求</li><li>PBR 公式什么意义，怎么推导</li><li>法向量乘以变换向量逆矩阵的转置</li></ul><h3 id="C-4"><a href="#C-4" class="headerlink" title="C++"></a>C++</h3><ul><li>forward 和 move 的区别</li><li>线程 move</li><li>function 和 lambda 的区别</li><li>weak_ptr 怎么保证有效</li><li>unic_ptr 怎么实现</li><li>obj 文件左右手坐标系</li></ul><h3 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h3><ul><li>Unity 场景资源管理</li><li>M乘N 大小的矩阵，每个元素的值都是 X乘Y 的结果，怎么找到第 K 小的元素。</li><li>三维空间中有一个圆圈，已知圆上两点 A、B 以及过 A 点的切线，如何用线性代数的方式求圆心位置。</li></ul><h2 id="释厄：游戏引擎开发"><a href="#释厄：游戏引擎开发" class="headerlink" title="释厄：游戏引擎开发"></a>释厄：游戏引擎开发</h2><h3 id="C-5"><a href="#C-5" class="headerlink" title="C++"></a>C++</h3><ul><li>const 对象可以触发移动函数吗，为什么？</li><li>被 move 了的对象还能继续使用吗？</li></ul><h3 id="图形-1"><a href="#图形-1" class="headerlink" title="图形"></a>图形</h3><ul><li>为什么要使用双重缓冲？</li><li>模型数据从 CPU 到 GPU，再到最后的画面，会经历哪些空间转换？</li><li>使用 NDC 空间的目的是什么？</li><li>shader 在你的理解里是指什么？</li><li>为什么在 shader 中计算会比在 cpu 计算快？</li><li>写 shader 需要注意些什么？</li><li>为什么要避免分支，分支的开销在于什么？</li><li>CPU 传递给 shader 数据要注意些什么？</li><li>GPU Driven 是什么？</li><li>为什么经常用贴图去存储数据？</li><li>了解过现代化的图形api设计吗？</li><li>FrameGraph 定义了哪些 Stage 去划分一个 Pass 的流程？</li><li>FrameGraph 定义了哪些资源类型，来更好的管理动态资源，或者说资源的生命周期？</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/1970/01/01/HelloWorld/"/>
    <url>/1970/01/01/HelloWorld/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown-Test"><a href="#Markdown-Test" class="headerlink" title="Markdown Test"></a>Markdown Test</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>std::string str;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello CPP&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$\dot{z}&#x3D;b$</p><p>$$<br>L_o(x, \omega_o) &#x3D; L_e(x, \omega_o) + \int_\Omega f_r(x, \omega_i, \omega_o)L_i(x, \omega_i)(\omega_i\cdot n)d\omega_i<br>$$</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>这是一句话<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这是对应的脚注">[1]</span></a></sup></p><h2 id="便签"><a href="#便签" class="headerlink" title="便签"></a>便签</h2><div class="note note-primary">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-secondary">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-danger">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-warning">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-info">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><div class="note note-light">            <p>文字 或者 <code>markdown</code> 均可</p>          </div><h2 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h2><span class="label label-primary">text</span><h2 id="折叠快"><a href="#折叠快" class="headerlink" title="折叠快"></a>折叠快</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-b5714680" role="button" aria-expanded="false" aria-controls="collapse-b5714680">        <div class="fold-arrow">▶</div>title      </div>      <div class="fold-collapse collapse" id="collapse-b5714680">        <div class="fold-content">          <p>需要折叠的一段内容，支持 markdown</p>        </div>      </div>    </div><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><div>            <input type="checkbox"  checked="checked">text          </div><div>            <input type="checkbox"  >text          </div><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><a class="btn" href="https://roeas.github.io/2024/07/12/HelloWorld/"  title="title" target="_blank">text</a><h2 id="图组"><a href="#图组" class="headerlink" title="图组"></a>图组</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/hina.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/hina.png"></div><div class="group-image-wrap"><img src="/img/hina.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/hina.png"></div><div class="group-image-wrap"><img src="/img/hina.png"></div><div class="group-image-wrap"><img src="/img/hina.png"></div></div></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这是对应的脚注<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
